// @ts-nocheck
#!/usr/bin/env node
import{readFileSync,writeFileSync}from"node:fs";import{fileURLToPath}from"node:url";import{dirname,join}from"node:path";import yaml from"js-yaml";const __dirname=dirname(fileURLToPath(import.meta.url)),SRC=join(__dirname,"ruko.tmLanguage.yaml"),DEST=join(__dirname,"ruko.tmlanguage.js");function stripVerbose(e){let n="",t=0,r=!1;for(;t<e.length;){const i=e[t];if("\\"!==i)if("["!==i||r)if("]"===i&&r)r=!1,n+=i,t++;else if("#"!==i||r)!/\s/.test(i)||r?(n+=i,t++):t++;else for(;t<e.length&&"\n"!==e[t];)t++;else r=!0,n+=i,t++;else n+=i+(e[t+1]??""),t+=2}return n}function convertRegex(e){if(!e||"string"!=typeof e)return e;let n=e,t=!1;return(n.match(/^\s*\(\?x\)\s*/)||n.includes("\n"))&&(t=!0,n=n.replace(/^\s*\(\?x\)\s*/,""),n=stripVerbose(n)),n=replaceHexShorthand(n),n=n.replace(/\\p\{alnum\}/g,"[\\p{L}\\p{N}]"),n=n.replace(/\\P\{alnum\}/g,"[^\\p{L}\\p{N}]"),n=n.replace(/\\p\{digit\}/gi,"\\d"),n=n.replace(/\\P\{digit\}/gi,"\\D"),n=n.replace(/\\p\{space\}/gi,"\\s"),n=n.replace(/\\P\{space\}/gi,"\\S"),n=n.replace(/\\p\{word\}/gi,"\\w"),n=n.replace(/(?<!\\)\\N/g,"[^\\n\\r]"),n=n.replace(/\(\?i:/g,"(?:/* (?i) */"),n=n.replace(/\(\?x\)/g,""),n}function replaceHexShorthand(e){let n="",t=0,r=0;for(;t<e.length;){const i=e[t];if("\\"===i){const o=e[t+1]??"";if("h"===o){n+=r>0?"0-9a-fA-F":"[\\da-fA-F]",t+=2;continue}if("H"===o){n+=r>0?"^0-9a-fA-F":"[^\\da-fA-F]",t+=2;continue}n+=i+o,t+=2;continue}"["===i&&r++,"]"===i&&r>0&&r--,n+=i,t++}return n}function flagsFor(e){return"v"}function hasInlineFlags(e){return/\(\?\??(i|m|s|x|g):/i.test(e)}function jsStr(e){return e?JSON.stringify(e):'""'}function emitRegex(e){if(!e)return"null";const n=convertRegex(e);flagsFor(n);return`new RegExp("${n.replace(/\\/g,"\\\\").replace(/"/g,'\\"')}", "v")`}let indentLevel=0;const IND="  ";function indent(){indentLevel++}function dedent(){indentLevel--}function line(e){return IND.repeat(indentLevel)+e+"\n"}function emptyLine(){return"\n"}const REGEX_FIELDS=new Set(["match","begin","end","while"]),STRING_FIELDS=new Set(["name","contentName","comment","scopeName","include","applyEndPatternLast"]);function emitNode(e,n=0){if(null==e)return"null";if("boolean"==typeof e)return String(e);if("number"==typeof e)return String(e);if("string"==typeof e)return jsStr(e);if(Array.isArray(e)){if(0===e.length)return"[]";indent();const t=e.map(e=>line(emitNode(e,n+1)+","));return dedent(),"[\n"+t.join("")+IND.repeat(indentLevel)+"]"}const t=Object.keys(e);if(0===t.length)return"{}";indent();const r=t.map(t=>{const r=e[t];let i;return i=REGEX_FIELDS.has(t)?"string"==typeof r?emitRegex(r):emitNode(r,n+1):"captures"===t||"beginCaptures"===t||"endCaptures"===t?emitCaptures(r,n+1):"patterns"===t&&Array.isArray(r)?emitPatternsArray(r,n+1):"repository"===t&&"object"==typeof r?emitRepository(r,n+1):emitNode(r,n+1),line(`${jsKey(t)}: ${i},`)});return dedent(),"{\n"+r.join("")+IND.repeat(indentLevel)+"}"}function emitCaptures(e,n){if(!e||"object"!=typeof e)return"{}";indent();const t=Object.entries(e).map(([e,t])=>line(`${jsStr(e)}: ${emitNode(t,n+1)},`));return dedent(),"{\n"+t.join("")+IND.repeat(indentLevel)+"}"}function emitPatternsArray(e,n){if(!Array.isArray(e)||0===e.length)return"[]";indent();const t=e.map(e=>e&&"object"==typeof e&&e.include?line(`{ include: ${jsStr(e.include)} },`):line(emitNode(e,n+1)+","));return dedent(),"[\n"+t.join("")+IND.repeat(indentLevel)+"]"}function emitRepository(e,n){if(!e||"object"!=typeof e)return"{}";indent();const t=Object.entries(e).map(([e,t])=>line(`${jsKey(e)}: ${emitNode(t,n+1)},`));return dedent(),"{\n"+t.join("")+IND.repeat(indentLevel)+"}"}function jsKey(e){return/^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(e)?e:jsStr(e)}const yamlOptions={schema:yaml.DEFAULT_SCHEMA};function resolveThisRefs(e,n){return"string"!=typeof e?e:e.split("\n").some(e=>/(?<!\\)#this\./.test(e))?e.replace(/(?<!\\)#this\.(.+)$/gm,(e,t)=>{const r=t.trim().split(".");let i=n;for(const n of r){if(null==i||"object"!=typeof i)return e;const t=n.match(/^repository\['(.+?)'\]$|^repository\["(.+?)"\]$/);i=t?i.repository?.[t[1]??t[2]]:i[n]}return"string"==typeof i?i:String(i??"")}):e}function resolveAllRefs(e,n){if(!e||"object"!=typeof e)return e;if(Array.isArray(e))return e.forEach((t,r)=>{e[r]=resolveAllRefs(e[r],n)}),e;for(const t of Object.keys(e))REGEX_FIELDS.has(t)&&"string"==typeof e[t]?e[t]=resolveThisRefs(e[t],n):e[t]=resolveAllRefs(e[t],n);return e}function collectDefineFragments(e){const n=e?.repository?.define?.repository;if(!n||"object"!=typeof n)return{};const t={};for(const[e,r]of Object.entries(n)){const n=r?.match;if("string"==typeof n){t["DEF_"+e.replace(/-/g,"_").replace(/[^a-zA-Z0-9_]/g,"_").toUpperCase()]={key:e,pattern:n}}}return t}function main(){console.log("Reading YAML…");const e=readFileSync(SRC,"utf8");let n,t;console.log("Parsing YAML…");try{n=yaml.load(e,yamlOptions),t=yaml.load(e,yamlOptions)}catch(e){console.error("YAML parse error:",e.message),process.exit(1)}const r=collectDefineFragments(n);console.log("Resolving #this. template references…"),resolveAllRefs(t,n),function e(n){n&&"object"==typeof n&&(Array.isArray(n)?n.forEach(e):(delete n.define,delete n.comment,Object.values(n).forEach(e)))}(t),console.log("Emitting JS…");let i="";i+=`/**\n * ruko.tmlanguage.js\n * Auto-generated by build-grammar.mjs  —  DO NOT EDIT BY HAND.\n * Re-run \`node build-grammar.mjs\` to regenerate from ruko.tmLanguage.yaml.\n *\n * Exports the Ruko language TextMate grammar as a JS module compatible with\n * Shiki's JavaScript regex engine (@shikijs/engine-javascript).\n *\n * ┌─────────────────────────────────────────────────────────────────────────┐\n * │  All RegExps use the "v" flag (unicodeSets, requires Node ≥ 20 / V8    │\n * │  11.2+ / Chrome 112+).                                                  │\n * │                                                                         │\n * │  Onigmo → JavaScript conversion applied:                                │\n * │   (?x) verbose     → stripped (inline comments/whitespace removed)      │\n * │   (?>…) atomics    → kept (V8 10.0+ natively supports atomic groups)    │\n * │   \\g<name>/\\g<N>  → kept verbatim — NOT supported by JS; patterns     │\n * │                       containing \\g<> require manual expansion          │\n * │   \\h / \\H         → [\\da-fA-F] / [^\\da-fA-F]                       │\n * │   \\p{alnum}        → [\\p{L}\\p{N}]                                   │\n * │   \\N               → [^\\n\\r]                                         │\n * │   (?i:…)            → (?:…) with a /* (?i) */ comment; NOT             │\n * │                        case-insensitive — manual expansion required      │\n * │   && in char classes → kept (v-flag unicodeSets supports intersection)  │\n * └─────────────────────────────────────────────────────────────────────────┘\n *\n * Last updated: ${(new Date).toISOString().slice(0,10)}\n */\n\n`,i+="// ─── Extracted define-block fragments (from grammar.repository.define) ─────────\n",i+="// These correspond to Onigmo regex fragments that the YAML grammar reuses via\n",i+="// YAML anchors (&) and aliases (*). Exported for advanced consumers.\n\n";for(const[e,{key:n,pattern:t}]of Object.entries(r)){i+=`/** define.${n} */\n`,i+=`export const ${e} = "${convertRegex(t).replace(/\\/g,"\\\\").replace(/"/g,'\\"')}";\n`}i+="\n",i+="// ─── Well-known shared regex fragments ───────────────────────────────────────\n\n";const o={FRAG_IDENT:String.raw`(?>\`(?:\`\`|[^\`])*\`|\b[\p{L}\p{Nl}\p{Pc}]\w*\b)`,FRAG_ACCESSOR:String.raw`(?:[?!]?\.|[?!:]:|[?!-]>)=?`,FRAG_SQ_STR:String.raw`:?[@#%]*'(?:\\.|[^\\'])*'|:?[@#$%]*'(?:''|[^'])*'`,FRAG_DQ_STR:String.raw`:?[@#%]*"(?:\\.|[^\\"])*"|:?[@#$%]*"(?:""|[^"])*"`,FRAG_NUM_DEC:String.raw`\d(?:[\d\p{Pc}]*\d)?(?:\.\d(?:[\d\p{Pc}]*\d)?|\/\d(?:[\d\p{Pc}]*\d)?)?(?:\\?e[+\-]?\d(?:[\d\p{Pc}]*\d)?|\\?p[+\-]?\d(?:[\d\p{Pc}]*\d)?)?`,FRAG_NUM_HEX:String.raw`0x[\da-fA-F](?:[\da-fA-F\p{Pc}]*[\da-fA-F])?(?:\.[\da-fA-F](?:[\da-fA-F\p{Pc}]*[\da-fA-F])?|\/[\da-fA-F](?:[\da-fA-F\p{Pc}]*[\da-fA-F])?)?(?:\\?e[+\-]?[\da-fA-F](?:[\da-fA-F\p{Pc}]*[\da-fA-F])?|\\?p[+\-]?\d(?:[\d\p{Pc}]*\d)?)?`,FRAG_NUM_BIN:String.raw`0b[01](?:[01\p{Pc}]*[01])?(?:\.[01](?:[01\p{Pc}]*[01])?|\/[01](?:[01\p{Pc}]*[01])?)?(?:\\?e[+\-]?[01](?:[01\p{Pc}]*[01])?|\\?p[+\-]?\d(?:[\d\p{Pc}]*\d)?)?`,FRAG_NUM_OCT:String.raw`0o[0-7](?:[0-7\p{Pc}]*[0-7])?(?:\.[0-7](?:[0-7\p{Pc}]*[0-7])?|\/[0-7](?:[0-7\p{Pc}]*[0-7])?)?(?:\\?e[+\-]?[0-7](?:[0-7\p{Pc}]*[0-7])?|\\?p[+\-]?\d(?:[\d\p{Pc}]*\d)?)?`,FRAG_NUM_DUODEC:String.raw`0z[\dab](?:[\dab\p{Pc}]*[\dab])?(?:\.[\dab](?:[\dab\p{Pc}]*[\dab])?|\/[\dab](?:[\dab\p{Pc}]*[\dab])?)?(?:\\?e[+\-]?[\dab](?:[\dab\p{Pc}]*[\dab])?|\\?p[+\-]?\d(?:[\d\p{Pc}]*\d)?)?`,FRAG_NUM_ARB:String.raw`(?!0)\d+b[\p{L}\p{N}](?:[\p{L}\p{N}\p{Pc}]*[\p{L}\p{N}])?(?:\.[\p{L}\p{N}](?:[\p{L}\p{N}\p{Pc}]*[\p{L}\p{N}])?|\/[\p{L}\p{N}](?:[\p{L}\p{N}\p{Pc}]*[\p{L}\p{N}])?)?(?:\\?e[+\-]?[\p{L}\p{N}](?:[\p{L}\p{N}\p{Pc}]*[\p{L}\p{N}])?|\\?p[+\-]?\d(?:[\d\p{Pc}]*\d)?)?`,FRAG_NUM_ALL:null};for(const[e,n]of Object.entries(o)){if(null===n)continue;i+=`export const ${e} = String.raw\`${n.replace(/\\/g,"\\\\").replace(/`/g,"\\`").replace(/\$\{/g,"\\${")}\`;\n`}i+="\n/** All numeric literal bases — use as an alternation in larger patterns. */\n",i+="export const FRAG_NUM_ALL = [\n",i+="  FRAG_NUM_ARB, FRAG_NUM_BIN, FRAG_NUM_OCT, FRAG_NUM_DUODEC,\n",i+="  FRAG_NUM_HEX, FRAG_NUM_DEC,\n",i+='].map(f => `(?:${f})`).join("|");\n',i+="\n// ─────────────────────────────────────────────────────────────────────────────\n\n",i+="/**\n",i+=" * Ruko language grammar object.\n",i+=" * Compatible with Shiki's \\@shikijs/engine-javascript RegExp engine.\n",i+=" * @type {import('shiki').LanguageRegistration}\n",i+=" */\n",i+="export const grammar = ",indentLevel=0,i+=emitNode(t),i+=";\n",i+="\nexport default grammar;\n",console.log(`Writing ${DEST}…`),writeFileSync(DEST,i,"utf8");const a=i.split("\n").length;console.log(`Done. ${a.toLocaleString()} lines written to ${DEST}`)}main();