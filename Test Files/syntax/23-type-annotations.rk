\* ============================================================
   23 — TYPE ANNOTATIONS & DECLARATIONS
   Corresponds to: ruko.tmLanguage.yaml lines 7251–8095
   All typed-binding, typed-declaration, and variable-
   declaration forms with full type annotation syntax.
   ============================================================ *\

// ============================================================
// SIMPLE TYPED VARIABLE DECLARATIONS
// ============================================================

// C-style: type before name
let int n = 42
let str s = "hello"
let f64 pi = 3.14159
let bool flag = true

// Rust-style: colon annotation
let n2: int = 42
let s2: str = "hello"
let pi2: f64 = 3.14159
let flag2: bool = true

// mut, val, var, const forms
mut  counter: int = 0
val  answer:  int = 42
var  cursor:  int = 0
const MAX:    int = 1000

// Inferred (no annotation required)
let inferred = 12345         // int
let inferred2 = "world"      // str

// ============================================================
// COLLECTION TYPES
// ============================================================

// Array types
let []int   arr1 = [1, 2, 3]
let arr2: []int = [1, 2, 3]

let [5]f64  vec5 = [0.0, 1.0, 2.0, 3.0, 4.0]   // fixed size
let vec6: [5]f64 = [0.0, 1.0, 2.0, 3.0, 4.0]

// Nested arrays
let [][]str grid1: [][]str = [["a"], ["b", "c"]]

// Tuple types
let (int, str) pair1 = (42, "hello")
let pair2: (int, str) = (42, "hello")

let (f64, f64, f64) triple1 = (1.0, 2.0, 3.0)
let triple2: (f64, f64, f64) = (1.0, 2.0, 3.0)

// Dict / map types
let {str: int}  wordCounts: {str: int}  = {"hello": 1, "world": 2}
let {int: []str} groupMap = {}

// ============================================================
// OPTIONAL AND RESULT TYPES
// ============================================================

// Optional: T?
let name: str? = null
let maybe: int? = Some(5)
let nothing: bool? = None

// Result: T!  (can either be the value or an error)
let r1: int! = Okay(42)
let r2: str! = Error("oops")

// Chained optional
let nested: str?? = null     // doubly optional
let deep: {str: int?}? = null

// ============================================================
// POINTER / REFERENCE TYPES
// ============================================================

let raw_ptr: *int = ptr_of(value)
let mut_ptr: *mut int = ptr_of(value)
let con_ptr: *const int = ptr_of(c)

let ref_val: &int = &value
let mut_ref: &mut int = &mut value

// ============================================================
// FUNCTION TYPES
// ============================================================

// Function type annotation
let fn_type:   fn(int, int): int   = |a, b| a + b
let async_fn:  async fn(str): void = async |s| print(s)
let pure_fn:   pure fn(f64): f64   = |x| x * x

// Named parameter types (not applied)
type Comparator<T> = fn(T, T): int
type Reducer<T, U> = fn(U, T): U
type Predicate<T>  = fn(T): bool

// ============================================================
// GENERIC TYPES
// ============================================================

// Generic type parameters
let list3: Vec<int> = Vec.new()
let set1:  Set<str> = Set.new()
let pair3: Pair<int, str> = Pair.new(1, "one")
let map2:  Map<str, []int> = Map.new()

// Nested generics
let nested2: Vec<Vec<str>> = Vec.new()
let either:  Either<int, str> = Left(42)
let either2: Either<int, str> = Right("hello")

// ============================================================
// FUNCTION DECLARATIONS WITH TYPE ANNOTATIONS
// ============================================================

// C-style prefix types
func int_add(int a, int b): int { a + b }

// Rust-style colon annotations
func f_add(a: int, b: int): int { a + b }

// Mixed
func mixed(int a, b: int): int { a + b }

// Generic function
func identity<T>(T x): T { x }
func zip2<A, B>([]A as2, []B bs): [](A, B) { as2.zip(bs) }

// Constrained type parameter
func sort2<T: Ord>([]T xs): []T { xs.sorted() }
func clamp2<T: Ord + Copy>(T v, T lo, T hi): T {
  if v < lo: lo
  elif v > hi: hi
  else: v
}

// Multiple constraints
func printSorted<T: Ord + Display + Clone>([]T xs): void {
  xs.sorted().each(print)
}

// Higher-kinded type simulation
func map2<T, U>([]T xs, fn(T): U f): []U { xs.map(f) }
func flatMap<T, U>([]T xs, fn(T): []U f): []U { xs.flatMap(f) }

// ============================================================
// TYPED DESTRUCTURING IN DECLARATIONS
// ============================================================

// Object destructuring with types
let {x: int, y: int, z: int} = vec3
let {name3: str, age: int} = user

// Tuple destructuring with types
let (int a, int b, int c) = triple1
let (f64 lat, f64 lon) = coord

// Array destructuring with types
let [int head2, []int ..rest] = numbers
let [str first_word, str second_word] = words

// ============================================================
// TYPE ALIASES AND SYNONYMS
// ============================================================

type ID   = int
type Name = str
type Vec2 = (f64, f64)
type Vec3 = (f64, f64, f64)
type Matrix4 = [4][4]f64
type Callback<T> = fn(T): void
type Maybe<T> = T?
type Result2<T, E> = T | E
type Nullable<T> = T | null

// ============================================================
// COMPLEX INLINE TYPES
// ============================================================

// Union types
let intOrStr: int | str = 42
let maybe2: int | null = null
let multi:  int | f64 | str | bool = 3.14

// Intersection (implied via impl/has)
func printAll<T: Display + Serialize>(T val): void {}

// Literal / singleton types
let yes: :ok = :ok
let no:  :err = :err
let num: 42 = 42        // literal type
let flag3: true = true  // boolean literal type

// ============================================================
// VARIABLE DECLARATIONS WITH COMPLEX EXPRESSIONS
// ============================================================

let sum3    = arr.fold(0, |a, b| a + b)
let maxVal  = arr.max() ?? 0
let words   = text.split(" ").filter(|w| w.len() > 0)
let doubled = [1, 2, 3].map(|x| x * 2)
let config  = Config{host: "localhost", port: 8080}
