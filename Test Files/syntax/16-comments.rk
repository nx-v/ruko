\* ============================================================
   16 — COMMENTS
   Corresponds to: ruko.tmLanguage.yaml lines 5139–5204
   Line comments, block comments, doc comments, nested
   block comments, and Markdown rendering inside comments.
   ============================================================ *\

// ----- Line comment -----
// This is a single-line comment. Everything after // is ignored.
let x = 10   // inline comment after code

// Continuation does not apply — each // starts fresh.
// Line 1
// Line 2
// Line 3

// ----- Block comment -----
/* This is a block comment.
   It spans multiple lines.
   Ends at the closing delimiter. */

let y = /* inline block comment */ 20

/* Single-line block */ let z = 30

// ----- Nested block comments -----
/* outer comment start
   /* inner comment start
      content inside inner
   */ inner comment end
   still inside outer
*/ // outer comment end

/* level 1 /* level 2 /* level 3 */ back to 2 */ back to 1 */

// ----- Documentation line comment  (///) -----
/// A single-line doc comment.
/// Appears before a declaration.
/// Multiple lines combine into one doc block.
/// **bold**, *italic*, `code` — Markdown rendered.
func square(int n): int { n * n }

/// Standalone doc line comments can appear anywhere.
/// These describe the next declaration.
/// Parameters:
/// - `n: int` — the base value
/// Returns: `n * n`
func docuSquare(int n): int { n * n }

// ----- Documentation block comment  (/** ... */) -----
/**
 * Full JSDoc-style block comment.
 * @param n - the input number
 * @returns n squared
 */
func jsDocSquare(int n): int { n * n }

/**
 * @class Point
 * @description A 2D point with x and y coordinates.
 */
class Point {
  /**
   * @property x - horizontal coordinate
   */
  val x: f64

  /**
   * @property y - vertical coordinate
   */
  val y: f64

  /**
   * @constructor
   * @param x - x value
   * @param y - y value
   */
  new func(f64 x, f64 y) {
    self.x = x
    self.y = y
  }

  /**
   * @method dist - Euclidean distance to another point
   * @param other - the target point
   * @returns distance as f64
   * @example
   * let p = Point.new(0, 0)
   * let q = Point.new(3, 4)
   * p.dist(q)   // 5.0
   */
  func dist(Point other): f64 {
    let dx = self.x - other.x
    let dy = self.y - other.y
    (dx * dx + dy * dy).sqrt()
  }
}

// ----- Markdown inside doc comments -----
/// # Overview
/// This module provides **sorting** utilities.
///
/// ## Usage
///
/// ```
/// let sorted = mergeSort([3, 1, 2])
/// ```
///
/// See [sorting theory](https://en.wikipedia.org/wiki/Sorting_algorithm).
module Sort {
  /// Sorts an array using merge sort.
  /// - Time: $O(n \log n)$
  /// - Space: $O(n)$
  func []T mergeSort<T: Ord>([]T xs) {
    if xs.len() <= 1: xs
    else {
      let mid = xs.len() / 2
      let left  = mergeSort(xs[..mid, ])
      let right = mergeSort(xs[, ..mid])
      merge(left, right)
    }
  }
}

// ----- Disabled code via block comment -----
/*
func oldImpl(int n): int {
  var acc = 0
  for i in 0 ..< n {
    acc += i
  }
  acc
}
*/

// ----- todo / fixme / note / hack inline annotations -----
// TODO: implement caching
// FIXME: off-by-one on line 42
// NOTE: this assumes sorted input
// HACK: workaround for compiler bug
// DEPRECATED: use newFn() instead
