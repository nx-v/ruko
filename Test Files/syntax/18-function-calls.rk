\* ============================================================
   18 — FUNCTION CALLS
   Corresponds to: ruko.tmLanguage.yaml lines 5380–5885
   Paren calls, piped calls, parenless calls, method chains,
   named arguments, generic calls, and special suffixed calls.
   ============================================================ *\

// ----- Standard paren call -----
let r1 = foo()
let r2 = bar(1, 2, 3)
let r3 = baz("hello", true, null)
let r4 = Math.sqrt(144.0)
let r5 = List.new(10)

// ----- Multi-line paren call -----
let r6 = compute(
  x: 10,
  y: 20,
  z: 30,
)

// ----- Named argument call -----
let r7  = open(path: "data.csv", mode: :read)
let r8  = connect(host: "localhost", port: 5432, ssl: false)
let r9  = Box.new(width: 200px, height: 100px, color: %#FF0000)
let r10 = animate(`from`: 0, to: 100, duration: 300ms, easing: :linear)

// ----- Generic call -----
let r11 = identity<int>(42)
let r12 = parse<Config>(jsonStr)
let r13 = Vec.new<str>()
let r14 = zip<int, str>(numbers, names)

// ----- Method chain call -----
let r15 = [1, 2, 3]
  .map(|x| x * 2)
  .filter(|x| x > 2)
  .fold(0, |acc, x| acc + x)

let r16 = text
  .trim()
  .toLower()
  .replace(/\s+:"-"/)
  .slice(0, 50)

// ----- Optional chain call -----
let r17 = user?.getAddress()?.city
let r18 = map?.get("key")?.toLower()
let r19 = obj?.(dynamicMethod)()
let r20 = arr?.[0]?.name

// ----- Force-unwrap chain call -----
let r21 = cfg!.database!.password
let r22 = arr!.[0]!.toLower()

// ----- Pipeline operator call -----
let r23 = 10 |> double
let r24 = "hello" |> trim |> toUpper
let r25 = [1, 2, 3] |> sort |> reverse |> first

let r26 = data
  |> parse
  |> validate
  |> transform
  |> persist

// ----- Reverse pipeline -----
let r27 = double <| 10
let r28 = toUpper <| "hello"

// ----- Piped with arguments (partial application) -----
let r29 = list |> map(|x| x * 2)
let r30 = list |> filter(|x| x > 0) |> sum

// ----- Parenless / bracketless call -----
// Function call with arguments and no parentheses (low-precedence)
print "Hello, World!"
log :error, "Something went wrong"
push arr, 42
assert n > 0, "n must be positive"

// ----- Argument-less parenless -----
// zero-arg parenless call when preceded by known function name
// (grammar: `function-name space* eol` form)
sort arr
reverse list
clear map
close handle

// ----- Embedded / method call with `·` (middle-dot) -----
let r31 = xs ·map |x| x * 2
let r32 = y ·fold 0, |acc, x| acc + x

// ----- Spread in call -----
let r33 = f(*args)
let r34 = g(1, *rest, last: true)
let r35 = h(**namedArgs)

// ----- Lambda as last argument (trailing) -----
let r36 = map(list) |x| x * 2
let r37 = filter([1, 2, 3]) |x| x > 1
let r38 = reduce(arr, 0) |acc, x| acc + x

// ----- Suffixed calls -----
// ! macro call
let r39 = format! "Error: {}" msg
let r40 = vec! [1, 2, 3]
let r41 = panic! "unreachable"

// ~ destructor call
let r42 = obj~()
let r43 = buffer~()

// * generator call
let r44 = genRange*(0, 100)
let r45 = iter*(collection)

// ----- Mutating method call  .= -----
arr.=push(42)
map.=insert("key", :value)
set.=remove(item)

// ----- Constructor calls  new -----
let pt  = new Point(3, 4)
let box = new Box(width: 100, height: 50)
let arr2 = new [10]int(0)        // [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]

// ----- Async call -----
let r46 = await fetch("https://api.example.com/data")
let r47 = await Promise.all([fetchA(), fetchB(), fetchC()])

// ----- Call with type parameter inferred -----
let r48 = fromJson(raw)           // T inferred from context
let r49: []int = fromJson(raw)    // T = []int inferred from binding

// ----- Named + positional mix -----
let r50 = lerp(a, b, t: 0.5)
let r51 = slice(arr, start: 2, end: 8, step: 1)

// ----- Macro / quote calls -----
let q1 = quote { 1 + 1 }
let q2 = macro! do_thing
let e1 = eval! #{expr}

// ----- Inline IIFE-style -----
let r52 = (|x| x * x)(7)       // = 49
let r53 = (func(int n): int { n + 1 })(41)  // = 42