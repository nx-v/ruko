\* ============================================================
   02 — SHARED DEFINITIONS & IDENTIFIERS
   Corresponds to: ruko.tmLanguage.yaml lines 352–761
   Core reusable patterns: identifiers, type annotations,
   access modifiers, and the keyword list.
   ============================================================ *\

// ----- Ordinary identifiers -----
// Must start with a letter, unicode letter, or connector (_).
// May contain letters, digits, connectors.
let camelCase   = 1
let PascalCase  = 2
let snake_case  = 3
let _leading    = 4
let café        = 5   // unicode letters allowed
let α           = 6   // greek letters ok
let ñoño        = 7

// ----- Backtick-escaped identifiers -----
// Any sequence of characters (except unescaped backtick) can
// be used as an identifier by surrounding it with backticks.
// This lets reserved keywords be used as variable names.
let `set`   = {1, 2, 3}
let `const` = 42
let `let` mut `mut`: `in` i32 = 10
let `user name` = "Alice"      // spaces allowed inside backticks
let `+` = |a, b| a + b        // operators as identifiers
let `hello world` = "hi"

// Backtick identifiers can be doubled internally to escape:
let `it``s fine` = true        // literal backtick inside = ``

// ----- Access / visibility modifiers -----
// Used before declarations to control visibility.
pub let x = 1          // public
prot let y = 2         // protected
stat let z = 3         // static
pub stat let k = 4     // public static
intern let w = 5       // internal (package-private)
extern let v = 6       // external (foreign binding)
local let u = 7        // local scope only
global let t = 8       // global scope

// ----- Storage / mutability modifiers -----
mut let a = 0          // mutable binding
immut let b = 0        // explicitly immutable
shared let c = 0       // shared ownership
unique let d = 0       // unique ownership
owned let e = 0        // owned value

// ----- Lifetime / storage-class modifiers -----
static let counter = 0
volatile let reg = 0
thread let tls = 0
atomic let flag = false

// ----- Function behaviour modifiers -----
pure func int square(int n) { n * n }
async func loadFile(str path): str { await readFile(path) }
rec func int fib(int n) { if n <= 1: n else: fib(n-1) + fib(n-2) }
gen func int* range(int n) { for let i in 0 ..< n: yield i }
inline func int inc(int n) { n + 1 }
unsafe func void poke(*mut u8 p, u8 v) { *p = v }

// ----- Type modifiers -----
abstract class Shape { }
final class Circle : Shape { }
sealed class Result<T> { }

// ----- Prefix type annotations (C-style) -----
// A type name directly before an identifier annotates its type.
let i32 x2 = 10
let f64 pi = 3.14159
let str msg = "hello"
let bool ok = true
let []int xs = [1, 2, 3]

// ----- Postfix type annotations (Rust-style) -----
// A colon after the identifier followed by a type.
let x3: i32 = 10
let pi2: f64 = 3.14159
let msg2: str = "hello"
let ok2: bool = true
let xs2: []int = [1, 2, 3]

// ----- Mixed annotation -----
let (y: int | str, str b2, f64 c2) = (42, "hello", 3.14)
