\* ============================================================
   27 — BINDING COMPONENTS
   Corresponds to: ruko.tmLanguage.yaml lines 8570–8679
   binding-as-keyword, binding-pattern-object, -tuple, -array:
   all combined forms, punning, key renaming, and splice syntax.
   ============================================================ *\

// ============================================================
// BINDING-AS-KEYWORD
// ============================================================

// Standard `as` in let binding
let result as backup = riskyOp()       // result bound to both names
let xs as orig = transform(input)      // xs, also accessible as orig

// `as` in pattern arms
match node {
  | Branch(left, right) as tree: process(tree, left, right)
  | Leaf(val) as leaf: process(leaf, val)
}

// `as` in for loop
for event as prev_event in event_log {
  compare(event, prev_event)
}

// `as` in catch
try {
  dangerousOp()
} catch {
  | RuntimeError as e: print(e.message)
  | else as e: print(e)
}

// `as` in import
use Http as H
use Http{ get as httpGet, post as httpPost } 

// ============================================================
// BINDING-PATTERN-OBJECT: FULL FORMS
// ============================================================

// Punning (variable == field name)
let {x, y} = point
let {name, age, email} = user

// Explicit renaming with :
let {x: px, y: py} = point
let {name: username, age: years} = user

// Mixed punning + renaming
let {name, email: contact, age: years2} = user

// Nested objects
let {address: {city, country, zip}} = user
let {meta: {author: {name: authorName}}} = doc

// Default values in object patterns
let {name: n, title = "Mx."} = person
let {port = 5432, host = "localhost"} = config

// Rest in object pattern
let {id, name: name2, ..rest} = record

// Optional fields
let {name: n3, email? , phone?} = contact

// Type-annotated object pattern
let {x: int, y: int, z: int} = vec3_obj
let {name: str, scores: []int} = player

// Object pattern in function param
func printUser({name, age, title = "Mx."}: User): void {
  print(#"#title #name, age #age")
}

// Object pattern in case arm
match event {
  | is {type: :click, x, y}: handleClick(x, y)
  | is {type: :keydown, key: k, shift}: handleKey(k, shift)
  | is {type: :resize, width: w, height: h}: resize(w, h)
}

// ============================================================
// BINDING-PATTERN-TUPLE: FULL FORMS
// ============================================================

// Simple ordered
let (a, b)       = pair
let (x2, y2, z2) = triple

// Ignoring elements
let (first, _)    = pair
let (_, second)   = pair
let (h, _, last2) = triple

// With types
let (int m, int n2)    = int_pair
let (str label, f64 val2) = labeled_value

// Nested tuples
let ((x3, y3), z3) = nested3
let (a2, (b2, c2)) = right_nested

// Tuple pattern in function param
func addTuple((int a, int b)): int { a + b }
func swapFn((int x, int y)): (int, int) { (y, x) }

// Tuple pattern in case arm
match result {
  | is (:ok, |val|): use(val)
  | is (:err, |msg|): logError(msg)
  | is (:pending, |pct|): showProgress(pct)
}

// Tuple pattern in for loop
for (k, v) in pairs { print(#"#k => #v") }
for (idx, item) in list.enumerate() { print(#"#{idx}: #item") }

// ============================================================
// BINDING-PATTERN-ARRAY: FULL FORMS
// ============================================================

// Single element
let [h] = char_arr

// Head / tail
let [first2, ..rest] = list

// First N elements
let [a3, b3, c3] = three_arr

// First N + rest
let [a4, b4, ..tail] = arr

// Init + last
let [..init, last3] = arr

// Specific + rest
let [a5, _, c4, ..more] = arr     // skip second element

// Typed
let [int h2, ..int[] t2] = int_arr
let [str word, ..str[] words2] = word_list

// Nested arrays
let [[x4, y4], [x5, y5]] = matrix_row
let [[r, g, b], ..others] = color_list

// Array pattern in function param
func headFn([h, ..]): auto { h }
func firstTwo([a, b, ..]): (auto, auto) { (a, b) }

// Array pattern in case arm
match list {
  | []: "empty"
  | [x]: #"singleton: #x"
  | [x, y]: #"pair: #x, #y"
  | [x, y, z]: #"triple: #x #y #z"
  | [h, ..t]: #"head=#h, rest len=#(t.len())"
}

// ============================================================
// SPLICE SYNTAX: #(..) #[..] #{}
// ============================================================

// #(..) — tuple splice inside templates / macros
let t1 = #(a, b, c)                  // spliced tuple literal
let t2 = #(x + 1, y - 1)            // computed splice
macro product($vals: ..) { #($vals) }

// #[..] — array splice
let arr2 = #[1, 2, 3]
let arr3 = #[*existing, 4, 5]        // spread + append

// #{..} — object splice
let obj = #{x: 1, y: 2}
let obj2 = #{*base_obj, z: 3}        // spread + extend

// Splice in JSX
let items = [1, 2, 3]
let el = <ul>#[items.map(|i| <li>#i</li>)]</ul>

// Splice in interpolated strings
let msg = #"Values: #(a, b, c)"
let msg2 = #"Items: #[items]"

// Splice in macro rules
macro log_all($vals: ..) {
  #($vals).each(|v| print(v))
}

// ============================================================
// COMBINED: OBJECT + ARRAY + TUPLE
// ============================================================

// Object containing array
let {tags: [primary, ..secondary]} = post

// Array of objects
let [{id: id1, name: name3}, {id: id2, name: name4}] = two_users

// Object containing tuple
let {origin: (ox, oy), size: (w, h)} = rect_data

// Tuple of arrays
let ([a6, b6], [c5, d5]) = two_arrays

// Deeply nested
let {
  meta: {
    author: {name: authorN},
    tags: [mainTag, ..moreTags]
  },
  body: {
    sections: [intro, ..bodyParts],
    conclusion
  }
} = document
