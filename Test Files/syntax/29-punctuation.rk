\* ============================================================
   29 — PUNCTUATION & BRACKETS
   Corresponds to: ruko.tmLanguage.yaml lines 8691–9176
   All bracket forms, accessor operators, angle brackets,
   generics, line-continuation, comma, and semicolon.
   ============================================================ *\

// ============================================================
// SEMICOLONS (statement separator)
// ============================================================

let a = 1; let b = 2; let c = a + b   // multiple statements on one line
for i in 0..<5 { print(i); process(i) }

// Semicolon is optional at end of line
let x = 10
let y = 20

// ============================================================
// COMMAS (list separator + line-continuation)
// ============================================================

// Standard comma in lists
let arr = [1, 2, 3]
let obj = {a: 1, b: 2, c: 3}
func f(int a, int b, int c): int { a + b + c }

// Trailing comma allowed
let arr2 = [
  1,
  2,
  3,
]

// Line-continuation comma (comma at end of line continues to next)
let result = [
  firstItem,\
  secondItem,\
  thirdItem
]

// ============================================================
// LINE CONTINUATION (backslash at end of line)
// ============================================================

let long_expr = veryLongVarName \
  + anotherLongVarName \
  + yetAnotherVar

let condition = x > 0 \
  and y > 0 \
  and z > 0

// ============================================================
// CURLY BRACKETS  { }
// ============================================================

// Block / body
func foo() { print("block") }

// Object/record literal
let pt = {x: 1, y: 2}
let rec = {name: "Alice", age: 30}

// Match / switch body
match n {
  | 0: "zero"
  | 1: "one"
  | else: "many"
}

// Binding pattern
let {x: px, y: py} = point

// String interpolation  #"#{expr}"
let msg = #"Result: #{a + b}"

// Splice form  #{...}
let obj2 = #{x: 1, y: 2}
let merged = #{*base, z: 3}

// Style block
style Card {
  background-color: :white;
  border-radius: 8px;
}

// Lambda body (multi-statement)
let fn2 = |x: int| {
  let doubled = x * 2
  doubled + 1
}

// ============================================================
// ROUND BRACKETS  ( )
// ============================================================

// Grouping expression
let r1 = (a + b) * c

// Tuple literal
let pair = (1, "hello")
let unit_val = ()

// Function call
foo(1, 2, 3)

// Tuple type
let p: (int, str) = (42, "world")

// Tuple binding pattern
let (x2, y2) = coordinate

// Lambda params
let double2 = |x| x * 2

// Splice form  #(...)
let t2 = #(a, b, c)

// Type cast
let n3 = (int) 3.14

// Condition
if (x > 0) { print("pos") }   // parens optional
while (running) { tick() }

// ============================================================
// SQUARE BRACKETS  [ ]
// ============================================================

// Array literal
let arr3 = [1, 2, 3]

// Array type annotation
let list: []int = [10, 20, 30]
let fixed: [5]int = [1, 2, 3, 4, 5]

// Subscript / index access
let first3 = arr3[0]
let last2   = arr3[arr3.len() - 1]
let ch      = str2[3]

// Slice
let sl = arr3[1:3]

// Array pattern
let [h, ...t] = arr3

// Dynamic property key
let val3 = obj[dynamicKey]

// CSS selector list (in style-list context)
style FocusStyle [input, textarea, button] {
  outline: 2px solid blue;
}

// Splice form  #[...]
let arr4 = #[1, 2, 3]
let arr5 = #[*existing, 4]

// ============================================================
// ANGLE BRACKETS  < >
// ============================================================

// Generic type parameter — declaration
class Box<T> { val value: T }
func identity<T>(T x): T { x }

// Generic type parameter — usage
let box1: Box<int> = Box.new(42)
let pairs: Vec<(str, int)> = Vec.new()
let nested2: Map<str, Vec<int>> = Map.new()

// Type constraints
func max_of<T: Ord>(T a, T b): T { if a > b: a else: b }
func print_all<T: Display + Clone>([]T xs): void { xs.each(print) }

// Comparison operators (not generic angle brackets)
let lt2 = a < b
let gt2 = a > b
let le  = a <= b
let ge2 = a >= b

// Turbofish / generic function call
let v3 = identity<int>(42)
let p3 = parse<Config>(raw)
let e3 = Either::<int, str>::Left(5)

// ============================================================
// ACCESSOR OPERATORS
// ============================================================

// Dot — field access
let name3 = user.name
let len4   = arr.length
let h5     = img.height

// Dot — method call
let sorted3 = list.sort()
let upper2  = str2.toUpper()

// Optional dot — safe access
let city3  = user?.address?.city
let first4 = arr?.first()

// Force-unwrap dot
let val4   = opt!.value

// Double colon — scope resolution
let val5   = Enum::variant
let fn3    = Module::subFn
let assoc2 = Vec<int>::new

// Arrow — pointer dereference access
let deref2 = ptr->value
let next   = node->next->data

// Optional arrow
let safe_v = ptr?->value

// ============================================================
// COMMA FORMS IN COMPLEX CONTEXTS
// ============================================================

// Function call with many args
let r5 = f(
  a,
  b,
  c: cc,
  d: dd,
)

// Destructuring
let {name: n2, age, email?} = user

// Multi-binding let
let (x5, y5, z5) = triple

// Tuple construction
let coord = (lat, lon, alt)

// Array with spread
let all = [*first_batch, *second_batch, extra_item]

// ============================================================
// GENERIC BRACKET DISAMBIGUATION
// ============================================================

// These are comparisons (not generics) because no type context
let ambig1 = a < b && c > d   // comparisons

// These are generics because of the function/type context
let v4 = Vec::<int>::new()
let r6: Result<int, str> = Okay(1)
