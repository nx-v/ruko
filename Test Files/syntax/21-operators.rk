\* ============================================================
   21 — OPERATORS
   Corresponds to: ruko.tmLanguage.yaml lines 6095–6584
   Every operator category: infix, prefix, postfix, special,
   named-infix, type-cast, and custom oper declarations.
   ============================================================ *\

// ----- Arithmetic -----
let s  = 3 + 4
let d  = 10 - 6
let m  = 5 * 7
let q  = 20 / 4
let r  = 17 % 3
let pw = 2 ** 10     // power / exponentiation

// ----- String operators -----
let cat  = "hello" ++ " world"    // concatenation
let rep  = "ha" -- 3              // ?? repeated-removal?
let mul2 = "ab" ×× 3              // repetition (Unicode ×)

// ----- Unary arithmetic -----
let neg  = -x
let pos  = +x
let pp   = +x      // prefix increment context
let mm   = -x      // prefix decrement context

// ----- Augmented assignment (compound) -----
x += 1
x -= 1
x *= 2
x /= 2
x %= 3
x **= 2
x ++= " suffix"
x &&= true
x ||= false
x ??= 0
x <<= 1
x >>= 1
x &= 0xFF
x |= 0x01
x ^= 0xF0

// ----- Bitwise -----
let band  = a & b
let bor   = a | b
let bxor  = a ^ b
let bnot  = ~a
let lsh   = a << 4
let rsh   = a >> 4
let rotl  = a <<> 5
let rotr  = a <>> 5

// ----- Comparison -----
let eq   = a == b
let neq  = a != b
let seq  = a === b    // structural equality
let sneq = a !== b
let lt   = a < b
let gt   = a > b
let le   = a <= b
let ge   = a >= b
let cmp  = a <=> b    // three-way comparison: -1 / 0 / 1

// ----- Logical -----
let land  = a && b
let lor   = a || b
let lnot  = !a
let lxor  = a ^^ b
let lnand = a §§ b   // NAND (Unicode §)
let lnor  = a ¦¦ b   // NOR  (Unicode ¦)
let lxnor = a ¤¤ b   // XNOR (Unicode ¤)
let limp  = a and b
let lor2  = a or b
let lnot2 = not a
let lnand2 = a nand b
let lnor2  = a nor b
let lxor2  = a xor b

// ----- Similarity -----
let sml  = a ~= b     // similar / fuzzy equal
let smr  = a =~ b     // regex match
let nsm  = a !=~ b    // not regex match

// ----- Null-coalescing -----
let nc1 = val ?? default_val       // null coalesce
let nc2 = val ??? fallback         // triple-? coalesce
let nc3 = val ¿¿ backup            // Unicode ¿ coalesce

// ----- Error-coalescing -----
let ec1 = result !!! fallback      // error coalesce (unwrap or fallback)
let ec2 = result ¡¡ backup         // Unicode ¡ coalesce

// ----- Ternary / conditional -----
let t1 = cond ? a : b             // standard ternary
let t2 = cond ¿ a : b             // Unicode ¿ ternary
let t3 = cond ! a : b             // negate-ternary
let t4 = cond ¡ a : b             // Unicode ¡ ternary

// ----- Range operators -----
let r1 = 0 .. 10          // inclusive range
let r2 = 0 ..< 10         // exclusive upper
let r3 = 0 >.. 10         // exclusive lower
let r4 = 0 >.< 10         // both exclusive
let r5 = ..10             // up-to (prefix)
let r6 = 0..              // from (suffix)
let r7 = ..               // unbounded full range

// ----- Accessor / member operators -----
let a1 = obj.field          // dot-access
let a2 = obj?.field         // optional-access
let a3 = obj!.field         // force-access
let a4 = obj::member        // scope-resolution
let a5 = ptr->field         // pointer deref access
let a6 = ptr?->field        // optional pointer deref
let a7 = ptr!->field        // force pointer deref

// ----- Assignment -----
x = 10
x := 20        // declare-assign
x ?= 30        // assign if null/undef

// ----- Fat / skinny / wavy arrows -----
let fa  = a ==> b     // fat right
let fa2 = a <== b     // fat left
let sk  = a --> b     // skinny right
let sk2 = a <-- b     // skinny left
let wv  = a ~~> b     // wavy right
let wv2 = a <~~ b     // wavy left

// ----- Pipeline operators -----
let p1 = x |> f              // pipe right
let p2 = f <| x              // pipe left
let p3 = x +> g              // applicative pipe right
let p4 = g <+ x              // applicative pipe left
let p5 = x *> h              // monadic pipe right
let p6 = h <* x              // monadic pipe left
let p7 = x $> i              // fmap pipe

// ----- Application operators -----
let ap1 = f $ x              // function application (Haskell-style)
let ap2 = f # x              // alternative application

// ----- Composition operators -----
let c1 = f . g               // compose (right-to-left)
let c2 = f · g               // middle-dot compose
let c3 = f ° g               // degree-sign compose
let c4 = f <+ g              // compose left
let c5 = f +> g              // compose right

// ----- Class / subtype operators -----
let isa = T <: U             // T is subtype of U
let isa2 = T :> U            // T is supertype of U

// ----- Prefix operators -----
let deref = *ptr             // pointer dereference
let spread = /arr            // spread into context
let ref_   = &val            // create reference
let borrow = ^val            // borrow (lifetime-aware)
let anchor = #label          // anchor / meta

// ----- Postfix operators -----
let unwrap  = opt!           // unwrap Option / error
let opt_get = val?           // option: None if null
let inc     = n!             // postfix unwrap/increment (context)

// ----- Named infix (backslash-quoted) -----
let ni1 = 10 \div\ 3         // user-defined named infix
let ni2 = xs \append\ ys
let ni3 = a \isApprox\ b

// ----- Type-cast operators -----
let tc1 = (int) 3.14         // C-style cast
let tc2 = x as f64           // safe cast keyword
let tc3 = x as! int          // force cast (panics on failure)
let tc4 = x as? str          // optional cast (returns null on failure)
let tc5 = typeof x           // type of expression (type keyword)
let tc6 = sizeof T           // size of type
let tc7 = valueof MyEnum     // values of enum
let tc8 = fieldof MyStruct   // fields of struct
let tc9 = keyof MyMap        // key type of map

// ----- Custom operator declarations -----
oper infix  (+-)  precedence: 6  associativity: left
oper infix  (><)  precedence: 5  associativity: right
oper prefix (¬)
oper postfix (‼)

// Using the custom operators
let r8 = a +- b
let r9 = a >< b
let r10 = ¬condition
let r11 = val‼

// ----- Unicode math operators -----
let um1 = a × b              // times (U+00D7)
let um2 = a ÷ b              // divide (U+00F7)
let um3 = a − b              // minus (U+2212)
let um4 = a ≠ b              // not equal (U+2260)
let um5 = a ≤ b              // less-or-equal (U+2264)
let um6 = a ≥ b              // greater-or-equal (U+2265)
let um7 = a ≈ b              // approximately equal
let um8 = a ∈ b              // element-of
let um9 = a ∉ b              // not element-of
let uma = a ⊂ b              // subset
let umb = a ⊃ b              // superset
let umc = a ⊕ b              // XOR / direct sum
let umd = a ⊗ b              // tensor product
let ume = a ∧ b              // logical and (U+2227)
let umf = a ∨ b              // logical or (U+2228)
let umg = ¬a                 // logical not (U+00AC)

// ----- Macro operators -----
let m1 = x $ y               // macro application
let m2 = x ::: y             // splice-operator
let m3 = x :: y              // namespace or cons
let m4 = x : y               // type / pair operator
