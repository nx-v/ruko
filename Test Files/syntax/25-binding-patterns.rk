\* ============================================================
   25 — BINDING PATTERNS
   Corresponds to: ruko.tmLanguage.yaml lines 8359–8455
   Object, tuple, and array destructuring in let/mut/case arms.
   ============================================================ *\

// ============================================================
// OBJECT DESTRUCTURING
// ============================================================

// Simple punning (variable name == field name)
let {x, y, z} = vec3

// All fields renamed with :
let {x: a, y: b, z: c} = vec3

// Mixed punning and renaming
let {name, age: years} = person

// Nested object destructuring
let {address: {city, country}, name: personName} = user

// With default values
let {name: n2, title = "Mx."} = person

// Optional field
let {name: n3, email?} = user     // email may not exist

// Type-annotated
let {x: int, y: int} = pixel
let {name: str, score: f64} = record

// In a function signature
func printPoint({x, y}: Point): void { print(#"(#x, #y)") }
func greetUser({name, title = "Friend"}: User): void { print(#"Hello, #title #name!") }

// In for loop
for let {key, value} of map.entries() { print(#"#key => #value") }
for let {name, age} of users { print(#"#name (#age)") }

// In case arm
match event {
  | {type: :click, target: el}: handler(el)
  | {type: :keydown, key: k}: keyHandler(k)
  |: ignore()
}

// ============================================================
// TUPLE DESTRUCTURING
// ============================================================

// Simple ordered unpacking
let (a, b) = pair
let (x2, y2, z2) = triple

// With types
let (int m, int n) = int_pair
let (f64 lat, f64 lon) = coord

// Ignoring elements with _
let (first, _, third) = triple
let (_, snd_el) = pair

// Nested tuples
let ((x3, y3), z3) = nested_pair

// In function signature
func addPair((int a, int b)): int { a + b }
func swapPair2((int a, int b)): (int, int) { (b, a) }

// In for loop
for let (k, v) of pairs { print(#"#k => #v") }

// In case arm
match result {
  | (:ok, val): process(val)
  | (:err, msg): logError(msg)
}

// ============================================================
// ARRAY DESTRUCTURING
// ============================================================

// First element only
let [head] = arr

// First and rest
let [first, ..rest] = arr

// First two
let [a2, b2] = arr

// First two and rest
let [a3, b3, ..tail] = arr

// Last element  (rest + last)
let [..init, last] = arr

// Specific positions
let [h, _, third2, ..remaining] = arr

// Typed
let [int h2, int h3, ..int[] t] = int_arr
let [str first_w, ..str[] more] = words

// Nested arrays
let [[x4, y4], [x5, y5]] = pairs_arr

// In function signature
func headTail2([h, ..t]) { (h, t) }
func firstTwo([a, b, ..]) { (a, b) }

// In for loop (iterating rows of matrix)
for [a4, b4, c4] in matrix3x { print(#"#a4 #b4 #c4") }

// In case arm
match list {
  | []: print("empty")
  | [x]: print(#"singleton: #x")
  | [x, y]: print(#"pair: #x, #y")
  | [h, ..t]: print(#"head=#h tail=#t")
}

// ============================================================
// COMBINED / NESTED PATTERNS
// ============================================================

// Object containing tuple
let {coord: (lat, lon), name: placeName} = location

// Array of objects
let [{id: id1, name: n4}, {id: id2, name: n5}, ..otherItems] = results

// Tuple of arrays
let ([a5, b5], [c5, d5]) = two_arrays

// Deep nesting
let {meta: {tags: [primaryTag, ..otherTags]}, content} = post

// ============================================================
// PATTERNS WITH IS / HAS / CAN GUARDS
// ============================================================

match val {
  | is int as n: print(#"int: #n")
  | is str as s: print(#"str: #s")
  | has .name as obj: print(obj.name)
  | can .serialize as obj: obj.serialize()
}

match shape {
  | is Circle has .radius as c: c.area()
  | is Rect   has .width as r: r.area()
}

// ============================================================
// PATTERNS WITH IF GUARDS
// ============================================================

match x {
  | n if n < 0: print("negative")
  | n if n == 0: print("zero")
  | n if n > 0: print("positive")
}

match pair {
  | (a, b) if a == b: print("equal")
  | (a, b) if a > b: print("a greater")
  | (a, b): print("b greater")
}

// ============================================================
// AS RENAMING IN PATTERNS
// ============================================================

match node {
  | Branch(left, right) as tree: renderBranch(left, right, tree)
  | Leaf(val) as leaf: renderLeaf(val, leaf)
}

let xs as original = transform(input)
let result as backup = riskyOp()
