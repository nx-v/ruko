\* ============================================================
   11 — REGULAR EXPRESSION LITERALS
   Corresponds to: ruko.tmLanguage.yaml lines 2295–3014
   Inline regex literals, all group types, character classes,
   fuzzy matching, replacement forms, and random generation.
   ============================================================ *\

// ----- Basic regex literals -----
let r1 = /hello/
let r2 = /hello/gi
let r3 = /[a-z]+/
let r4 = /^\d{4}-\d{2}-\d{2}$/m     // ISO date

// ----- Character classes -----
let digit      = /\d/                 // digit
let word       = /\w/                 // word char
let space      = /\s/                 // whitespace
let nonDigit   = /\D/
let nonWord    = /\W/
let nonSpace   = /\S/

// POSIX named classes
let alpha      = /[[:alpha:]]/
let alnum      = /[[:alnum:]]/
let upper      = /[[:upper:]]/
let lower      = /[[:lower:]]/
let punct      = /[[:punct:]]/
let blank      = /[[:blank:]]/

// Unicode property escapes
let letter     = /\p{L}/              // any letter
let upper2     = /\p{Lu}/             // uppercase letter
let lower2     = /\p{Ll}/             // lowercase letter
let numeral    = /\p{N}/              // any number
let emoji      = /\p{Emoji_Presentation}/
let han        = /\p{Script=Han}/
let latin      = /\p{Script=Latin}/
let arabic     = /\p{Script=Arabic}/
let thai       = /\p{Block=Thai}/
let cjk        = /\p{Block=CJK}/

// Negated Unicode property
let nonLetter  = /\P{L}/

// Extended character class (set operations)
let thai_or_lao = /(?[\p{Thai}|\p{Lao}])/
let letter_no_ascii = /(?[\p{L}--\p{ASCII}])/
let consonants = /(?[\p{L}&&[^aeiouAEIOU]])/

// ----- Anchors and boundaries -----
let anchors = /^start|end$/m
let word_b  = /\bhello\b/
let non_word_b = /\Bhello\B/
let line_s  = /^/m
let input_s = /\A/                   // start of input
let input_e = /\Z/                   // end of input (before \n)

// ----- Quantifiers -----
let q1  = /a*/          // zero or more
let q2  = /a+/          // one or more
let q3  = /a?/          // zero or one
let q4  = /a{3}/        // exactly 3
let q5  = /a{3,}/       // 3 or more
let q6  = /a{3,7}/      // between 3 and 7
let q7  = /a*?/         // lazy zero or more
let q8  = /a+?/         // lazy one or more
let q9  = /a??/         // lazy zero or one
let q10 = /a{3,7}?/     // lazy bounded
let q11 = /a*+/         // possessive zero or more
let q12 = /a++/         // possessive one or more

// ----- Non-capturing group -----
let nc1 = /(?:abc)+/
let nc2 = /(?:foo|bar)baz/

// ----- Named capture groups -----
let named1 = /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/
let named2 = /(?<word>\w+)\s+\k<word>/    // backreference by name

// ----- Atomic group (no backtracking) -----
let atom1 = /(?>abc|ab)c/

// ----- Lookahead and lookbehind -----
let la_pos  = /\w+(?= is)/       // positive lookahead
let la_neg  = /\w+(?! is)/       // negative lookahead
let lb_pos  = /(?<=Mr\. )\w+/    // positive lookbehind
let lb_neg  = /(?<!Mr\. )\w+/    // negative lookbehind

// Variable-length lookbehind
let vllb = /(?<=\w+)\s/

// ----- Conditional groups -----
let cond1 = /(?(1)a|b)/          // if group 1 matched: a else: b
let cond2 = /(?(<name>)yes|no)/  // named conditional

// ----- Branch reset group -----
let branch1 = /(?|(\d+)|([a-z]+))/

// ----- Flag modifier group -----
let fg1 = /(?i:abc)/              // case-insensitive only within group
let fg2 = /(?-i:abc)/             // force case-sensitive within group
let fg3 = /(?si:.)*/              // dotall + case-insensitive

// ----- Absent operator -----
let absent = /(?~;.*)/            // Oniguruma absent expression

// ----- Callout group -----
let callout1 = /a(?{myCallback})b/

// ----- Recursive patterns -----
let balanced = /\((?:[^()]*|\g<0>)*\)/   // balanced parentheses

// ----- Subroutine calls -----
let sub1 = /(?P=name)/            // backreference (Python-style)
let sub2 = /\g{1}/                // group subroutine by number
let sub3 = /\g<name>/             // group subroutine by name

// ----- Fuzzy matching -----
// {~n}  — allow up to n errors (insertions, deletions, substitutions)
let fuzzy1 = /hello{~1}/          // allow 1 error
let fuzzy2 = /world{~2}/          // allow 2 errors
let fuzzy3 = /#{pattern}{~n}/     // dynamic error count

// ----- Replacement form -----
// /pattern/:replacement/flags
let replaced = str.replace(/foo:bar/)
let replaced2 = str.replace(/(\w+):$1!/)
let replaced3 = str.replace(/\d+:#{"NUM"}/g)

// ----- Random generation from regex -----
// /pattern/ random: seed
let generated = (/[a-z]{8}/).random 42
let password  = (/[A-Za-z0-9!@#]{12}/).random Date.now()