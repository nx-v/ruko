\* ============================================================
   22 — CLAUSES & KEYWORDS
   Corresponds to: ruko.tmLanguage.yaml lines 6585–7250
   All modifier, declaration, general, expression, and
   control-flow keywords organised by grammar category.
   ============================================================ *\

// ============================================================
// ACCESS / VISIBILITY MODIFIERS
// ============================================================
pub    func publicFn() {}
priv   func privateFn() {}
prot   func protectedFn() {}
int    func internalFn() {}        // package-internal
extern func externalFn(): void     // foreign declaration

// ============================================================
// STORAGE MODIFIERS
// ============================================================
static let counter: int = 0
thread val local_data: str = ""
shared let shared_count: int = 0    // across fibers
lazy   val config = Config.load()   // computed on first access
inline func fastOp(int x): int { x + 1 }
extern val C_CONSTANT: int          // from C

// ============================================================
// MUTABILITY MODIFIERS
// ============================================================
let   imm: int = 5         // immutable binding
mut   var1: int = 5        // mutable binding keyword
const C_MAX: int = 1000    // compile-time constant
val   answer: int = 42     // value binding (alias of let)
var   counter2: int = 0    // variable (mutable by default)
final val done: bool = true // cannot be overridden

// ============================================================
// LIFETIME MODIFIERS
// ============================================================
// \a, \b — named lifetimes (backslash prefix)
func longest(\a str s1, \a str s2): \a str {
  if s1.len() >= s2.len(): s1 else: s2
}

// ============================================================
// FUNCTION BEHAVIOUR MODIFIERS
// ============================================================
async  func fetchData(): Promise<str>    { await http.get(url) }
pure   func add2(int a, int b): int      { a + b }
safe   func safeDiv(int a, int b): int?  { if b == 0: null else: a / b }
unsafe func rawMemCopy(ptr src, ptr dst): void {}
gen    func* counter3(int start): iter<int> { yield start; yield start + 1 }
iter   func* range2(int lo, int hi): iter<int> {
  var i = lo
  while i < hi { yield i; i += 1 }
}

// ============================================================
// TYPE MODIFIERS
// ============================================================
abstract class Shape {
  abstract func area(): f64
}

sealed class Tree<T> {
  record Leaf(T val)
  record Branch(Tree<T> left, Tree<T> right)
}

open class Base {}       // can be extended
closed class Final {}    // cannot be extended
data class Point(f64 x, f64 y)
value class Celsius(f64 deg)
opaque type UserId = int

// ============================================================
// INHERITANCE / TRAIT MODIFIERS
// ============================================================
class Circle extends Shape {
  override func area(): f64 { Math.PI * radius ** 2 }
}

class B extends A {
  virtual func method() {}
}

// ============================================================
// DECLARATION KEYWORDS
// ============================================================
let x: int = 10
mut y: str = "hello"
const PI: f64 = 3.14159
var z: bool = false
val w: f64 = 2.718

// Function declarations
func add(int a, int b): int { a + b }
proc sideEffect(): void { print("side effect") }

// Property
prop name: str { get { storage_name } set(v) { storage_name = v } }

// Iterator / generator
iter countdown(int n): iter<int> {
  mut i = n
  while i >= 0 { yield i; i -= 1 }
}

// Type alias
type Point2D = (f64, f64)
type Matrix  = [][]f64

// Class, trait, interface, enum, record
class Animal { val name: str }
trait Describable { func describe(): str }
inter Serializable { func toJson(): str }
enum Color { :red, :green, :blue }
record Pair(int fst, int snd)
struct Vec3 { val x, y, z: f64 }

// Module, schema, object, union
module Http {}
schema UserInput { name: str, age: int }
object Singleton { val instance = new Singleton() }
union Value = int | f64 | str | bool

// Implementation
impl Describable for Animal {
  func describe(): str { #"Animal: #name" }
}

// Macro
macro make_pair {
  ($a:expr, $b:expr) => Pair($a, $b)
}

// Namespace / space
space Utils {
  func clamp(int v, int lo, int hi): int { min(max(v, lo), hi) }
}

// Realm (compile-time execution context)
realm Compile {
  func constFibonacci(int n): int {
    if n <= 1: n else: constFibonacci(n-1) + constFibonacci(n-2)
  }
}

// Query declaration
query ActiveUsers {
  from users
  where user.active == true
  select user
}

// Template
temp Button(str label, fn(): void onClick) {
  <button :click=onClick>#label</button>
}

// Shader
shader VertexShader(v: VertexInput): VertexOutput {
  gl_Position = projection * view * model * vec4(v.position, 1.0)
}

// Quote
quote MyAst {
  let x = 1 + 2
}

// Style
style Theme {
  background-color: %#1a1a2e;
  font-family: "Inter", sans-serif;
}

// Script / Component
script {
  let count = 0
  func increment() { count += 1 }
}

compo Counter {
  \\ A simple click counter.
  let count = 0
  <button :click=(|_| count += 1)>Count: #count</button>
}

// ============================================================
// GENERAL KEYWORDS
// ============================================================

// Membership / type checking
let r1 = item in collection
let r2 = key of object
let r3 = value as str
let r4 = x is int
let r5 = obj has .serialize
let r6 = obj can .render

// Object construction
let pt = new Point(1, 2)
let old_pt = old Point(1, 2)     // create via "old" constructor

// Direction / iteration keywords
for x in list {}
for x of map {}
for x to 10 {}
for x by 2 {}

// Access direction
func foo(): int { ref myGlobal } // ref: reference return

// Logical keywords (spelled out)
let la = a and b
let lo = a or b
let ln = not a
let lna = a nand b
let lno = a nor b
let lx  = a xor b
let lxn = a xnor b
let li  = a imply b
let lni = a nimply b

// Deletion
del map["key"]
del obj.field

// Get / set
get prop {}
set prop(v) {}

// Module keywords
use Http
use Http show { get, post }
use Http hide { internal }

// ----- safe / unsafe blocks -----
safe {
  let r = safeDivide(10, 0)
}
unsafe {
  let raw = derefRawPointer(ptr)
}

// ----- scope / begin / end -----
scope "outer" {
  scope "inner" {
    break "outer"
  }
}

begin
  let temp = doSetup()
end

// ----- pass / skip / redo -----
for x in list {
  if x == 0: skip
  if x < 0: redo
}
pass   // no-op statement
