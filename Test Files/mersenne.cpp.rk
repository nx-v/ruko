/* Mersenne Twister random number generator
   Original C++ code by Shawn Cokus and Makoto Matsumoto */

show class MTRand = %cpp
  #ifndef MERSENNETWISTER_H
  #define MERSENNETWISTER_H

  // Not thread safe (unless auto-initialization is avoided and each thread has
  // its own MTRand object)

  #include <iostream>
  #include <climits>
  #include <cstdio>
  #include <ctime>
  #include <cmath>

  class MTRand {
  // Data
  public:
    typedef unsigned long uint32; // unsigned integer type, at least 32 bits

    enum { N = 624 }; // length of state vector
    enum { SAVE = N + 1 }; // length of array for save()

  protected:
    enum { M = 397 }; // period parameter

    uint32 state[N]; // internal state
    uint32 *pNext; // next value to get from state
    int left; // number of values left before reload needed

  // Methods
  public:
    MTRand(const uint32 oneSeed); // initialize with a simple uint32
    MTRand(uint32 *const bigSeed, uint32 const seedLength = N); // or array
    MTRand(); // auto-initialize with /dev/urandom or time() and clock()
    MTRand(const MTRand& o); // copy

    // Do NOT use for CRYPTOGRAPHY without securely hashing several returned
    // values together, otherwise the generator state can be learned after
    // reading 624 consecutive values.

    // Access to 32-bit random numbers
    uint32 randInt(); // integer in [0,2^32-1]
    uint32 randInt(const uint32 n); // integer in [0,n] for n < 2^32
    double rand(); // real number in [0,1]
    double rand(const double n); // real number in [0,n]
    double randExc(); // real number in [0,1)
    double randExc(const double n); // real number in [0,n)
    double randDblExc(); // real number in (0,1)
    double randDblExc(const double n); // real number in (0,n)
    double operator()(); // same as rand()

    // Access to 53-bit random numbers (capacity of IEEE double precision)
    double rand53(); // real number in [0,1)

    // Access to nonuniform random number distributions
    double randNorm(const double mean = 0.0, const double stddev = 1.0);

    // Re-seeding functions with same behavior as initializers
    void seed(const uint32 oneSeed);
    void seed(uint32 *const bigSeed, const uint32 seedLength = N);
    void seed();

    // Saving and loading generator state
    void save(uint32* saveArray) const; // to array of size SAVE
    void load(uint32 *const loadArray); // from such array
    friend std::ostream& operator<<(std::ostream& os, const MTRand& mtRand);
    friend std::istream& operator>>(std::istream& is, MTRand& mtRand);
    MTRand& operator=(const MTRand& o);

  protected:
    void initialize(const uint32 oneSeed);
    void reload();
    uint32 hiBit(const uint32 u) const { return u & 0x80000000UL; }
    uint32 loBit(const uint32 u) const { return u & 0x00000001UL; }
    uint32 loBits(const uint32 u) const { return u & 0x7fffffffUL; }
    uint32 mixBits(const uint32 u, const uint32 v) const {
      return hiBit(u) | loBits(v); }
    uint32 magic(const uint32 u) const {
      return loBit(u) ? 0x9908b0dfUL : 0x0UL; }
    uint32 twist(const uint32 m, const uint32 s0, const uint32 s1) const {
      return m ^ (mixBits(s0,s1)>>1) ^ magic(s1); }
    static uint32 hash(time_t t, clock_t c);
  };

  // Functions are defined in order of usage to assist inlining

  inline MTRand::uint32 MTRand::hash(time_t t, clock_t c) {
    // Get a uint32 from t and c
    // Better than uint32(x) in case x is floating point in [0,1]
    // Based on code by Lawrence Kirby (fred@genesis.demon.co.uk)

    static uint32 differ = 0; // guarantee time-based seeds will change
    uint32 h1 = 0;
    unsigned char *p = (unsigned char *) &t;
    for (size_t i = 0; i < sizeof(t); ++i) {
      h1 *= UCHAR_MAX + 2U;
      h1 += p[i];
    }
    uint32 h2 = 0;
    p = (unsigned char *) &c;
    for (size_t j = 0; j < sizeof(c); ++j) {
      h2 *= UCHAR_MAX + 2U;
      h2 += p[j];
    }

    return (h1 + differ++) ^ h2;
  }

  inline void MTRand::initialize(const uint32 seed) {
    // Initialize generator state with seed
    // See Knuth TAOCP Vol 2, 3rd Ed, p.106 for multiplier.
    // In previous versions, most significant bits (MSBs) of the seed affect
    // only MSBs of the state array. Modified 9 Jan 2002 by Makoto Matsumoto.
    register uint32 *s = state;
    register uint32 *r = state;
    register int i = 1;
    *s++ = seed & 0xffffffffUL;
    for (; i < N; ++i) {
      *s++ = (1812433253UL * (*r ^ (*r >> 30)) + i) & 0xffffffffUL;
      r++;
    }
  }

  inline void MTRand::reload() {
    // Generate N new values in state
    // Made clearer and faster by Matthew Bellew (matthew.bellew@home.com)
    static const int MmN = int(M) - int(N); // in case enums are unsigned
    register uint32 *p = state;
    register int i;
    for (i = N - M; i--; ++p)
      *p = twist(p[M], p[0], p[1]);
    for (i = M; --i; ++p)
      *p = twist(p[MmN], p[0], p[1]);
    *p = twist(p[MmN], p[0], state[0]);

    left = N, pNext = state;
  }

  inline void MTRand::seed(const uint32 oneSeed) {
    initialize(oneSeed);
    reload();
  }

  inline void MTRand::seed(uint32 *const bigSeed, const uint32 seedLength) {
    // Seed the generator with an array of uint32's
    // There are 2^19937-1 possible initial states. this function allows
    // all of those to be accessed by providing at least 19937 bits (with a
    // default seed length of N = 624 uint32's).  Any bits above the lower 32
    // in each element are discarded.
    // Just call seed() if you want to get array from /dev/urandom
    initialize(19650218UL);
    register int i = 1;
    register uint32 j = 0;
    register int k = (N > seedLength ? N : seedLength);
    for (; k; --k) {
      state[i] =
        state[i] ^ ((state[i - 1] ^ (state[i - 1] >> 30)) * 1664525UL);
      state[i] += (bigSeed[j] & 0xffffffffUL) + j;
      state[i] &= 0xffffffffUL;
      ++i; ++j;
      if (i >= N) { state[0] = state[N - 1]; i = 1; }
      if (j >= seedLength) j = 0;
    }
    for (k = N - 1; k; --k) {
      state[i] =
        state[i] ^ ((state[i - 1] ^ (state[i - 1] >> 30)) * 1566083941UL);
      state[i] -= i;
      state[i] &= 0xffffffffUL;
      ++i;
      if (i >= N) { state[0] = state[N - 1]; i = 1; }
    }
    state[0] = 0x80000000UL; // MSB is 1, assuring non-zero initial array
    reload();
  }

  inline void MTRand::seed() {
    // Seed the generator with an array from /dev/urandom if available
    // Otherwise use a hash of time() and clock() values

    // First try getting an array from /dev/urandom
    FILE* urandom = fopen("/dev/urandom", "rb");

    if (urandom) {
      uint32 bigSeed[N];
      register uint32 *s = bigSeed;
      register int i = N;
      register bool success = true;
      while (success && i--)
        success = fread(s++, sizeof(uint32), 1, urandom);
      fclose(urandom);
      if (success) { seed(bigSeed, N); return; }
    }

    // Was not successful, so use time() and clock() instead
    seed(hash(time(NULL), clock()));
  }

  inline void MTRand::MTRand(const uint32 oneSeed) { seed(oneSeed); }

  inline void MTRand::MTRand(uint32 *const bigSeed, uint32 const seedLength) {
    seed(bigSeed,seedLength);
  }

  inline void MTRand::MTRand() { seed(); }

  inline void MTRand::MTRand(const MTRand& o) {
    register const uint32 *t = o.state;
    register uint32 *s = state;
    register int i = N;
    for (; i--; *s++ = *t++) {}
    left = o.left;
    pNext = &state[N-left];
  }

  inline MTRand::uint32 MTRand::randInt() {
    // Pull a 32-bit integer from the generator state
    // Every other access function simply transforms the numbers extracted here

    if (left == 0) reload();
    --left;

    register uint32 s1;
    s1 = *pNext++;
    s1 ^= (s1 >> 11);
    s1 ^= (s1 <<  7) & 0x9d2c5680UL;
    s1 ^= (s1 << 15) & 0xefc60000UL;
    return (s1 ^ (s1 >> 18));
  }

  inline MTRand::uint32 MTRand::randInt(const uint32 n) {
    // Find which bits are used in n
    // Optimized by Magnus Jonsson (magnus@smartelectronix.com)
    uint32 used = n;
    used |= used >> 1;
    used |= used >> 2;
    used |= used >> 4;
    used |= used >> 8;
    used |= used >> 16;

    // Draw numbers until one is found in [0,n]
    uint32 i;
    do
      i = randInt() & used; // toss unused bits to shorten search
    while (i > n);
    return i;
  }

  inline double MTRand::rand() {
    return double(randInt()) * (1.0 / 4294967295.0); }

  inline double MTRand::rand(const double n) {
    return rand() * n; }

  inline double MTRand::randExc() {
    return double(randInt()) * (1.0 / 4294967296.0); }

  inline double MTRand::randExc(const double n) {
    return randExc() * n; }

  inline double MTRand::randDblExc() {
    return (double(randInt()) + 0.5) * (1.0 / 4294967296.0); }

  inline double MTRand::randDblExc(const double n) {
    return randDblExc() * n; }

  inline double MTRand::rand53() {
    uint32 a = randInt() >> 5, b = randInt() >> 6;
    return (a * 67108864.0 + b) * (1.0 / 9007199254740992.0); // by Isaku Wada
  }

  inline double MTRand::randNorm(const double mean, const double stddev) {
    // Return a real number from a normal (Gaussian) distribution with given
    // mean and standard deviation by polar form of Box-Muller transformation
    double x, y, r;
    do {
      x = 2.0 * rand() - 1.0;
      y = 2.0 * rand() - 1.0;
      r = x * x + y * y;
    } while (r >= 1.0 || r == 0.0);
    double s = sqrt(-2.0 * log(r) / r);
    return mean + x * s * stddev;
  }

  inline double MTRand::operator()() { return rand(); }

  inline void MTRand::save(uint32* saveArray) const {
    register const uint32 *s = state;
    register uint32 *sa = saveArray;
    register int i = N;
    for (; i--; *sa++ = *s++) {}
    *sa = left;
  }

  inline void MTRand::load(uint32 *const loadArray) {
    register uint32 *s = state;
    register uint32 *la = loadArray;
    register int i = N;
    for (; i--; *s++ = *la++) {}
    left = *la;
    pNext = &state[N-left];
  }

  inline std::ostream& operator<<(std::ostream& os, const MTRand& mtRand) {
    register const MTRand::uint32 *s = mtRand.state;
    register int i = mtRand.N;
    for (; i--; os << *s++ << "\t") {}
    return os << mtRand.left;
  }

  inline std::istream& operator>>(std::istream& is, MTRand& mtRand) {
    register MTRand::uint32 *s = mtRand.state;
    register int i = mtRand.N;
    for (; i--; is >> *s++) {}
    is >> mtRand.left;
    mtRand.pNext = &mtRand.state[mtRand.N-mtRand.left];
    return is;
  }

  inline MTRand& MTRand::operator=(const MTRand& o) {
    if (*this == &o) return (*this);
    register const uint32 *t = o.state;
    register uint32 *s = state;
    register int i = N;
    for (; i--; *s++ = *t++) {}
    left = o.left;
    pNext = &state[N-left];
    return (*this);
  }

  #endif  // MERSENNETWISTER_H
cpp%

show class MTRand = %cs
  // C# port of Mersenne Twister random number generator
  // Not thread safe (unless auto-initialization is avoided and each thread has
  // its own MTRand object)

  using System;
  using System.IO;
  using System.Security.Cryptography;

  public class MTRand {
    // Data
    public const int N = 624; // length of state vector
    public const int SAVE = N + 1; // length of array for save()

    protected const int M = 397; // period parameter

    protected uint[] state = new uint[N]; // internal state
    protected int pNextIndex; // next value index to get from state
    protected int left; // number of values left before reload needed

    // Methods
    public MTRand(uint oneSeed) { seed(oneSeed); }  // initialize with a simple uint
    public MTRand(uint[] bigSeed, uint seedLength = N) { seed(bigSeed, seedLength); }  // or array
    public MTRand() { seed(); }  // auto-initialize with time and ticks
    public MTRand(MTRand o) { // copy
      Array.Copy(o.state, state, N);
      left = o.left;
      pNextIndex = o.pNextIndex;
    }

    // Do NOT use for CRYPTOGRAPHY without securely hashing several returned
    // values together, otherwise the generator state can be learned after
    // reading 624 consecutive values.

    // Access to 32-bit random numbers
    public uint randInt() { // integer in [0,2^32-1]
      if (left == 0) reload();
      --left;

      uint s1 = state[pNextIndex++];
      s1 ^= (s1 >> 11);
      s1 ^= (s1 << 7) & 0x9d2c5680U;
      s1 ^= (s1 << 15) & 0xefc60000U;
      return (s1 ^ (s1 >> 18));
    }

    public uint randInt(uint n) { // integer in [0,n] for n < 2^32
      uint used = n;
      used |= used >> 1;
      used |= used >> 2;
      used |= used >> 4;
      used |= used >> 8;
      used |= used >> 16;

      uint i;
      do i = randInt() & used; while (i > n);
      return i;
    }

    public double rand() { return randInt() * (1.0 / 4294967295.0); } // real number in [0,1]
    public double rand(double n) { return rand() * n; } // real number in [0,n]
    public double randExc() { return randInt() * (1.0 / 4294967296.0); } // real number in [0,1)
    public double randExc(double n) { return randExc() * n; } // real number in [0,n)
    public double randDblExc() { return (randInt() + 0.5) * (1.0 / 4294967296.0); } // real number in (0,1)
    public double randDblExc(double n) { return randDblExc() * n; } // real number in (0,n)
    public double this[] { get { return rand(); } } // same as rand()

    // Access to 53-bit random numbers (capacity of IEEE double precision)
    public double rand53() { // real number in [0,1)
      uint a = randInt() >> 5, b = randInt() >> 6;
      return (a * 67108864.0 + b) * (1.0 / 9007199254740992.0);
    }

    // Access to nonuniform random number distributions
    public double randNorm(double mean = 0.0, double stddev = 1.0) {
      double x, y, r;
      do {
        x = 2.0 * rand() - 1.0;
        y = 2.0 * rand() - 1.0;
        r = x * x + y * y;
      } while (r >= 1.0 || r == 0.0);
      double s = Math.Sqrt(-2.0 * Math.Log(r) / r);
      return mean + x * s * stddev;
    }

    // Re-seeding functions with same behavior as initializers
    public void seed(uint oneSeed) {
      initialize(oneSeed);
      reload();
    }

    public void seed(uint[] bigSeed, uint seedLength = N) {
      initialize(19650218U);
      int i = 1;
      int j = 0;
      int k = (N > seedLength ? N : (int)seedLength);
      for (; k > 0; --k) {
        state[i] = state[i] ^ ((state[i - 1] ^ (state[i - 1] >> 30)) * 1664525U);
        state[i] += (bigSeed[j] & 0xffffffffU) + (uint)j;
        state[i] &= 0xffffffffU;
        ++i; ++j;
        if (i >= N) { state[0] = state[N - 1]; i = 1; }
        if (j >= seedLength) j = 0;
      }
      for (k = N - 1; k > 0; --k) {
        state[i] = state[i] ^ ((state[i - 1] ^ (state[i - 1] >> 30)) * 1566083941U);
        state[i] -= (uint)i;
        state[i] &= 0xffffffffU;
        ++i;
        if (i >= N) { state[0] = state[N - 1]; i = 1; }
      }
      state[0] = 0x80000000U;
      reload();
    }

    public void seed() {
      // Use DateTime and Environment.TickCount for seeding
      uint h = hash(DateTime.Now.Ticks, Environment.TickCount);
      seed(h);
    }

    // Saving and loading generator state
    public void save(uint[] saveArray) {
      Array.Copy(state, saveArray, N);
      saveArray[N] = (uint)left;
    }

    public void load(uint[] loadArray) {
      Array.Copy(loadArray, state, N);
      left = (int)loadArray[N];
      pNextIndex = N - left;
    }

    public override string ToString() {
      string s = "";
      for (int i = 0; i < N; ++i) s += state[i] + "\t";
      s += left;
      return s;
    }

    public static MTRand Parse(string s) {
      string[] parts = s.Split('\t');
      MTRand m = new MTRand();
      for (int i = 0; i < N; ++i) m.state[i] = uint.Parse(parts[i]);
      m.left = int.Parse(parts[N]);
      m.pNextIndex = N - m.left;
      return m;
    }

    public MTRand Clone() {
      return new MTRand(this);
    }

    protected void initialize(uint seed) {
      uint[] s = state;
      int i = 1;
      s[0] = seed & 0xffffffffU;
      for (; i < N; ++i)
        s[i] = (1812433253U * (s[i - 1] ^ (s[i - 1] >> 30)) + (uint)i) & 0xffffffffU;
    }

    protected void reload() {
      int i;
      for (i = N - M; i > 0; --i)
        state[N - i] = twist(state[N - i + M], state[N - i], state[N - i + 1]);
      for (; i > 1; --i)
        state[N - i] = twist(state[N - i + M - N], state[N - i], state[N - i + 1]);
      state[N - 1] = twist(state[M - 1], state[N - 1], state[0]);

      left = N;
      pNextIndex = 0;
    }

    protected uint hiBit(uint u) { return u & 0x80000000U; }
    protected uint loBit(uint u) { return u & 0x00000001U; }
    protected uint loBits(uint u) { return u & 0x7fffffffU; }
    protected uint mixBits(uint u, uint v) { return hiBit(u) | loBits(v); }
    protected uint magic(uint u) { return loBit(u) != 0 ? 0x9908b0dfU : 0x0U; }
    protected uint twist(uint m, uint s0, uint s1) {
      return m ^ (mixBits(s0, s1) >> 1) ^ magic(s1);
    }

    protected static uint hash(long t, int c) {
      uint h1 = 0;
      byte[] tb = BitConverter.GetBytes(t);
      for (int i = 0; i < tb.Length; ++i) {
        h1 *= (byte.MaxValue + 2U);
        h1 += tb[i];
      }
      uint h2 = 0;
      byte[] cb = BitConverter.GetBytes(c);
      for (int j = 0; j < cb.Length; ++j) {
        h2 *= (byte.MaxValue + 2U);
        h2 += cb[j];
      }
      return h1 ^ h2;
    }
  }
cs%

show class MTRand = %rs
  use std::fs::File;
  use std::io::{Read, Write};
  use std::time::{SystemTime, UNIX_EPOCH};

  const N: usize = 624;
  const M: usize = 397;
  const SAVE: usize = N + 1;

  pub struct MTRand {
    state: [u32; N],
    left: usize,
    p_next: usize,
  }

  impl MTRand {
    /// simple constructor, seed with single `u32`
    pub fn new(seed: u32) -> Self {
      let mut mt = MTRand {
        state: [0; N],
        left: 0,
        p_next: 0,
      };
      mt.seed(seed);
      mt
    }

    /// seed from array
    pub fn from_slice(seed: &[u32]) -> Self {
      let mut mt = MTRand {
        state: [0; N],
        left: 0,
        p_next: 0,
      };
      mt.seed_slice(seed);
      mt
    }

    /// autoâ€‘seed from `/dev/urandom` or time/clock
    pub fn auto() -> Self {
      let mut mt = MTRand {
        state: [0; N],
        left: 0,
        p_next: 0,
      };
      mt.seed();
      mt
    }

    // ---- public API ----

    pub fn rand_int(&mut self) -> u32 {
      if self.left == 0 {
        self.reload();
      }
      self.left -= 1;
      let mut s1 = self.state[self.p_next];
      self.p_next += 1;
      s1 ^= s1 >> 11;
      s1 ^= (s1 << 7) & 0x9d2c5680;
      s1 ^= (s1 << 15) & 0xefc60000;
      s1 ^ (s1 >> 18)
    }

    pub fn rand_int_n(&mut self, n: u32) -> u32 {
      let mut used = n;
      used |= used >> 1;
      used |= used >> 2;
      used |= used >> 4;
      used |= used >> 8;
      used |= used >> 16;

      loop {
        let i = self.rand_int() & used;
        if i <= n {
          return i;
        }
      }
    }

    pub fn rand(&mut self) -> f64 {
      (self.rand_int() as f64) * (1.0 / 4294967295.0)
    }

    pub fn rand_n(&mut self, n: f64) -> f64 {
      self.rand() * n
    }

    pub fn rand_exc(&mut self) -> f64 {
      (self.rand_int() as f64) * (1.0 / 4294967296.0)
    }

    pub fn rand_exc_n(&mut self, n: f64) -> f64 {
      self.rand_exc() * n
    }

    pub fn rand_dbl_exc(&mut self) -> f64 {
      ((self.rand_int() as f64) + 0.5) * (1.0 / 4294967296.0)
    }

    pub fn rand_dbl_exc_n(&mut self, n: f64) -> f64 {
      self.rand_dbl_exc() * n
    }

    pub fn rand53(&mut self) -> f64 {
      let a = self.rand_int() >> 5;
      let b = self.rand_int() >> 6;
      (a as f64 * 67108864.0 + b as f64) * (1.0 / 9007199254740992.0)
    }

    pub fn rand_norm(&mut self, mean: f64, stddev: f64) -> f64 {
      let (x, y, r);
      loop {
        x = 2.0 * self.rand() - 1.0;
        y = 2.0 * self.rand() - 1.0;
        r = x * x + y * y;
        if r < 1.0 && r != 0.0 {
          break;
        }
      }
      let s = (-2.0 * r.ln() / r).sqrt();
      mean + x * s * stddev
    }

    pub fn save(&self) -> [u32; SAVE] {
      let mut out = [0u32; SAVE];
      out[..N].copy_from_slice(&self.state);
      out[N] = self.left as u32;
      out
    }

    pub fn load(&mut self, data: &[u32; SAVE]) {
      self.state.copy_from_slice(&data[..N]);
      self.left = data[N] as usize;
      self.p_next = N - self.left;
    }

    // ---- seeding ----

    pub fn seed(&mut self) {
      // try /dev/urandom
      let mut buf = [0u8; 4 * N];
      if let Ok(mut f) = File::open("/dev/urandom") {
        if f.read_exact(&mut buf).is_ok() {
          let mut words = [0u32; N];
          for (i, chunk) in buf.chunks_exact(4).enumerate() {
            words[i] = u32::from_ne_bytes(chunk.try_into().unwrap());
          }
          self.seed_slice(&words);
          return;
        }
      }

      // fallback
      let now = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap()
        .as_nanos() as u64;
      let ticks = unsafe { libc::clock() } as u64;
      let h = Self::hash(now, ticks);
      self.seed_one(h);
    }

    pub fn seed_one(&mut self, seed: u32) {
      self.initialize(seed);
      self.reload();
    }

    pub fn seed_slice(&mut self, big_seed: &[u32]) {
      self.initialize(19650218);
      let mut i = 1usize;
      let mut j = 0usize;
      let k = N.max(big_seed.len());

      for _ in 0..k {
        self.state[i] = self.state[i]
          ^ ((self.state[i - 1] ^ (self.state[i - 1] >> 30)).wrapping_mul(1664525));
        self.state[i] = self.state[i]
          .wrapping_add(big_seed[j])
          .wrapping_add(j as u32);
        i += 1;
        j += 1;
        if i >= N {
          self.state[0] = self.state[N - 1];
          i = 1;
        }
        if j >= big_seed.len() {
          j = 0;
        }
      }

      for _ in 0..(N - 1) {
        self.state[i] = self.state[i]
          ^ ((self.state[i - 1] ^ (self.state[i - 1] >> 30))
            .wrapping_mul(1566083941));
        self.state[i] = self.state[i].wrapping_sub(i as u32);
        i += 1;
        if i >= N {
          self.state[0] = self.state[N - 1];
          i = 1;
        }
      }
      self.state[0] = 0x8000_0000;
      self.reload();
    }

    // ---- internal helpers ----

    fn initialize(&mut self, seed: u32) {
      self.state[0] = seed;
      for i in 1..N {
        self.state[i] = 1812433253u32
        .wrapping_mul(self.state[i - 1] ^ (self.state[i - 1] >> 30))
        .wrapping_add(i as u32);
      }
    }

    fn reload(&mut self) {
      for i in 0..(N - M) {
        self.state[i] =
          Self::twist(self.state[i + M], self.state[i], self.state[i + 1]);
      }
      for i in (N - M)..(N - 1) {
        self.state[i] = Self::twist(
          self.state[i + M - N],
          self.state[i],
          self.state[i + 1],
        );
      }
      self.state[N - 1] =
        Self::twist(self.state[M - 1], self.state[N - 1], self.state[0]);

      self.left = N;
      self.p_next = 0;
    }

    #[inline]
    fn hi_bit(u: u32) -> u32 {
      u & 0x8000_0000
    }

    #[inline]
    fn lo_bit(u: u32) -> u32 {
      u & 0x0000_0001
    }

    #[inline]
    fn lo_bits(u: u32) -> u32 {
      u & 0x7fff_ffff
    }

    #[inline]
    fn mix_bits(u: u32, v: u32) -> u32 {
      Self::hi_bit(u) | Self::lo_bits(v)
    }

    #[inline]
    fn magic(u: u32) -> u32 {
      if Self::lo_bit(u) != 0 {
        0x9908_b0df
      } else {
        0
      }
    }

    #[inline]
    fn twist(m: u32, s0: u32, s1: u32) -> u32 {
      m ^ (Self::mix_bits(s0, s1) >> 1) ^ Self::magic(s1)
    }

    fn hash(t: u64, c: u64) -> u32 {
      let mut h1 = 0u32;
      for byte in t.to_ne_bytes() {
        h1 = h1.wrapping_mul(u8::MAX as u32 + 2);
        h1 = h1.wrapping_add(u32::from(byte));
      }
      let mut h2 = 0u32;
      for byte in c.to_ne_bytes() {
        h2 = h2.wrapping_mul(u8::MAX as u32 + 2);
        h2 = h2.wrapping_add(u32::from(byte));
      }
      h1 ^ h2
    }
  }
rs%