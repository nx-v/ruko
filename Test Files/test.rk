// test file for the Ruko Language
proc main {
  use Figlet.*,
    Dom.{Canvas, Audio, FS, Log},
    Artists.`Nexo Volta`,
    Galaxies.MilkyWay:Galaxy,
    Components.Post;

  let stars = Galaxy.getVisibleStars();
  if const prophecy = 3 ** (3 * 2) &&
  stars has "Alained" &&
  "Nexo" in stars \map\ _-1.name {
    [Dom.Canvas clear:
                setBackground: 'black'
                draw: prophecy.toSVG()];
    [Audio.Track play: './VirtualRiot-Reconnect.mp3'
                 volume: 0.8
                 `loop`: true];
    Post.emit(
      dev: <`Nexo Volta` handle=@nexoVolta/>
    );
  }

  [FS writeFile: :utf-8, new? Log{
    path: 'C://users/NexoV/memories/2025',
    message: 'before there was code, there was\n' +
      Figlet.toAscii(str prophecy),
    title: 'nu-Eden: Sundered Skies',
  }];
}

// variable declarations
let `user name` = "Nexo";
let message = #"Hello, #`user name`!";
let mut a: i32 = 10;
let mut i32 x = 15;
pub let i32 a = 20;
let int[][][][] y = [[[[1, 2], [3]], [[4, 5]]], [[[6]]]];
let &mut int z = &mut a;
&Type a = 10;
(int | 'hello world') b = "hello world";
let int[] result = [];
pub func int x(mut const int x) =
  arr.reduce 0 (int|int sum, int value| sum + value);
let x = 10;
let mut str name = "Ruko";
let f32 pi = 3.14159;
let f64 x = 2.718281828459045;
let f128 z = 1.618033988749895;
let bool isActive = true;
let char initial = 'R';
let [int | str] c = 42;
mut<X :> T> func<T> identity = |x: x|: X = x;
mut<X :> T> func<T> X identity = X|x x| = x;
X<(|x| func<X>)> identity = |x: x|: X = x;
((((((((((((((((((((int | str))))))))))))))))))))[] c = [1, "two", 3, "four"];
for `int` i = 0, i < 10, i++:
  print("Hello, Ruko World! Iteration: " + i);

// style DSL example
style `style` {
  width: 200px;
  draw: %draw(M 100 100 L 300 100 L 200 300 Z);
  background color: %322;
  text color: %rgb(255, 255, 255);
  fill: %url"https://example.com/resource.txt";
  content: %quote(\(({Hello, World!})\));
  font family: ['Courier New', :monospace];
  margin: 20px;
  padding: 10px;
  border: 2px :solid %#ff5733;
  font size: 14px;
  animation: blink(1s, :infinite, :easeInOut, :alternate);
  timestamp: %time'2024-06-01T12:00:00Z';
}

// imperative style
func int[][] sortedPowerSet(int[] arr) {
  mut int[][] result = [];

  for let int i in 0 ..< 1 << arr::len {
    mut int[] subset = [];
    for let int j in 0 ..< arr::len:
      if (i >> j) & 1:
        subset.=push arr[j];
    result.=push subset;
  }

  return result.=sort(int[][]|int a, int b| {
    let int countA = a.reduce 0, int|int c,, int i| c + 1;
    let int countB = b.reduce 0, int|int d,, int i| d + 1;
    if countA != countB:
      countA - countB;
    for let int i in 0 ..< min a::len b::len:
      if a[i] != b[i]:
        a[i] - b[i];
    a::len - b::len;
  })
}

// infix functional style
func sortedPowerSet = int[][]|int[] arr| 0 ..< 1 << arr::len
  \sort\ int[]|int a, int b| (-) ([a, b]
  \map\ int[]|int k| (arr \reduce\ 0, int|int c,, int i| c + ((k >> i) & 1))
    ) || arr \reduce\ 0, int|int d,, int i| d || ((b >> i) & 1) - ((a >> i) & 1)
  \map\ int[]|int e| (arr \filter\ int|, int i| (e >> i) & 1);

// LINQ style
func int[][] sortedPowerSet(int[] arr) =
  from let int i in 0 ..< (1 << arr::len)
  select (
    from let int j in 0 ..< arr::len
    where (i >> j) & 1
    select arr[j] ) as let int[] subset
  sort by subset::len
  then by (
    from let int a, int b
    where a::len != b::len
    select a::len - b::len )
  then by (
    from let int i in 0 ..< min a::len b::len
    where a[i] != b[i]
    select a[i] - b[i] )
  then by a::len - b::len;

// Haskell/ML/Python style
func int[][] sortedPowerSet(int[] arr) =
  mut int[][] result = [];

  for let int i in 0 ..< 1 << arr::len:
    mut int[] subset = []
    for let int j in 0 ..< arr::len:
      if (i >> j) & 1:
        subset = push subset arr[j];
    result = push result subset;

  return sort result (int[][]|int a, int b| =
    let int countA = reduce a 0, int|int c,, int i| c + 1;
    let int countB = reduce b 0, int|int d,, int i| d + 1;
    if countA != countB:
      countA - countB;
    for let int i in 0 ..< min a::len b::len:
      if a[i] != b[i]:
        a[i] - b[i];
    a::len - b::len);

// Objective-C & Ruby style
func int[][] sortedPowerSet(int[] arr) {
  mut int[][] result = [];

  [0 ..< 1 << arr::len each: |int i| {
    mut int[] subset = [];
    [0 ..< arr::len each: |int j|
      if (i >> j) & 1: [subset =push: arr[j]]]
    [result =push: subset];
  }]

  return [result =sort: int[][]|int a, int b| {
    let int countA = [a reduce: 0, int|int c,, int i| c + 1];
    let int countB = [b reduce: 0, int|int d,, int i| d + 1];
    if countA != countB: return countA - countB;
    for let int i in 0 ..< min(a::len, b::len):
      if a[i] != b[i]:
        return a[i] - b[i];
    a::len - b::len;
  }];
}

// Lisp/Clojure/Scheme style (operators and calls only)
func int[][] sortedPowerSet(int[] arr) {
  mut int[][] result = [];

  for let int i in (..< 0 (<< 1 arr::len)) {
    mut int[] subset = [];
    for let int j in (..< 0 arr::len):
      if (& (>> i j) 1):
        subset = (push subset arr[j]);
    result = (push result subset);
  }

  return (sort result (int[][]|int a, int b| {
    let int countA = (reduce a 0 (int|int c,, int i| (+ c 1)));
    let int countB = (reduce b 0 (int|int d,, int i| (+ d 1)));
    if (!= countA countB):
      (- countA countB);
    for let int i in (..< 0 (min a::len b::len)):
      if (!= a[i] b[i]):
        (- a[i] b[i]);
    (- a::len b::len);
  }));
}

// JSX style
<decl (func int[][] sortedPowerSet(int[] arr))=(
  <mut(type int[][]) (result)=[]/>
  <for let(type int)=i in=(0 ..< 1 << arr::len)>
    <mut(type int[]) (subset)=[]/>
    <for let(type int)=j in=(0 ..< arr::len)>
      <if ((i >> j) & 1)>
        subset.=push arr[j];
      </if>
    </for>
    result.=push subset;
  </for>
  <return (result.=sort(int[][]|int a, int b| <>
    <let(type int) (countA)=(a.reduce 0, int|int c,, int i| c + 1)/>
    <let(type int) (countB)=(b.reduce 0, int|int d,, int i| d + 1)/>
    <if (countA != countB)>
      <return (countA - countB)/>
    </if>
    <for let(type int)=i in=(0 ..< min a::len b::len)>
      <if (a[i] != b[i])>
        <return (a[i] - b[i])/>
      </if>
    </for>
    <return (a::len - b::len)/>
  </>))/>
)/>;

// using the various sortedPowerSet implementations
for let i in sortedPowerSet [1 ... 16]:
  print i;

// LINQ-style queries
func str formatPowerSet = |int[][] a| =
  a.iter(from let int[] subset in a
    where subset::len > 0
    select '[' ++ [subset map: str x `join`: ','] ++ ']'
  ).join(', ');

print $ formatPowerSet sortedPowerSet [1 ..< 10];

// shader language subset example (WGSL-like)
shader MazeGenerator {
  struct Uniforms {prop u32 mazeSize, u32 numWalls};
  struct WallsArray {prop u32[] values};
  mut<group 0, id 0> Uniforms uniforms;
  mut<group 0, id 1> u32[] walls;
  mut<group 0, id 2> WallsArray wallsArray;

  func i32 getCellIndex(Vec2<i32> cellCoords) {
    let i32 size = uniforms.mazeSize;
    cellCoords->y * size + cellCoords->x;
  }

  func f32 coinFlip(Vec2<f32> p) {
    mut Vec3<f32> p3 = fract $ Vec3 p->xyx * 0.1031;
    p3 += dot p3 (p3->yzx + 33.33);
    step 0.5 (fract (p3->x + p3->y) * p3->z);
  }

  // Carve walls for a given cell at random
  proc randomCarveCellWalls(Vec2<i32> cellCoords) {
    let i32 cellIndex = getCellIndex cellCoords;

    let i32 size = uniforms.mazeSize;
    let i32 numWalls = uniforms.numWalls;

    const i32 tWallType = 0; // top
    const i32 rWallType = 1; // right
    const i32 bWallType = 0; // bottom
    const i32 lWallType = 1; // left

    // isOnEdge -> Vec2 isMostLeftEdge isMostBottomEdge
    mut Vec2<bool> isOnEdge = cellCoords == Vec2 0;

    // main body: bottom and left edges
    let f32 bottomNotLeft = coinFlip $ Vec2<f32> cellCoords;
    let i32 bWallIndex = cellIndex * 2 + bWallType;
    let i32 lWallIndex = cellIndex * 2 + lWallType;
    let f32 carveBottom = mix bottomNotLeft 1.0 (f32 isOnEdge->x);
    let f32 carveLeft = mix (1.0 - bottomNotLeft) 1.0 (f32 isOnEdge->y);
    wallsArray.values[bWallIndex] = u32 bottomNotLeft;
    wallsArray.values[lWallIndex] = u32 $ 1.0 - bottomNotLeft;
  }

  compute proc<thread 8 8> main(Vec3<u32> @id) {
    randomCarveCellWalls $ Vec2<i32> @id->xy;
  }
}

// regex examples
/[\d\D]/;
/\p{L}+/;
/\p{Script=Latin}+/;
/\p{sc=Han}+/;
/\p{blk=UCAS_Ext_A}+/;
/\p{name~=/(SMILING|GRINNING) FACE/}/g;
/\p{InGreek}+/i;
/\p{Script=Hiragana}+/m;
/\p{Emoji_Presentation}+/gi;
/(?[\p{Thai}|\p{Lao}])/;
/(?[\p{Digit}&(\p{Thai}|\p{Lao})])/;
/(?[^\P{L}\p{M}])+/;

// generating a random string
func randomString = str |repeat, seed = 3**32| =
  [/[\da-z]/i random: seed, repeat toIter: `join`: ''];
print randomString;

// function call with different argument types
funcName(arg1: 10, &a arg2: 2, stat MyType{k: v} arg3: "hello");
let v = #{a: pub int|*a| a + 1};
oper int k + int x = x * 2;
x = pub int|*a| a + 1;

// chaining with custom operators
// Haskell-style
`iter` 4 $ every 3 (||+ n "10 20") $ (n "0 1 3") # s "triangle" # crush 4
// JavaScript-style
`iter`(4, every(3, add.squeeze("10 20"), n("0 1 3").s("triangle").crush(4)));
n("0 1 3").every(3, add.squeeze("10 20")).iter(4).s("triangle").crush(4)

// arbitrary base digits
let int `custom base` = 16b012345678۹۸۲۷۴٤۶;

// cursed C++ pointer manipulation example
proc x(
  struct {let u32 size = 32} a,
  *mut u8 addr,
  *const f64 b?,
  pub *i32 c?,
)(
  stat (K where K ~ (α + β + γ)) u,
  *pub ((|T, U| <(T as [*U]?)>(U ^ T)) | str) v,
  *&mut (α | β)? y?,
  &mut (***γ??? where !(α & β)?) z!,
): <α, β, γ>(
  ***[(α & β) | γ]? as [[*((|α| β) ^ γ)]?; 20]
) = unsafe {
  mut *α? p = null;
  mut **β? q = null;
  mut **γ? r = null;

  for let int i = 0, i < a::size + 17, i += 1 {
    if y? && !p?:
      p := &y as *α;
    if p? && !q? {
      q := &*(p as **β);
      q[i % 20] := (i * i << (i & 3)) ^ 0xfeedface;
    }
  }

  if z? && z != false:
    for let int j = 0, j < 20, j += 1:
      **z[j] := ((**z[j] ?? 0) + j) as γ;

  func l = compo|*(*i32[]) θ| {
    θ[0][0] := θ[0][0] ^ 1337;
    <div style={color: :green}>\* Pointer value: #{*θ[0][0]} *\</>;
  }

  λ(&q as *(*i32[]));
}

x(
  struct {let u32 size = 32} {},
  unsafe {malloc(type u8)},
  null,
  null,
)(
  unsafe {malloc(type stat u32)},
  unsafe {malloc(type str)},
  null,
  null,
);

// simple linked list node
struct Node {
  let i32 value;
  let *Node next;

  func *Node Node(i32 value) {
    let node = unsafe {malloc Node};
    node.value = value;
    node.next = null;
    return node;
  }
}

mut *Node head = Node 1;
head.next = Node 2;
head.next.next = Node 3;
head.next.next.next = null;
mut *Node current = head;
while current != null {
  print current.value;
  current = current.next;
}

// stropping keywords with invisible characters
`const` `let` mut `mut`: `in` i32 = 10;
scope `for` for let `in` in [`mut` alloc: init: release:]:
  print `in`;

// JSX with inline styles and dynamic class names
<div>
  for item in items:
    <`span` .item-[item.id]=item.id> item.name </`span`>;
</div>;

// JSX control structures
<for let=i in=(0 ... 10)>
  <if (x % 2 == 0)>
    <span>#"Even: #i"</span>
  <elif (x % 3 == 0)/>
    <span>#"Divisible by 3: #i"</span>
  <else/>
    <span>#"Other: #i"</span>
  </if>
</for>;

// component example with props and conditional rendering
module CounterMessage(use React) {
  let compo make = |{count, ?username}|{
    let times = switch count {
      case 1: "once";
      case 2: "twice";
      case n: str(n) ++ " times";
    }

    let name = switch username {
      case Some(""): "Anonymous";
      case Some(name): name;
      case None: "Anonymous";
    }

    <div>#"Hello #name, you clicked me #times"</div>;
  };
}

// console output example with various options
module App(use React, CounterMessage) {
  let compo make = |()|{
    let (int count, |int _| int setCount) = useState(|()|0);
    let (str username, |str _| int setUsername) = useState(|()|"Anonymous");

    <div>
      "Username: ";
      <input
        type="text"
        value=username
        onChange=(|event|{
          event.preventDefault();
          let eventTarget = event.target;
          let username = eventTarget."value";
          setUsername(|prev|username);
        })
      />;
      <button onClick=(|evt|setCount(|prev|prev + 1))>
        "Click me";
      </button>;
      <button onClick=(|evt|setCount(|_|0))>
        "Reset";
      </button>;
      <CounterMessage count username/>;
    </div>;
  };
}

// Tokio async client example with blocking wrapper
use bytes::Bytes;
use std::time::Duration;

impl BlockingClient {
  pub func crate::Result<Bytes?> `get`(&mut self, &str key) {
    self.rt.block_on(self.inner.get(key));
  }

  pub func crate::Result<()> `set`(&mut self, &str key, Bytes value) {
    self.rt.block_on(self.inner.set(key, value));
  }

  pub func crate::Result<()> set_expires(
    &mut self, &str key, Bytes value, Duration expiration,
  ) {
    self.rt.block_on(self.inner.set_expires(key, value, expiration));
  }

  pub func crate::Result<u64> publish(
    &mut self, &str channel, Bytes message
  ) {
    self.rt.block_on(self.inner.publish(channel, message));
  }
}

// the user hasn't been constructed yet, so we need to use 'as' here
let userToBeBuilt = {} as User;

struct User {
  let str id;
  let str name;
  let i32 age?;
  let str email?;
}

let defaultUser = {
  id: "123",
  name: "Matt",
} by User;

// assigning to a dynamic key
(const["name", "id"]).forEach(proc(str key) {
  userToBeBuilt[key] = "default"
});

// style DSL example
style `style` {
  x: 100px;
  y: 100px;
  background color: :blue;
  color: %#ff5733;
  file path: %draw(M 50 50 L 150 50 L 100 150 Z);
  custom key: addedValue;
  dynamic[key] sub[key]: dynamicValue;

  @media (max width: 600px) {background color: :red;}

  @keyframes slidein {
    `from`(transform: translateX 0%);
    `to`(transform: translateX 100%);
  }

  @fontFace {
    font family: 'MyFont';
    src: %file"../fonts/myfont.woff2".format(:woff2);
    font weight: :normal;
    font style: :normal;
  }

  ^hover {color: :green;}
  &active {color: :yellow;}
  &visited {color: :purple;}
  ::before {content: 'Hello';}
  ::after {content: 'World';}

  // Nested selectors
  .container {
    display: :flex;
    flex direction: :column;

    .item {
      margin: 10px;
      padding: 5px;
    }
  }

  animation: slideIn 3s :easeInOut :infinite :alternate;
}

// markdown literals (with embedded code)
<div>
  \\ # Generic Heading 1
  \\ ## Generic Heading 2
  \\ ### Generic Heading 3
  \\ #### Generic Heading 4
  \\ ##### Generic Heading 5
  \\ ###### Generic Heading 6

  <decl (func markdownExample() =
    <div .markdown-container>
    \*
      Term : definition term
           : definition description
      + x
        + _x
        + a_ n // comment after raw string
      - : x z
      > this starts a blockquote [example link](https://example.com)
      > > this is a nested blockquote
      > > _nested italic text
      > > continuing the nested blockquote_
      > - and **bold
      > - text** too
      > last line of the outer blockquote
      this starts a paragraph **with bold text** and _italic text
      with a raw string:_ `C:\Users\Name\Documents\file.txt`
      + ++underline++ ~~strikethrough~~ ==highlight== ||spoiler||
      - this is a list item ~subscript~ and ^superscript^
      + numbered list item (automatic) &#x1F600; &zcaron; &copy; &reg;
      [shortcut] [link text](https://example.com)
      ![image alt text](https://example.com/image.png)
      `pre-rendered` #obj.methodCall(arg1, arg2)
      {style X {x: 10px}}!(p inline styled paragraph)
      {inline code} !{color: :red}**bold red text**
      $\a + y = z ^ 2 - \sqrt{y + x + a}$ // inline math
      !(tag .class span tag with custom attributes !(x nested?!))
    *\

      for let i in 0 ... 3:
        \\ Loop iteration number: #a
    </div>
  )/>
</div>;

// advanced type mapping example
show type MappedParameterTypes<T : Parameter[]> = {
  prop[P in T[num] as P["name"]]: (P of {var any `enum`}
    ? E of str 
      ? P.'required' of false
        ? E | null
        : E 
      : never 
    : P of {prop('object') `type`, infer Attributes attributes?}
      ? Attributes of Parameter[]
        ? MappedParameterTypes<Attributes> 
        : never
    : P of {prop('object[]') `type`, never attributes}
      ? any[]
    : P of {prop('object') `type`, infer Attributes attributes}
      ? Attributes of Parameter[]
        ? MappedParameterTypes<Attributes>[]
        : any[]
    : P.'required' of false
      ? TypeMap[P.'type' of keyof TypeMap ? P.'type' : 'string'] | null
      : TypeMap[P.'type' of keyof TypeMap ? P.'type' : 'string']
  );
};

// SQL query example
from users
left join posts on users.id = posts.user_id
where users.active = 1
group by users.id, users.name
having post_count > 10
order desc by post_count
limit 50
select users.id, users.name, count posts.id as post_count;

// string literals with interpolation and raw strings.
// unlike in other languages, function and method calls can be used inside interpolations.
let x = 42;

let multilineString = #"""
  This is a multiline string.
  It can span multiple lines.
  The value of x is: #x.toStr().concat('!').format(toHex: true)
""";

let rawString = $"""
  This is a raw string.
  It does not process escape sequences like \n or \t.
  You can include quotes " and backslashes \ without escaping.
""";

let combinedStr = #$"""
  Here is a raw string combined with interpolation. \t
  The value of x is: #x
""";

let templateString = @"""
  This is a template string, that is, a function returning a string.
  Arguments are provided for let interpolation, with the syntax @varName
  or @{mut varName = expression}.
  The value of x doubled is: @{mut x = x * 2}
""";