// Ruko is a markup, scripting, styling and shader
// language I'm making that compiles to HTML/CSS/JS,
// WebAssembly, and WebGPU shaders (GLSL, WGSL, etc.).

// This is an implementation of the Mersenne Twister
// pseudorandom number generator (MT19937), loosely
// translated from the original C code by Makoto Matsumoto
// and Takuji Nishimura.

// Translated from https://gist.github.com/yuikns/10017640

use Sys{Crypto, Time, Io, Fs}, Math

show class MTRand : Io.Serializer {
  pub:
    const N = 624
    const SAVE = N + 1

  prot:
    const M = 397

    prop [u32; N] state
    prop &u32 p_next
    prop i32 left
    prop bool has_gauss = false
    prop f64 next_gauss = 0.0

    prop stat u32 differ = 0

    // constructor overloads
    // # = "self"
    proc MTRand(u32 one_seed) = #seed(one_seed)
    proc MTRand(&u32 big_seed, u32 seed_length = N) =
      #seed(big_seed, seed_length)
    proc MTRand() = #seed()
    proc MTRand(&MTRand o) {
      for let i32 i in 0..<N: #state[i] := o.state[i]
      #left := o.left
      #p_next := if #left == 0: &#state.0 else &#state[N - #left]
    }

    proc ~MTRand() {} // no dynamic memory to free

    proc u32 rand_int() {
      // generate N words at one time
      if #left == 0: #reload()
      #left -= 1

      mut u32 s1 = *#p_next
      #p_next += 1

      s1 ^= (s1 >> 11)
      s1 ^= (s1 << 7) & 0x9d2c5680
      s1 ^= (s1 << 15) & 0xefc60000

      s1 ^ (s1 >> 18) // implicit return
    }

    proc u32 rand_int(u32 n) {
      // find the biggest used bit
      mut used = n
      for let i32 i in 0..5:
        used |= used >> (1 << i)

      mut u32 i
      loop i := #rand_int() & used while i >= n

      i // implicit return
    }

    // seed overloads
    proc seed(u32 one_seed) {
      #initialize(one_seed)
      #reload()
    }

    // seed with an array
    proc seed(&u32 big_seed, u32 seed_length = N) {
      #initialize(19650218)

      mut i32 i = 1
      mut u32 j = 0
      mut i32 k = if N > seed_length: N else seed_length

      for in 0..<k {
        #state[i] := #state[i] ^
          ((#state[i - 1] ^ (#state[i - 1] >> 30)) * 0x19660d)
        #state[i] += (big_seed[j] & 0xffffffff) + j
        #state[i] &= 0xffffffff

        i += 1; j += 1

        if i >= N {#state.0 := #state[N - 1]; i := 1}
        if j >= seed_length: j := 0
      }

      for in 0..<N - 1 {
        #state[i] := #state[i] ^
          ((#state[i - 1] ^ (#state[i - 1] >> 30)) * 0x5d588b65)
        #state[i] -= i
        #state[i] &= 0xffffffff

        i += 1
        if i >= N {#state.0 := #state[N - 1]; i := 1}
      }

      #state.0 := 0x80000000
      #reload()
    }

    // seed with system entropy or time-based seed
    proc seed() {
      let ur = Crypto.open_urandom()

      if ?ur {
        mut [u32; N] big
        mut ok = true
         for let i32 i in 0..<N {
          let bytes = ur.get.read_bytes(4)
          if bytes.len != 4 {ok := false; break}
          big[i] := bytes.to_u32(0)
        }
        ur.get.close()
        if ok {#seed(&big.0, N); return}
      }

      let Time.time t = Time.now().to_unix()
      let Time.clock c = Time.clock.to_nanoseconds()
      #seed(#hash(t, c))
    }

    proc initialize(u32 one_seed) {
      #state.0 := one_seed & 0xffffffff

      for let i32 i in 1..<N {
        let u32 x = #state[i - 1] ^ (#state[i - 1] >> 30)
        #state[i] := (0x6c078965 * x + i) & 0xffffffff
      }
    }

    proc reload() {
      mut p = &#state.0

      for in 0..<(N - M) {
        p.0 := #twist(p[M], p.0, p.1)
        p += 1
      }

      for in 0..<(M - 1) {
        p.0 := #twist(p[M - N], p.0, p.1)
        p += 1
      }

      p.0 := #twist(p[M - N], p.0, #state.0)
      #left := N
      #p_next := &#state.0
    }

    proc save(&u32 save_array) {
      mut sa = save_array
      for let i32 i in 0..<N: sa[i] := #state[i]
      sa[N] := #left
    }

    proc load(&u32 load_array) {
      mut la = load_array
      for let i32 i in 0..<N: #state[i] := la[i]
      #left := la[N]
      #p_next := if #left == 0: &#state.0 else &#state[N - #left]
    }

    // hash function for time-based seed
    proc u32 hash(Time.time t, Time.clock c) {
      mut u32 h1 = 0
      let &u8 tb = (&u8) t
      for let i32 i in 0..<sizeof(Time.time) {
        h1 *= u8.max_value + 2
        h1 += (u32) tb[i]
      }

      mut u32 h2 = 0
      let &u8 cb = (&u8) c
      for let i32 i in 0..<sizeof(Time.clock) {
        h2 *= u8.max_value + 2
        h2 += (u32) cb[i]
      }

      let u32 out = (h1 + #differ) ^ h2
      #differ += 1
      out // implicit return
    }

    proc u32 twist(u32 m, u32 s0, u32 s1) =
      m ^ (#mix_bits(s0, s1) >> 1) ^ #magic(s1)

    proc u32 mix_bits(u32 u, u32 v) =
      #hi_bit(u) | #lo_bits(v)

    proc u32 magic(u32 u) =
      if #lo_bit(u) != 0: 0x9908b0df else 0x0

    proc u32 hi_bit(u32 u) = u & 0x80000000
    proc u32 lo_bit(u32 u) = u & 0x00000001
    proc u32 lo_bits(u32 u) = u & 0x7fffffff

    // additional generation functions
    proc f64 rand() =
      ((f64) #rand_int()) * (1.0 / 0xffffffff.0)
    proc f64 rand(f64 n) =
      #rand() * n
    proc f64 rand_exc() =
      ((f64) #rand_int()) * (1.0 / 0x100000000.0)
    proc f64 rand_exc(f64 n) =
      #rand_exc() * n
    proc f64 rand_dbl_exc() =
      (((f64) #rand_int()) + 0x0.8) * (1.0 / 0x100000000.0)
    proc f64 rand_dbl_exc(f64 n) =
      #rand_dbl_exc() * n

    proc f64 rand_53() {
      let u32 a = #rand_int() >> 5 // 27 bits
      let u32 b = #rand_int() >> 6 // 26 bits
      ((f64) a * 0x4000000.0 + (f64) b) *
        (1.0 / 0x20000000000000.0) // implicit return
    }

    proc u32 genrand_int_31() = #rand_int() >> 1
    proc f64 genrand_real_1() = #rand_dbl_exc()
    proc f64 genrand_real_2() = #rand()
    proc f64 genrand_real_3() = #rand_exc()
    proc f64 genrand_res_53() = #rand_53()

    // normally distributed number
    proc f64 rand_norm(f64 mean = 0.0, f64 std_dev = 1.0) {
      if #has_gauss {
        #has_gauss := false
        return #next_gauss * std_dev + mean
      }

      mut f64 x, y, r
      loop {
        x := 2.0 * #rand() - 1.0
        y := 2.0 * #rand() - 1.0
        r := x**2 + y**2
      } while r >= 1.0 || r == 0.0

      let f64 s = Math.sqrt(-2.0 * Math.log(r) / r)
      #next_gauss := y * s + mean
      #has_gauss := true
      x * s * std_dev + mean
    }

    // override
    proc str serialize() { 
      mut str s = ''
      for let i32 i in 0..<N:
        s ++= (str) #state[i] ++ '\t'
      s ++= (str) #left
      s // implicit return
    }

    static proc deserialize(str s) {
      let [str] parts = s / '\t' // division = split
      for let i32 i in 0..<N:
        #state[i] := (u32) parts[i]
      #left := (i32) parts[N]
      #p_next := if #left == 0: &#state.0 else &#state[N - #left]
    }

    static proc u32 hash(str s) {
      mut u32 h = 0
      let [u8] bytes = s.to_bytes()
      for let i32 i in 0..<bytes.len {
        h *= u8.max_value + 2
        h += (u32) bytes[i]
      }
      mut u32 h2 = 0
      for let i32 i in 0..<bytes.len {
        h2 *= u8.max_value + 2
        h2 += (u32) bytes[bytes.len - i - 1]
      }
      h ^ h2 // implicit return
    }

    // operator overloads
    oper()(): f64 = #rand()

    right oper prec 4 (&Io.OutputStream o_stream) <- (&MTRand mt_rand): &Io.OutputStream {
      for let i32 i in 0..<N:
        o_stream.write_str((str) mt_rand.state[i] ++ '\t')
      o_stream.write_str((str) mt_rand.left)
      o_stream // implicit return
    }

    left oper prec 4 (&Io.InputStream i_stream) -> (&MTRand mt_rand): &Io.InputStream {
      for let i32 i in 0..<N {
        let str line = i_stream.read_line()
        mt_rand.state[i] := (u32) line
      }

      let str line = i_stream.read_line()
      mt_rand.left := (i32) line
      mt_rand.p_next := &mt_rand.state[N - mt_rand.left]
      i_stream // implicit return
    }

    right oper prec 1 =(&MTRand o): &MTRand {
      if *self == o: return *self
      for let i32 i in 0..<N: #state[i] := o.state[i]
      #left := o.left
      #p_next := &#state[N - #left]
      *self // implicit return
    }
}

MTRand rand = new MTRand
rand.seed()

rand -> Fs.open('mtstate.txt', fm_write).get.close()
rand <- Fs.open('mtstate.txt', fm_read).get.close()

/* Mersenne Twister random number generator
   Original C++ code by Shawn Cokus and Makoto Matsumoto */

show class MTRand = script cpp {
  #ifndef MERSENNETWISTER_H
  #define MERSENNETWISTER_H

  // Not thread safe (unless auto-initialization is avoided and each thread has
  // its own MTRand object)

  #include <iostream>
  #include <climits>
  #include <cstdio>
  #include <ctime>
  #include <cmath>

  class MTRand {
  // Data
  public:
    typedef unsigned long uint32;  // unsigned integer type, at least 32 bits

    enum { N = 624 };       // length of state vector
    enum { SAVE = N + 1 };  // length of array for save()

  protected:
    enum { M = 397 };  // period parameter

    uint32 state[N];   // internal state
    uint32 *pNext;     // next value to get from state
    int left;          // number of values left before reload needed

  // Methods
  public:
    MTRand(const uint32 oneSeed);  // initialize with a simple uint32
    MTRand(uint32 *const bigSeed, uint32 const seedLength = N);  // or array
    MTRand();  // auto-initialize with /dev/urandom or time() and clock()
    MTRand(const MTRand& o);  // copy

    // Do NOT use for CRYPTOGRAPHY without securely hashing several returned
    // values together, otherwise the generator state can be learned after
    // reading 624 consecutive values.

    // Access to 32-bit random numbers
    uint32 randInt();                     // integer in [0,2^32-1]
    uint32 randInt(const uint32 n);     // integer in [0,n] for n < 2^32
    double rand();                        // real number in [0,1]
    double rand(const double n);        // real number in [0,n]
    double randExc();                     // real number in [0,1)
    double randExc(const double n);     // real number in [0,n)
    double randDblExc();                  // real number in (0,1)
    double randDblExc(const double n);  // real number in (0,n)
    double operator()();                  // same as rand()

    // Access to 53-bit random numbers (capacity of IEEE double precision)
    double rand53();  // real number in [0,1)

    // Access to nonuniform random number distributions
    double randNorm(const double mean = 0.0, const double stddev = 1.0);

    // Re-seeding functions with same behavior as initializers
    void seed(const uint32 oneSeed);
    void seed(uint32 *const bigSeed, const uint32 seedLength = N);
    void seed();

    // Saving and loading generator state
    void save(uint32* saveArray) const;  // to array of size SAVE
    void load(uint32 *const loadArray);  // from such array
    friend std::ostream& operator<<(std::ostream& os, const MTRand& mtrand);
    friend std::istream& operator>>(std::istream& is, MTRand& mtrand);
    MTRand& operator=(const MTRand& o);

  protected:
    void initialize(const uint32 oneSeed);
    void reload();
    uint32 hiBit(const uint32 u) const { return u & 0x80000000UL; }
    uint32 loBit(const uint32 u) const { return u & 0x00000001UL; }
    uint32 loBits(const uint32 u) const { return u & 0x7fffffffUL; }
    uint32 mixBits(const uint32 u, const uint32 v) const { 
      return hiBit(u) | loBits(v); }
    uint32 magic(const uint32 u) const {
      return loBit(u) ? 0x9908b0dfUL : 0x0UL; }
    uint32 twist(const uint32 m, const uint32 s0, const uint32 s1) const {
      return m ^ (mixBits(s0,s1)>>1) ^ magic(s1); }
    static uint32 hash(time_t t, clock_t c);
  };

  // Functions are defined in order of usage to assist inlining

  inline MTRand::uint32 MTRand::hash(time_t t, clock_t c) {
    // Get a uint32 from t and c
    // Better than uint32(x) in case x is floating point in [0,1]
    // Based on code by Lawrence Kirby (fred@genesis.demon.co.uk)

    static uint32 differ = 0;  // guarantee time-based seeds will change
    uint32 h1 = 0;
    unsigned char *p = (unsigned char *) &t;
    for (size_t i = 0; i < sizeof(t); ++i) {
      h1 *= UCHAR_MAX + 2U;
      h1 += p[i];
    }
    uint32 h2 = 0;
    p = (unsigned char *) &c;
    for (size_t j = 0; j < sizeof(c); ++j) {
      h2 *= UCHAR_MAX + 2U;
      h2 += p[j];
    }

    return (h1 + differ++) ^ h2;
  }

  inline void MTRand::initialize(const uint32 seed) {
    // Initialize generator state with seed
    // See Knuth TAOCP Vol 2, 3rd Ed, p.106 for multiplier.
    // In previous versions, most significant bits (MSBs) of the seed affect
    // only MSBs of the state array. Modified 9 Jan 2002 by Makoto Matsumoto.
    register uint32 *s = state;
    register uint32 *r = state;
    register int i = 1;
    *s++ = seed & 0xffffffffUL;
    for (; i < N; ++i) {
      *s++ = (1812433253UL * (*r ^ (*r >> 30)) + i) & 0xffffffffUL;
      r++;
    }
  }

  inline void MTRand::reload() {
    // Generate N new values in state
    // Made clearer and faster by Matthew Bellew (matthew.bellew@home.com)
    static const int MmN = int(M) - int(N);  // in case enums are unsigned
    register uint32 *p = state;
    register int i;
    for (i = N - M; i--; ++p)
      *p = twist(p[M], p[0], p[1]);
    for (i = M; --i; ++p)
      *p = twist(p[MmN], p[0], p[1]);
    *p = twist(p[MmN], p[0], state[0]);

    left = N, pNext = state;
  }

  inline void MTRand::seed(const uint32 oneSeed) {
    initialize(oneSeed);
    reload();
  }

  inline void MTRand::seed(uint32 *const bigSeed, const uint32 seedLength) {
    // Seed the generator with an array of uint32's
    // There are 2^19937-1 possible initial states. this function allows
    // all of those to be accessed by providing at least 19937 bits (with a
    // default seed length of N = 624 uint32's).  Any bits above the lower 32
    // in each element are discarded.
    // Just call seed() if you want to get array from /dev/urandom
    initialize(19650218UL);
    register int i = 1;
    register uint32 j = 0;
    register int k = (N > seedLength ? N : seedLength);
    for (; k; --k) {
      state[i] =
        state[i] ^ ((state[i-1] ^ (state[i-1] >> 30)) * 1664525UL);
      state[i] += (bigSeed[j] & 0xffffffffUL) + j;
      state[i] &= 0xffffffffUL;
      ++i;  ++j;
      if (i >= N) { state[0] = state[N-1];  i = 1; }
      if (j >= seedLength) j = 0;
    }
    for (k = N - 1; k; --k) {
      state[i] =
        state[i] ^ ((state[i-1] ^ (state[i-1] >> 30)) * 1566083941UL);
      state[i] -= i;
      state[i] &= 0xffffffffUL;
      ++i;
      if (i >= N) { state[0] = state[N-1];  i = 1; }
    }
    state[0] = 0x80000000UL;  // MSB is 1, assuring non-zero initial array
    reload();
  }

  inline void MTRand::seed() {
    // Seed the generator with an array from /dev/urandom if available
    // Otherwise use a hash of time() and clock() values

    // First try getting an array from /dev/urandom
    FILE* urandom = fopen("/dev/urandom", "rb");

    if (urandom) {
      uint32 bigSeed[N];
      register uint32 *s = bigSeed;
      register int i = N;
      register bool success = true;
      while (success && i--)
        success = fread(s++, sizeof(uint32), 1, urandom);
      fclose(urandom);
      if (success) { seed(bigSeed, N); return; }
    }

    // Was not successful, so use time() and clock() instead
    seed(hash(time(NULL), clock()));
  }

  inline MTRand::MTRand(const uint32 oneSeed) { seed(oneSeed); }

  inline MTRand::MTRand(uint32 *const bigSeed, uint32 const seedLength) {
    seed(bigSeed,seedLength); }

  inline MTRand::MTRand() { seed(); }

  inline MTRand::MTRand(const MTRand& o) {
    register const uint32 *t = o.state;
    register uint32 *s = state;
    register int i = N;
    for (; i--; *s++ = *t++) {}
    left = o.left;
    pNext = &state[N-left];
  }

  inline MTRand::uint32 MTRand::randInt() {
    // Pull a 32-bit integer from the generator state
    // Every other access function simply transforms the numbers extracted here

    if (left == 0) reload();
    --left;

    register uint32 s1;
    s1 = *pNext++;
    s1 ^= (s1 >> 11);
    s1 ^= (s1 <<  7) & 0x9d2c5680UL;
    s1 ^= (s1 << 15) & 0xefc60000UL;
    return (s1 ^ (s1 >> 18));
  }

  inline MTRand::uint32 MTRand::randInt(const uint32 n) {
    // Find which bits are used in n
    // Optimized by Magnus Jonsson (magnus@smartelectronix.com)
    uint32 used = n;
    used |= used >> 1;
    used |= used >> 2;
    used |= used >> 4;
    used |= used >> 8;
    used |= used >> 16;

    // Draw numbers until one is found in [0,n]
    uint32 i;
    do
      i = randInt() & used;  // toss unused bits to shorten search
    while (i > n);
    return i;
  }

  inline double MTRand::rand() {
    return double(randInt()) * (1.0/4294967295.0); }

  inline double MTRand::rand(const double n) {
    return rand() * n; }

  inline double MTRand::randExc() {
    return double(randInt()) * (1.0/4294967296.0); }

  inline double MTRand::randExc(const double n) {
    return randExc() * n; }

  inline double MTRand::randDblExc() {
    return (double(randInt()) + 0.5) * (1.0/4294967296.0); }

  inline double MTRand::randDblExc(const double n) {
    return randDblExc() * n; }

  inline double MTRand::rand53() {
    uint32 a = randInt() >> 5, b = randInt() >> 6;
    return (a * 67108864.0 + b) * (1.0/9007199254740992.0);  // by Isaku Wada
  }

  inline double MTRand::randNorm(const double mean, const double stddev) {
    // Return a real number from a normal (Gaussian) distribution with given
    // mean and standard deviation by polar form of Box-Muller transformation
    double x, y, r;
    do {
      x = 2.0 * rand() - 1.0;
      y = 2.0 * rand() - 1.0;
      r = x * x + y * y;
    } while (r >= 1.0 || r == 0.0);
    double s = sqrt(-2.0 * log(r) / r);
    return mean + x * s * stddev;
  }

  inline double MTRand::operator()() { return rand(); }

  inline void MTRand::save(uint32* saveArray) const {
    register const uint32 *s = state;
    register uint32 *sa = saveArray;
    register int i = N;
    for (; i--; *sa++ = *s++) {}
    *sa = left;
  }

  inline void MTRand::load(uint32 *const loadArray) {
    register uint32 *s = state;
    register uint32 *la = loadArray;
    register int i = N;
    for (; i--; *s++ = *la++) {}
    left = *la;
    pNext = &state[N-left];
  }

  inline std::ostream& operator<<(std::ostream& os, const MTRand& mtrand) {
    register const MTRand::uint32 *s = mtrand.state;
    register int i = mtrand.N;
    for (; i--; os << *s++ << "\t") {}
    return os << mtrand.left;
  }

  inline std::istream& operator>>(std::istream& is, MTRand& mtrand) {
    register MTRand::uint32 *s = mtrand.state;
    register int i = mtrand.N;
    for (; i--; is >> *s++) {}
    is >> mtrand.left;
    mtrand.pNext = &mtrand.state[mtrand.N-mtrand.left];
    return is;
  }

  inline MTRand& MTRand::operator=(const MTRand& o) {
    if (*this == &o) return (*this);
    register const uint32 *t = o.state;
    register uint32 *s = state;
    register int i = N;
    for (; i--; *s++ = *t++) {}
    left = o.left;
    pNext = &state[N-left];
    return (*this);
  }

  #endif  // MERSENNETWISTER_H
}

show class MTRand = script cs {
  // C# port of Mersenne Twister random number generator
  // Not thread safe (unless auto-initialization is avoided and each thread has
  // its own MTRand object)

  using System;
  using System.IO;
  using System.Security.Cryptography;

  public class MTRand {
    // Data
    public const int N = 624;       // length of state vector
    public const int SAVE = N + 1;  // length of array for save()

    protected const int M = 397;  // period parameter

    protected uint[] state = new uint[N];   // internal state
    protected int pNextIndex;     // next value index to get from state
    protected int left;          // number of values left before reload needed

    // Methods
    public MTRand(uint oneSeed) { seed(oneSeed); }  // initialize with a simple uint
    public MTRand(uint[] bigSeed, uint seedLength = N) { seed(bigSeed, seedLength); }  // or array
    public MTRand() { seed(); }  // auto-initialize with time and ticks
    public MTRand(MTRand o) { // copy
      Array.Copy(o.state, state, N);
      left = o.left;
      pNextIndex = o.pNextIndex;
    }

    // Do NOT use for CRYPTOGRAPHY without securely hashing several returned
    // values together, otherwise the generator state can be learned after
    // reading 624 consecutive values.

    // Access to 32-bit random numbers
    public uint randInt() { // integer in [0,2^32-1]
      if (left == 0) reload();
      --left;

      uint s1 = state[pNextIndex++];
      s1 ^= (s1 >> 11);
      s1 ^= (s1 << 7) & 0x9d2c5680U;
      s1 ^= (s1 << 15) & 0xefc60000U;
      return (s1 ^ (s1 >> 18));
    }

    public uint randInt(uint n) { // integer in [0,n] for n < 2^32
      uint used = n;
      used |= used >> 1;
      used |= used >> 2;
      used |= used >> 4;
      used |= used >> 8;
      used |= used >> 16;

      uint i;
      do
        i = randInt() & used;
      while (i > n);
      return i;
    }

    public double rand() { return randInt() * (1.0 / 4294967295.0); } // real number in [0,1]
    public double rand(double n) { return rand() * n; } // real number in [0,n]
    public double randExc() { return randInt() * (1.0 / 4294967296.0); } // real number in [0,1)
    public double randExc(double n) { return randExc() * n; } // real number in [0,n)
    public double randDblExc() { return (randInt() + 0.5) * (1.0 / 4294967296.0); } // real number in (0,1)
    public double randDblExc(double n) { return randDblExc() * n; } // real number in (0,n)
    public double this[] { get { return rand(); } } // same as rand()

    // Access to 53-bit random numbers (capacity of IEEE double precision)
    public double rand53() { // real number in [0,1)
      uint a = randInt() >> 5, b = randInt() >> 6;
      return (a * 67108864.0 + b) * (1.0 / 9007199254740992.0);
    }

    // Access to nonuniform random number distributions
    public double randNorm(double mean = 0.0, double stddev = 1.0) {
      double x, y, r;
      do {
        x = 2.0 * rand() - 1.0;
        y = 2.0 * rand() - 1.0;
        r = x * x + y * y;
      } while (r >= 1.0 || r == 0.0);
      double s = Math.Sqrt(-2.0 * Math.Log(r) / r);
      return mean + x * s * stddev;
    }

    // Re-seeding functions with same behavior as initializers
    public void seed(uint oneSeed) {
      initialize(oneSeed);
      reload();
    }

    public void seed(uint[] bigSeed, uint seedLength = N) {
      initialize(19650218U);
      int i = 1;
      int j = 0;
      int k = (N > seedLength ? N : (int)seedLength);
      for (; k > 0; --k) {
        state[i] = state[i] ^ ((state[i-1] ^ (state[i-1] >> 30)) * 1664525U);
        state[i] += (bigSeed[j] & 0xffffffffU) + (uint)j;
        state[i] &= 0xffffffffU;
        ++i; ++j;
        if (i >= N) { state[0] = state[N-1]; i = 1; }
        if (j >= seedLength) j = 0;
      }
      for (k = N - 1; k > 0; --k) {
        state[i] = state[i] ^ ((state[i-1] ^ (state[i-1] >> 30)) * 1566083941U);
        state[i] -= (uint)i;
        state[i] &= 0xffffffffU;
        ++i;
        if (i >= N) { state[0] = state[N-1]; i = 1; }
      }
      state[0] = 0x80000000U;
      reload();
    }

    public void seed() {
      // Use DateTime and Environment.TickCount for seeding
      uint h = hash(DateTime.Now.Ticks, Environment.TickCount);
      seed(h);
    }

    // Saving and loading generator state
    public void save(uint[] saveArray) {
      Array.Copy(state, saveArray, N);
      saveArray[N] = (uint)left;
    }

    public void load(uint[] loadArray) {
      Array.Copy(loadArray, state, N);
      left = (int)loadArray[N];
      pNextIndex = N - left;
    }

    public override string ToString() {
      string s = "";
      for (int i = 0; i < N; ++i) s += state[i] + "\t";
      s += left;
      return s;
    }

    public static MTRand Parse(string s) {
      string[] parts = s.Split('\t');
      MTRand m = new MTRand();
      for (int i = 0; i < N; ++i) m.state[i] = uint.Parse(parts[i]);
      m.left = int.Parse(parts[N]);
      m.pNextIndex = N - m.left;
      return m;
    }

    public MTRand Clone() {
      return new MTRand(this);
    }

    protected void initialize(uint seed) {
      uint[] s = state;
      int i = 1;
      s[0] = seed & 0xffffffffU;
      for (; i < N; ++i) {
        s[i] = (1812433253U * (s[i-1] ^ (s[i-1] >> 30)) + (uint)i) & 0xffffffffU;
      }
    }

    protected void reload() {
      int i;
      for (i = N - M; i > 0; --i) {
        state[N - i] = twist(state[N - i + M], state[N - i], state[N - i + 1]);
      }
      for (; i > 1; --i) {
        state[N - i] = twist(state[N - i + M - N], state[N - i], state[N - i + 1]);
      }
      state[N - 1] = twist(state[M - 1], state[N - 1], state[0]);

      left = N;
      pNextIndex = 0;
    }

    protected uint hiBit(uint u) { return u & 0x80000000U; }
    protected uint loBit(uint u) { return u & 0x00000001U; }
    protected uint loBits(uint u) { return u & 0x7fffffffU; }
    protected uint mixBits(uint u, uint v) { return hiBit(u) | loBits(v); }
    protected uint magic(uint u) { return loBit(u) != 0 ? 0x9908b0dfU : 0x0U; }
    protected uint twist(uint m, uint s0, uint s1) {
      return m ^ (mixBits(s0, s1) >> 1) ^ magic(s1);
    }

    protected static uint hash(long t, int c) {
      uint h1 = 0;
      byte[] tb = BitConverter.GetBytes(t);
      for (int i = 0; i < tb.Length; ++i) {
        h1 *= (byte.MaxValue + 2U);
        h1 += tb[i];
      }
      uint h2 = 0;
      byte[] cb = BitConverter.GetBytes(c);
      for (int j = 0; j < cb.Length; ++j) {
        h2 *= (byte.MaxValue + 2U);
        h2 += cb[j];
      }
      return h1 ^ h2;
    }
  }
}