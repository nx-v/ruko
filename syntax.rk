// Ruko is a markup, scripting, styling and shader
// language I'm making that compiles to HTML/CSS/JS,
// WebAssembly, and WebGPU shaders (GLSL, WGSL, etc.).

// This is an implementation of the Mersenne Twister
// pseudorandom number generator (MT19937), loosely
// translated from the original C code by Makoto Matsumoto
// and Takuji Nishimura.
// See http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html.

// Its syntax is inspired by Haskell, Rust and Kotlin,
// hence the name "HaRuKo", clipped to just "Ruko".
// but also is named after the character
// Haruko Haruhara from the anime "FLCL".

// Syntax is kind of similar to Haskell, Rust, and Kotlin
// (hence forming the name "HaRuKo", clipped to "Ruko")
// but also has influences from modern and not-so-modern
// languages. If you probably know most of these languages,
// you might be able to see where some of the syntax ideas
// came from.

// I don't know if anyone will ever use this language,
// other than me, but I made it mainly as a personal project
// to experiment with language and compiler design, as well
// as the first step towards making my own game engine and LSP
// for it, along with IDE support, to make developing my game
// nu-Eden: Sundered Skies' using just web technologies,
// without having to juggle multiple languages, frameworks
// and tools (HTML, CSS, JS/TS, WebAssembly, GLSL/WGSL, etc.)
// around like everyone else does.

// ==============================

// Ruko Example Code Snippets
// variables
var x: i32 = 10 // mutable dynamic variable
mut y: i32 = 5 // mutable static variable
let x: str = "Hello, Ruko!" // immutable static variable
auto z = x + " How are you?" // compile-time inferred constant
const e: f64 = 2.71828 // compile-time constant

// infix function syntax
let sortedPowerSet = |arr| 0 ..< 1 << len arr
  \sort\ (|a, b| (-) ([a, b] \map\
      |k| (arr \reduce\ 0, |c,, i| c + ((k >> i) & 1))
    ) || arr \reduce\ 0, |d,, i| d || ((b >> i) & 1) - ((a >> i) & 1))
  \map\ (|e| arr \filter\ |, i| (e >> i) & 1)

// Casting
let a: i32 = 42
let b: f64 = a as f64