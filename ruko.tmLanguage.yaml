name: Ruko
scopeName: source.spwn # will change to Ruko once the language is out
fileTypes: [ruko, rk, spwn]
patterns: [include: '#core']

information: |
  This file is entirely maintained by NexoVolta (nx-v) for the Ruko programming
  language. If you want to contribute, please open an issue or a pull request
  on the official GitHub repository:

  https://github.com/nx-v/ruko

  Please note that this grammar is still a work in progress, and is not yet
  complete. Features and syntax will change frequently as the language evolves.

  In the meantime, please be patient and report any issues you encounter.

todo: |
  - [ ] Rework inline Markdown syntax. Refer to Texy, Textile, AsciiDoc
    and cousins for inspiration. Reimplement with these extensions:
    - [ ] Citations 
    - [x] Deleted and inserted text ~~deleted~~ ++inserted++
    - [x] Superscript ^super^
    - [x] Subscript ~sub~
    - [x] Highlighted text ==highlight==
    - [x] Redacted text ||redacted||
    - [ ] Spans !!.custom.classes span!!
    - [ ] Selectors and anchors #anchor .class
    - [ ] Code blocks 
    - [ ] Definition blocks ::: 
    - [ ] Tables
    - [ ] Headings and subheadings
  - [ ] Plan and implement all the built-in modules, classes, objects, constants
    functions and properties for Ruko's standard library.
    This would all be done in a separate PR and once the grammar is completely
    finished.
  - [ ] Multi-base numeric literals (up to base 64). Digits will be 0-9, a-z, 
    lowercase Icelandic thorn, lowercase eth, A-Z, uppercase Icelandic thorn.
  - [ ] Add new parameter binding/destructuring syntax for:
    - [ ] Strings
    - [ ] Regular expressions
    - [ ] Arrays
    - [ ] Sets
    - [ ] Maps and objects
    - [ ] Tuples
    - [ ] Function arguments
    - [ ] Variables
  - [ ] Rework function call syntax to be more consistent and terser.
    Inspired by Haskell.
  - [x] Rework import/export/module syntax to be terse, drawing inspiration 
    from JavaScript ES6 modules, with changes such as:
      - glob file path matching: import path/**/*.ruko
      - named imports/exports: import module{a,b,c}
      - default imports/exports: import module)
      - renaming imports/exports: import module{a:x,b:y}
      - show/hide mechanism: import module{a,b-c,d}
      - glob-style pattern matching: import module{a*,b?,c{1,2}}
  - [ ] Fix and expand regex syntax and highlighting:
    - [ ] Add and expand quantifiers and range highlighting
    - [ ] Add support for fuzzy matching (edits, insertions, deletions, etc.)
    - [ ] Improve highlighting for regexes with flags

changelog: |
  A major rewrite is underway. This language's syntax would be terser
  and thus inspired by Rust, Zig and D.

  New changes:

  - Custom modifiers can now be placed before any declaration.
    For example: async place func(x) { ... }
    This includes within map declarations and function parameters
    as well, though fn is required in order to use modifiers.
  - Reworked function parameter binding/destructuring syntax. Might
    still need some work. For example:
    func f(const (a, b), let {c, d}, mut [e, f], dyn g) { ... }
  - Reworked function call syntax. Function calls are now
    triggered beside ( and {. a space is no longer required, and
    the function call must be bracketed.
  - Added s-expression and message passing syntax, resembling
    Lisp, Clojure, Elixir and Smalltalk. For example:
    [object message: arg1, arg2 message2: arg3]
    (function arg1 arg2 arg3)
  - Added keywords temp, prop, actor, realm, style, script, intern, extern,
    assert, check, given, using.
  - Fixed empty generics: T<> is now highlighted properly.
  - Fixed style k-v pairs.
  - All control structures do not need to be bracketed. If the body of a
    control structure is a single statement, the braces can be omitted,
    and is replaced by a colon (:). This includes if, for, while, switch,
    match, try, catch, etc.
  - Fixed syntax highlighting of code blocks beside lambda pipes.
  - Added base 4, 6 and 12 numeric literals. Except for base 14, all even
    bases up to 16 are now supported.
  - Overall now closely resembles Rust's. This includes keywords, comments,
    literals, strings etc. Only thing I need to do is to rework how code blocks
    (i.e. clauses) are highlighted to be more consistent with Rust's own grammar.
  - Added s-expressions and message passing, which intentionally
    resembles Lisp, Clojure, Elixir and Smalltalk.
  - Numbers and escape sequences have been reworked, and will no longer accept
  - Most keywords should have a max of 6 characters.
  - Range keywords to, till and by have been removed in favor of range operators.
  - Generics now capture properly before and after function names
    For example, T.<x>, T?.<x>, T!.<x>, T::<x>, T?:<x>, T!:<x>.
    They can even be curried: x<T><U>(y), x<T><U><V>(y).
  - Generic type parameters now work for prefix operators as well. i.e. T<&x>, etc.
  - Fixed a bug where escape sequences for literals would accept integers bigger than 
    decimal 1114111 which now are highlighted as an error.
  - Base 12 (0z, \z in strings and character classes) is added back,
    with A, X, T, or turned 2 for digit 10, and B, E or turned 3 for digit 11.
  - Bases 4 and 6 have been removed, though a multi-base (up to base 64)
    numeric literal is still in the works.
  - Interpolation and formatting syntax have been reworked and fixed, and can now
    span multiple lines and beyond 20 nested layers thanks to applyEndPatternLast.
    Because of this, spacing around most of the patterns here have also been removed;
    a separate 'space' scope is added to join everything together.
  - Function call syntax is heavily standardized and would need a later fix in
    the long run. This is if a more terser variant of Ruko is in the need,
    and if so would be inspired by Haskell.
  - Fixed some bugs with regular expressions:
    - Added and expanded quantifiers and range highlighting
    - Add support for fuzzy matching (edits, insertions, deletions, etc.)
    - Improved highlighting for regexes with flags
  - Added prefixes to strings.
  - Added Python negation syntax: is not, if not, not in, not of. 
    - Removed unless/until keywords. Replaced by if not, while not.
  - Switched around regular expressions: / triggers a regex when it begins an
    expression. ` is now used to begin unquoted strings.
  - Two (or more) regular expressions in a row on the same line without a comma
    triggers a replacement string instead of a normal regular expression literal.
  - Changed up syntax highlighting of switch and match statements to be more
    consistent with JavaScript.
  - Function calls now trigger beside ( and {.
  - Added Perl/Ruby's unless and until keywords.
  - Fixed module syntax to be more consistent with JavaScript.
  - Dashes will no longer allowed in identifiers.
  - Fixed XML highlighting and attributes, inspired by Svelte, Angular (TS), HAML
    - @directive
    - #id and .class
    - :event and |pipe (both from Svelte)
    - %directive
    - &reference and *spread
    - ?boolean and @property (from Lit)
  - Added script blocks for injection of raw JavaScript.
  - Fixed keys in literal objects
  - Fixed modifier keywords beside function literals
  - Fixed default values in function arguments, thus no longer requiring trailing
    commas. 'from' and 'where' statements, the string `\| and the operator | have to
    be bracketed.
  - Slightly changed attribute selectors to allow for regexp matches.
  - Added Scala's 'given'/'using' syntax to function arguments

  Fixes:

  - Fix a bug where interpolated syntax would not be
  - Add multiline \\ syntax for interpolated JS.
  - Large regexps scattered throughout this document also have been
    rewritten with the (?x) syntax to be more readable for editors.
    - [x] Markdown syntax
    - [x] function parameters
    - [x] function calls
    - [x] identifiers and variables
    - [x] operators
    - [x] object literals
    - [x] object labels
    - [x] pipeline functions
    - [x] modifier keywords
    - [x] function assignments
    - [x] anonymous functions
    - [x] embedded content
    - [x] rounded and square brackets
    - [x] LINQ, inline SQL and constraint syntax (more to come later)
  - Fix syntax of type annotations inside generics to avoid being parsed 
    as custom operators.
  - Fix syntax of generic type parameters and constraints.
  - Match unquoted globs in routes
  - Fix syntax for JavaScript ES5 module import and export statements
  - Reimplement Markdown syntax with these extensions:
    - [ ] Citations
    - [ ] Strike-through
    - [ ] Deleted and inserted text
    - [ ] Superscript
    - [ ] Subscript
    - [ ] Spans
    - [ ] Selectors and anchors
    - [ ] Code blocks
    - [ ] Definition blocks
    - [ ] Tables
    - [ ] Headings and subheadings
  - Rework inline "Markdown" syntax. Refer to Texy, Textile, AsciiDoc and cousins.
  - Plan and implement all the built-in objects, constants and
    functions for Ruko's standard library.
    This would all be done in a separate PR and once the grammar is completely
    finished.
    - A handful of built-in properties and constants are part of this grammar
      and are used to highlight CSS properties, constants and HTML tags. Other
      than that, nothing else is present...
      at least not in the moment
    - This features would include:
      - Type, interface, module/namespace and class names
      - Functions and methods
      - Constants and properties
      - Special variables
      - Various UI elements and color names
      - Character names (LaTeX/HTML/AGLFN)
  - Add new parameter binding/destructuring syntax for:
    - [ ] Strings
    - [ ] Regular expressions
    - [ ] Arrays
    - [ ] Sets
    - [ ] Maps and objects
    - [ ] Tuples
    - [ ] Function arguments
    - [ ] Variables

define:
  entity-name: &entity-name |
    (?x) \s*\b

    (?!
      (?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b
      (?: # keywords
        [io]n|of|[ai]s|has|old|new|del
        |unset|ref|and|x?or|not
        |const|let|mut|dyn
        |va[rl]|use|given|state
        |func|proc|prop|type|class|actor
        |impl|enum|module|struct|record
        |union|iter|macro|query|elem|temp
        |object|realm|trait|style|script|quote
        |go|defer|do|with|from|where
        |if|else|then|guard|when
        |for|loop|while|goto|move
        |try|throw|catch|switch
        |match|case|pass|def
        |break|skip|redo|retry
        |return|yield|await|scope
        |import|export|intern|extern
        |debug|assert|check|decl
      )
      \b
    )

    # identifier
    ([\p{Pc}\p{L}]\w*)
    \b

  keywords: |
    (?x) \s* \b

    (?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b
      (?: # keywords
        [io]n|of|[ai]s|has|old|new|del
        |unset|ref|and|x?or|not
        |const|let|mut|dyn
        |va[rl]|use|given|state
        |func|proc|prop|type|class|actor
        |impl|enum|module|struct|record
        |union|iter|macro|query|elem|temp
        |object|realm|trait|style|script|quote
        |go|defer|do|with|from|where
        |if|else|then|guard|when
        |for|loop|while|goto|move
        |try|throw|catch|switch
        |match|case|pass|def
        |break|skip|redo|retry
        |return|yield|await|scope
        |import|export|intern|extern
        |debug|assert|check|decl
      )
    \b

  html-tag-names: &html-tag-names
    - match: (?x)([?!:]:|[?!]?\.)
      captures:
        1: {name: punctuation.separator.namespace.ruko}
    - match: \b([\p{Pc}\p{L}]\w*)\b(?=[:.])
      name: entity.name.tag.namespace.ruko
    - match: \b((?:[\p{Pc}\p{L}&&\P{Ll}][\w&&\P{Lu}]*)+)\b
      name: support.class.component.ruko
    - include: '#clauses'
    - include: '#declarations'
    - include: '#keywords'
    - include: '#html-tag-names'

repository:
  core:
    patterns:
      - include: '#ignore-long-lines'
      - include: '#clauses'
      - include: '#declarations'
      - include: '#keywords'
      - include: '#comments'
      - include: '#argument-list'
      - include: '#function-clause'
      - include: '#symbols'
      - include: '#decorators'
      - include: '#type-signature'
      - include: '#embedded-expression'
      - include: '#embedded-format'
      - include: '#embedded-placeholder'
      - include: '#xml'
      - include: '#generics'
      - include: '#literals'
      - include: '#accessor-operators'
      - include: '#brackets'
      - include: '#punctuation'
      - include: '#operators'
      - include: '#function-calls'
      - include: '#variables'
      - include: '#illegal'
      - include: '#space'

  # Ignore Patterns

  ignore-long-lines:
    comment: avoid parsing files with long lines of code
    match: ^.{4097,}$

  space:
    match: \s+
    name: meta.var.expr.ruko

  # Illegal Syntax

  illegal:
    patterns:
      - match: \p{N}[\w.+-/\\]*?
        name: invalid.illegal.numeric.ruko
      - match: '[\w]+?'
        name: invalid.illegal.variable.ruko
      - match: '[({\[)}\]]+?'
        name: invalid.illegal.missing-bracket.ruko
      - match: '[\p{P}\p{S}&&[^,;''"`({\[)}\]\p{Pc}]]+'
        name: invalid.illegal.operator.ruko
      - match: \S+?
        name: invalid.illegal.uncaught.ruko

  illegal-identifier:
    applyEndPatternLast: true
    name: meta.type.ruko
    begin: (?<=\w+\b)\s*(?=\b\w+)
    end: (?=)|$
    patterns:
      - match: \s*\w+\s*
        name: invalid.illegal.identifier.ruko

  # Types

  types:
    patterns:
      - include: '#comments'
      - include: '#type-brackets'
      - include: '#embedded-expression'
      - include: '#embedded-format'
      - include: '#embedded-placeholder'
      - include: '#angle-brackets'
      - include: '#type-modifiers'
      - include: '#type-keywords'
      - include: '#type-names'
      - include: '#literals'
      - include: '#type-variables'
      - include: '#type-operators'
      - include: '#space'

  type-variables:
    comment: |
      Four types of variables:
      - _lead_underscore
      - UPPERCASE
      - PascalCase
      - camelCase
    match: |
      (?x) \s* \b

      (?!
        (?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b
        (?: # keywords
          [io]n|of|[ai]s|has|old|new|del
          |unset|ref|and|x?or|not
          |const|let|mut|dyn
          |va[rl]|use|given|state
          |func|proc|prop|type|class|actor
          |impl|enum|module|struct|record
          |union|iter|macro|query|elem|temp
          |object|realm|trait|style|script|quote
          |go|defer|do|with|from|where
          |if|else|then|guard|when
          |for|loop|while|goto|move
          |try|throw|catch|switch
          |match|case|pass|def
          |break|skip|redo|retry
          |return|yield|await|scope
          |import|export|intern|extern
          |debug|assert|check|decl
        )
        \b
      )

      (?:
        (?<=(?:^|[,;'"`(){}\[\]\w\s]|\\.)(?:[!?]?\.=?|[?!:]:=?|[?!-]>=?))
        (?: # Properties
            # Leading underscore
            (\p{Pc}+\w*\b(?!\p{Pc}+))
          | # Train case
            ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)
          | # Pascal case
            ((?:[\p{Pc}\p{L}&&\P{Ll}][\w&&\P{Lu}]*)+)
          | # Camel or kebab case
            ([\p{Pc}\p{L}]\w*)
        )
        |
        (?: # Objects
            # Leading underscore
            (\p{Pc}+\w*\b(?!\p{Pc}+))
          | # Train case
            ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)
          | # Pascal case
            ((?:[\p{Pc}\p{L}&&\P{Ll}][\w&&\P{Lu}]*)+)
          | # Camel or kebab case
            ([\p{Pc}\p{L}]\w*)
        )
        (?=(?:[!?]?\.=?|[?!:]:=?|[?!-]>=?|<)(?:[,;'"`(){}\[\]\w\s]|$))
        |
        (?: # Regular variables
            # Leading underscore
            (\p{Pc}+\w*\b(?!\p{Pc}+))
          | # Train case
            ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)
          | # Pascal case
            ((?:[\p{Pc}\p{L}&&\P{Ll}][\w&&\P{Lu}]*)+)
          | # Camel or kebab case
            ([\p{Pc}\p{L}]\w*)
        )
      )\b

      \s*
    captures:
      1: {name: entity.name.trait.ruko}
      2: {name: entity.name.interface.ruko}
      3: {name: entity.name.interface.ruko}
      4: {name: entity.name.trait.ruko}
      5: {name: entity.name.module.ruko}
      6: {name: entity.name.namespace.ruko}
      7: {name: entity.name.namespace.ruko}
      8: {name: entity.name.module.ruko}
      9: {name: entity.name.type.ruko}
      10: {name: entity.name.class.ruko}
      11: {name: entity.name.class.ruko}
      12: {name: entity.name.type.ruko}

  type-signature:
    applyEndPatternLast: true
    name: meta.type.ruko
    begin: (?<=(?:[)}\]\w\s'"`]|\\.)\|?|^\|?)(:)(?=$|[\w\s'"`({\[])
    end: (?=)|$
    beginCaptures:
      1: {name: punctuation.definition.annotation.ruko}
    patterns:
      - include: '#types'

  type-brackets:
    patterns:
      - include: '#type-curly-brackets'
      - include: '#type-square-brackets'
      - include: '#type-round-brackets'

  type-curly-brackets:
    repository:
      punctuation:
        patterns:
          - match: ','
            name: punctuation.separator.mapping.ruko
          - match: (?<=(?:['"`)}\]\w]|\\.)[\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]*):(?=['"`({\[\w\s]|$)
            name: punctuation.separator.key-value.ruko

    patterns:
      - begin: |
          (?x)
          (?<=
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \b
              (?: # destructuring keywords
                const|let|mut|dyn
                |va[rl]|use|given|state
                |case
              )
            \b
            (?:$|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \s*
          )
          (\#?\{)\s*
        end: \s*(\})
        name: meta.brace.curly.ruko
        captures:
          1:
            name: punctuation.definition.binding-pattern.object.ruko
        patterns:
          - include: '#labels'
          - include: '#punctuation'
          - include: '#as-keyword'
          - include: '#types'
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \b
              (?: # expression keywords
                [io]n|of|[ai]s|has|old|new|del
                |unset|ref|and|x?or|not
              )
            \b
            (?:$|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \s*
          )
          (\#\{)\s*
        end: \s*(\})
        name: meta.brace.curly.ruko
        captures:
          1: {name: punctuation.definition.mapping.ruko}
        patterns:
          - include: '#labels'
          - include: '#punctuation'
          - include: '#types'
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \b
              (?: # expression keywords
                [io]n|of|[ai]s|has|old|new|del
                |unset|ref|and|x?or|not
              )
            \b
            (?:$|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \s*
          )
          (\{)\s*
        end: \s*(\})
        name: meta.brace.curly.ruko
        captures:
          1: {name: punctuation.definition.dictionary.ruko}
        patterns:
          - include: '#labels'
          - include: '#punctuation'
          - include: '#types'
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:
                ^
              | [,;({\[]
              | (?:^|[,;({\[)}\]\w'"`]|\\.):\s*
              | [\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]+
            )
            \s*
          )
          (\#\{)\s*
        end: \s*(\})
        name: meta.brace.curly.ruko
        captures:
          1: {name: punctuation.definition.mapping.ruko}
        patterns:
          - include: '#labels'
          - include: '#punctuation'
          - include: '#types'
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:
                ^
              | [,;({\[]
              | (?:^|[,;({\[)}\]\w'"`]|\\.):\s*
              | [\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]+
            )
            \s*
          )
          (\{)\s*
        end: \s*(\})
        name: meta.brace.curly.ruko
        captures:
          1: {name: punctuation.definition.dictionary.ruko}
        patterns:
          - include: '#labels'
          - include: '#punctuation'
          - include: '#types'
          - include: $self

  type-round-brackets:
    repository:
      punctuation:
        patterns:
          - match: ','
            name: punctuation.separator.arguments.ruko
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(as)\b\s*
            name: keyword.operator.expression.as.ruko
          - match: (?<=[\w\s][(|])\.
            name: punctuation.definition.metadata.ruko
    patterns:
      - begin: |
          (?x)
          (?<= # literal
              (?: [\w'"`)}\]] | \\.) >* \s*
            | [^.]\.=?|[?!:]:=?
          )
          (\#?\()\s*
        end: \s*(\))
        name: meta.brace.round.ruko
        captures:
          1: {name: punctuation.definition.parameters.ruko}
        patterns:
          - include: '#types'
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \b
              (?: # destructuring keywords
                const|let|mut|dyn
                |va[rl]|use|given|state
                |case
              )
            \b
            (?:$|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \s*
          )
          (\#?\()\s*
        end: \s*(\))
        name: meta.brace.round.ruko
        captures:
          1: {name: punctuation.definition.binding-pattern.tuple.ruko}
        patterns:
          - include: '#punctuation'
          - include: '#types'
          - include: $self
      - begin: (\#\()\s*
        end: \s*(\))
        name: meta.brace.round.ruko
        captures:
          1: {name: punctuation.definition.tuple.ruko}
        patterns:
          - include: '#types'
          - include: $self
      - begin: (\()\s*
        end: \s*(\))
        name: meta.brace.round.ruko
        captures:
          1: {name: punctuation.definition.expression.ruko}
        patterns:
          - include: '#types'
          - include: $self

  type-square-brackets:
    repository:
      punctuation:
        patterns:
          - match: ','
            name: punctuation.separator.sequence.ruko
    patterns:
      - begin: |
          (?x)
          (?<= # literal
              (?: [\w'"`)}\]] | \\.) \s*
            | [^.]\.=?|[?!:]:=?
          )
          (\#?\[)\s*
        end: \s*(\])
        name: meta.brace.square.ruko
        captures:
          1: {name: punctuation.definition.attribute-selector.ruko}
        patterns:
          - include: '#types'
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \b
              (?: # destructuring keywords
                const|let|mut|dyn
                |va[rl]|use|given|state
                |case
              )
            \b
            (?:$|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \s*
          )
          (\#?\[)\s*
        end: \s*(\])
        name: meta.brace.square.ruko
        captures:
          1: {name: punctuation.definition.binding-pattern.array.ruko}
        patterns:
          - include: '#punctuation'
          - include: '#types'
          - include: $self
      - begin: (\#\[)\s*
        end: \s*(\])
        name: meta.brace.square.ruko
        captures:
          1: {name: punctuation.definition.sequence.ruko}
        patterns:
          - include: '#punctuation'
          - include: '#types'
          - include: $self
      - begin: (\[)\s*
        end: \s*(\])
        name: meta.brace.square.ruko
        captures:
          1: {name: punctuation.definition.array.ruko}
        patterns:
          - include: '#punctuation'
          - include: '#types'
          - include: $self

  type-keywords:
    patterns:
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(from)\b\s*
        name: storage.type.extends.ruko
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(for)\b\s*
        name: storage.type.implements.ruko
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(infer|as)\b\s*
        name: keyword.operator.expression.$1.ruko
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(is\s+not|is|has)\b\s*
        name: keyword.operator.expression.is.ruko
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b((inst|value|pair|type|name|size|key)of)\b\s*
        name: keyword.operator.expression.$1.ruko
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(instof)\b\s*
        name: keyword.operator.expression.instanceof.ruko
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(ext)\b\s*
        name: storage.type.extends.ruko
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(impl)\b\s*
        name: storage.type.implements.ruko

  type-operators:
    unused:
      - comment: Function types
        match: (?:^|\s+)(?:(\|)|(>))(?=['"`({\[\w])|(?<=['"`)}\]\w])(?:(\|)|(<))(?:$|\s+)
        captures:
          1: {name: keyword.operator.type.function.ruko}
          2: {name: keyword.operator.type.channel.ruko}
          3: {name: keyword.operator.type.function.ruko}
          4: {name: keyword.operator.type.channel.ruko}

    patterns:
      - &qualified-name-separators
        comment: Primary binary operators
        match: (?<=[)}\]\w])(?:(\?[.:>]=?)|(![.:>]=?)|((?:::|\.|->)=?))(?=[({\[\w])
        captures:
          1: {name: keyword.operator.optional.ruko}
          2: {name: keyword.operator.assert.ruko}
          3: {name: keyword.operator.accessor.ruko}
      - match: \s*(--?>|~~?>|==?>)
        name: keyword.operator.type.function.ruko
      - match: \s*(<--?|<~~?|<==?)
        name: keyword.operator.type.channel.ruko
      - comment: type unions
        match: (?<=^|[\s({\[])(\|)(?=$|[)}\]\s])|(?<=['"`)}\]\w]|\\.)(\|)(?=['"`({\[\w])
        captures:
          1: {name: keyword.operator.union.ruko}
          2: {name: keyword.operator.union.ruko}
      - comment: pointers
        match: (?<=^|[,;'"`({\[)}\]\w\s*&]|\\.)(\*)(?=['"`({\[\w*&])|(?<=['"`)}\]\w*&]|\\.)(\*)(?=$|[,;'"`({\[)}\]\w\s*&])|(?<=[(\[{*&]\s*)(\*)(?=\s*[*&)\]}])
        captures:
          1: {name: keyword.operator.pointer.ruko}
          2: {name: keyword.operator.pointer.ruko}
          3: {name: keyword.operator.pointer.ruko}
      - comment: references
        match: (?<=^|[,;'"`({\[)}\]\w\s*&]|\\.)(\&)(?=['"`({\[\w*&])|(?<=['"`)}\]\w*&]|\\.)(\&)(?=$|[,;'"`({\[)}\]\w\s*&])|(?<=[(\[{*&]\s*)(\&)(?=\s*[*&)\]}])
        captures:
          1: {name: keyword.operator.reference.ruko}
          2: {name: keyword.operator.reference.ruko}
          3: {name: keyword.operator.reference.ruko}
      - comment: type operators
        match: |
          (?x)
          (?<=^|[,;'"`({\[)}\]\w\s]|\\.)
            (?:
               (\+)|(\-)|(\*)|(\/)|(\%)|(\!)
              |(\?)|(\&)|(\^)|(\~)|(\$)|(\\)
              |(:[<>]|[<>]:)|(\#)
            )
          (?=$|[,;'"`({\[)}\]\w\s])
        captures:
          1: {name: keyword.operator.sum.ruko}
          2: {name: keyword.operator.difference.ruko}
          3: {name: keyword.operator.product.ruko}
          4: {name: keyword.operator.quotient.ruko}
          5: {name: keyword.operator.remainder.ruko}
          6: {name: keyword.operator.only.ruko}
          7: {name: keyword.operator.maybe.ruko}
          8: {name: keyword.operator.intersection.ruko}
          9: {name: keyword.operator.symmetric.ruko}
          10: {name: keyword.operator.negation.ruko}
          11: {name: keyword.operator.macro.dollar.ruko}
          12: {name: keyword.operator.successor.ruko}
          13: {name: keyword.operator.class.ruko}
          14: {name: keyword.operator.typeid.ruko}

  parameter-type-operators:
    patterns:
      - match: \&
        name: keyword.operator.reference.ruko
      - match: \b\?\B
        name: keyword.operator.spread.ruko
      - match: \*
        name: keyword.operator.pointer.ruko
      - match: \b\?\B
        name: keyword.operator.existential.ruko
      - match: \?
        name: keyword.operator.optional.ruko
      - match: \#
        name: keyword.operator.macro.ruko
      - match: \^
        name: keyword.operator.function.ruko
      - match: \@
        name: keyword.operator.decorator.ruko
      - match: \+
        name: keyword.operator.increment.ruko
      - match: \-
        name: keyword.operator.decrement.ruko
      - match: \\
        name: keyword.operator.escape.ruko
      - match: \%
        name: keyword.operator.format.ruko
      - match: \b\!\B
        name: keyword.operator.assert.ruko
      - match: \!
        name: keyword.operator.logical.ruko
      - match: \/
        name: keyword.operator.match.ruko
      - match: \.
        name: keyword.operator.accessor.ruko
      - match: \b\~\B
        name: keyword.operator.negation.ruko
      - match: \~
        name: keyword.operator.bitwise.ruko
      - match: \$
        name: keyword.operator.macro.dollar.ruko
      - match: \<|\>
        name: keyword.operator.channel.ruko
      - match: \=
        name: keyword.operator.match.ruko
      - match: '[\p{P}\p{S}&&[^,;''"`({\[|)}\]\p{Pc}]]*'
        name: keyword.operator.ruko

  # Literals and Constants

  literals:
    patterns:
      - include: '#regexps'
      - include: '#strings'
      - include: '#numbers'
      - include: '#constants'
      - include: '#strings-unquoted'

  constants:
    patterns:
      - match: |
          (?x)
          (?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b
          (?:
            (true|false) # boolean
            |(null|nan)
            |(undef) # undefined
            |(inf) # infinity
          )
          \b
        captures:
          1: {name: constant.language.boolean.$1.ruko}
          2: {name: constant.language.$2.ruko}
          3: {name: constant.language.undefined.ruko}
          4: {name: constant.language.infinity.ruko}
      - match: |
          (?x)
          (?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b
          (?:
            (it|this|super|self) # special arguments
            |(params) # arguments
            |(ctor) # constructor
            |(proto) # prototype
          )
          \b
        captures:
          1: {name: variable.language.$1.ruko}
          2: {name: variable.language.arguments.ruko}
          3: {name: variable.language.constructor.ruko}
          4: {name: variable.language.prototype.ruko}
      - match: |
          (?x)
          (?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b
          (
            console|document|window|global|process|require|module|exports
            |navigator|location|history|localStorage|sessionStorage
          )
          \b
        captures:
          1: {name: support.type.object.$1.ruko}

  # Numbers

  numbers:
    applyEndPatternLast: true
    begin: (?<!\.)(?=\d)
    end: \b
    name: meta.number.ruko
    patterns:
      - comment: hexadecimal integer literal
        name: constant.numeric.hexadecimal.ruko
        match: |
          (?ix) \b
            (0x) # prefix
            \h [\h_]* # integer part
            (\.)? # decimal point
            [\h_]* # fractional part
            (?: # exponent part
              (p) # delimiter
              ([+-])? # sign
              ([\d_]+) # mantissa
            )?
            ([\p{Pc}\p{L}]\w*)? # type suffix
          \b
        captures:
          1: {name: storage.type.numeric.ruko}
          2: {name: keyword.other.unit.ruko}
          3: {name: keyword.operator.expression.exponent.ruko}
          4: {name: keyword.operator.exponent.sign.ruko}
          5: {name: constant.numeric.decimal.exponent.mantissa.ruko}
          6: {name: keyword.other.unit.ruko}
      - comment: duodecimal integer literal
        name: constant.numeric.duodecimal.ruko
        match: |
          (?ix) \b
            (0z) # prefix
            [\d\u218a\u218babetx] [\d\u218a\u218babetx_]* # integer part
            (\.)? # decimal point
            [\d\u218a\u218babetx_]* # fractional part
            (?: # exponent part
              (p) # delimiter
              ([+-])? # sign
              ([\d_]+) # mantissa
            )?
            ([\p{Pc}\p{L}]\w*)? # type suffix
          \b
        captures:
          1: {name: storage.type.numeric.ruko}
          2: {name: keyword.other.unit.ruko}
          3: {name: keyword.operator.expression.exponent.ruko}
          4: {name: keyword.operator.exponent.sign.ruko}
          5: {name: constant.numeric.decimal.exponent.mantissa.ruko}
          6: {name: keyword.other.unit.ruko}
      - comment: octal integer literal
        name: constant.numeric.octal.ruko
        match: |
          (?ix) \b
            (0o) # prefix
            [0-7] [0-7_]* # integer part
            (\.)? # decimal point
            [0-7_]* # fractional part
            (?: # exponent part
              (p) # delimiter
              ([+-])? # sign
              ([\d_]+) # mantissa
            )?
            ([\p{Pc}\p{L}]\w*)? # type suffix
          \b
        captures:
          1: {name: storage.type.numeric.ruko}
          2: {name: keyword.other.unit.ruko}
          3: {name: keyword.operator.expression.exponent.ruko}
          4: {name: keyword.operator.exponent.sign.ruko}
          5: {name: constant.numeric.decimal.exponent.mantissa.ruko}
          6: {name: keyword.other.unit.ruko}
      - comment: binary integer literal
        name: constant.numeric.binary.ruko
        match: |
          (?ix) \b
            (0b) # prefix
            [01] [01_]* # integer part
            (\.)? # decimal point
            [01_]* # fractional part
            (?: # exponent part
              (p) # delimiter
              ([+-])? # sign
              ([\d_]+) # mantissa
            )?
            ([\p{Pc}\p{L}]\w*)? # type suffix
          \b
        captures:
          1: {name: storage.type.numeric.ruko}
          2: {name: keyword.other.unit.ruko}
          3: {name: keyword.operator.expression.exponent.ruko}
          4: {name: keyword.operator.exponent.sign.ruko}
          5: {name: constant.numeric.decimal.exponent.mantissa.ruko}
          6: {name: keyword.other.unit.ruko}
      - comment: quaternary integer literal
        name: constant.numeric.quaternary.ruko
        match: |
          (?ix) \b
            (0q) # prefix
            [0-3] [0-3_]* # integer part
            (\.)? # decimal point
            [0-3_]* # fractional part
            (?: # exponent part
              (p) # delimiter
              ([+-])? # sign
              ([\d_]+) # mantissa
            )?
            ([\p{Pc}\p{L}]\w*)? # type suffix
          \b
        captures:
          1: {name: storage.type.numeric.ruko}
          2: {name: keyword.other.unit.ruko}
          3: {name: keyword.operator.expression.exponent.ruko}
          4: {name: keyword.operator.exponent.sign.ruko}
          5: {name: constant.numeric.decimal.exponent.mantissa.ruko}
          6: {name: keyword.other.unit.ruko}
      - comment: senary integer literal
        name: constant.numeric.senary.ruko
        match: |
          (?ix) \b
            (0s) # prefix
            [0-5] [0-5_]* # integer part
            (\.)? # decimal point
            [0-5_]* # fractional part
            (?: # exponent part
              (p) # delimiter
              ([+-])? # sign
              ([\d_]+) # mantissa
            )?
            ([\p{Pc}\p{L}]\w*)? # type suffix
          \b
        captures:
          1: {name: storage.type.numeric.ruko}
          2: {name: keyword.other.unit.ruko}
          3: {name: keyword.operator.expression.exponent.ruko}
          4: {name: keyword.operator.exponent.sign.ruko}
          5: {name: constant.numeric.decimal.exponent.mantissa.ruko}
          6: {name: keyword.other.unit.ruko}
      - comment: decimal (no prefix)
        name: constant.numeric.decimal.ruko
        match: |
          (?ix) \b
            () # prefix
            \d [\d_]* # integer part
            (\.)? # decimal point
            [\d_]* # fractional part
            (?: # exponent part
              (e) # delimiter
              ([+-])? # sign
              ([\d_]+) # mantissa
            )?
            ([\p{Pc}\p{L}]\w*)? # type suffix
          \b
        captures:
          1: {name: storage.type.numeric.ruko}
          2: {name: keyword.other.unit.ruko}
          3: {name: keyword.operator.expression.exponent.ruko}
          4: {name: keyword.operator.exponent.sign.ruko}
          5: {name: constant.numeric.decimal.exponent.mantissa.ruko}
          6: {name: keyword.other.unit.ruko}

  # Symbols

  decorators:
    applyEndPatternLast: true
    begin: (?<=^|\\.|['"`({\[)}\]\s]|(?:[)}\]\w\s'"`]|\\.)\s*[:=])(\@)(?=[\p{Pc}\p{L}])
    end: (?=)|$
    name: entity.name.decorator.ruko
    captures:
      1: {name: punctuation.definition.decorator.ruko}
      2: {name: entity.name.decorator.ruko}
    patterns:
      - include: '#function-calls'
      - include: '#sigil-function-calls'
      - match: '[?!:]:|[?!]?\.'
        name: punctuation.separator.namespace.ruko
      - include: '#brackets'
      - include: '#strings'
      - include: '#variables'

  symbols:
    patterns:
      - comment: quoted symbol
        applyEndPatternLast: true
        begin: (?<=^|\\.|['"`({\[)}\]\s]|(?:[)}\]\w\s'"`]|\\.)\s*[:=])(:)(?=[`'"])
        end: (?=)|$
        name: constant.language.symbol-type.ruko
        captures:
          1: {name: punctuation.definition.symbol.ruko}
        patterns:
          - include: '#strings-single-quoted'
          - include: '#strings-double-quoted'
          - include: '#strings-unquoted'
      - match: (?<=^|\\.|['"`({\[)}\]\s]|(?:[)}\]\w\s'"`]|\\.)\s*[:=])(:)(\b[\p{Pc}\p{L}]\w*\b)
        name: constant.other.symbol.ruko
        captures:
          1: {name: punctuation.definition.symbol.ruko}
          2: {name: constant.other.symbol.ruko}
        patterns:
          - include: '#string-escapes'

  strings-unquoted:
    comment: Unquoted string
    applyEndPatternLast: true
    begin: (`)
    end: (?=\W)|$
    name: string.template.ruko
    captures:
      1: {name: punctuation.definition.string.ruko}
    patterns:
      - match: \b\p{Pd}+\b
      - include: '#string-escapes'

  strings:
    patterns:
      - comment: multi- single-quoted verbatim, interpolated, format, and template string
        begin: \s*([\\\$%#]+)('''+)\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - match: '''''|\$\$|%%|##'
            name: constant.character.escape.ruko
          - include: '#embedded-expression'
          - include: '#embedded-format'
          - include: '#embedded-placeholder'
      - comment: multi- double-quoted verbatim, interpolated, format, and template string
        begin: \s*([\\\$%#]+)("""+)\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - match: "\"\"|\\$\\$|%%|##"
            name: constant.character.escape.ruko
          - include: '#embedded-expression'
          - include: '#embedded-format'
          - include: '#embedded-placeholder'
      - comment: single-quoted verbatim, interpolated, format, and template string
        begin: \s*([\\\$%#]+)(')\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - match: '''''|\$\$|%%|##'
            name: constant.character.escape.ruko
          - include: '#embedded-expression'
          - include: '#embedded-format'
          - include: '#embedded-placeholder'
      - comment: double-quoted verbatim, interpolated, format, and template string
        begin: \s*([\\\$%#]+)(")\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - match: "\"\"|\\$\\$|%%|##"
            name: constant.character.escape.ruko
          - include: '#embedded-expression'
          - include: '#embedded-format'
          - include: '#embedded-placeholder'
      - comment: multi- single-quoted verbatim, interpolated, and format string
        begin: \s*([\\\$%]+)('''+)\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - match: '''''|\$\$|%%'
            name: constant.character.escape.ruko
          - include: '#embedded-expression'
          - include: '#embedded-format'
      - comment: multi- double-quoted verbatim, interpolated, and format string
        begin: \s*([\\\$%]+)("""+)\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - match: "\"\"|\\$\\$|%%"
            name: constant.character.escape.ruko
          - include: '#embedded-expression'
          - include: '#embedded-format'
      - comment: single-quoted verbatim, interpolated, and format string
        begin: \s*([\\\$%]+)(')\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - match: '''''|\$\$|%%'
            name: constant.character.escape.ruko
          - include: '#embedded-expression'
          - include: '#embedded-format'
      - comment: double-quoted verbatim, interpolated, and format string
        begin: \s*([\\\$%]+)(")\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - match: "\"\"|\\$\\$|%%"
            name: constant.character.escape.ruko
          - include: '#embedded-expression'
          - include: '#embedded-format'
      - comment: multi- single-quoted verbatim, interpolated, and template string
        begin: \s*([\\\$#]+)('''+)\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - match: '''''|\$\$|##'
            name: constant.character.escape.ruko
          - include: '#embedded-expression'
          - include: '#embedded-placeholder'
      - comment: multi- double-quoted verbatim, interpolated, and template string
        begin: \s*([\\\$#]+)("""+)\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - match: "\"\"|\\$\\$|##"
            name: constant.character.escape.ruko
          - include: '#embedded-expression'
          - include: '#embedded-placeholder'
      - comment: single-quoted verbatim, interpolated, and template string
        begin: \s*([\\\$#]+)(')\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - match: '''''|\$\$|##'
            name: constant.character.escape.ruko
          - include: '#embedded-expression'
          - include: '#embedded-placeholder'
      - comment: double-quoted verbatim, interpolated, and template string
        begin: \s*([\\\$#]+)(")\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - match: "\"\"|\\$\\$|##"
            name: constant.character.escape.ruko
          - include: '#embedded-expression'
          - include: '#embedded-placeholder'
      - comment: multi- single-quoted verbatim, format, and template string
        begin: \s*([\\%#]+)('''+)\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - match: "''|%%|##"
            name: constant.character.escape.ruko
          - include: '#embedded-format'
          - include: '#embedded-placeholder'
      - comment: multi- double-quoted verbatim, format, and template string
        begin: \s*([\\%#]+)("""+)\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - match: '""|%%|##'
            name: constant.character.escape.ruko
          - include: '#embedded-format'
          - include: '#embedded-placeholder'
      - comment: single-quoted verbatim, format, and template string
        begin: \s*([\\%#]+)(')\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - match: "''|%%|##"
            name: constant.character.escape.ruko
          - include: '#embedded-format'
          - include: '#embedded-placeholder'
      - comment: double-quoted verbatim, format, and template string
        begin: \s*([\\%#]+)(")\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - match: '""|%%|##'
            name: constant.character.escape.ruko
          - include: '#embedded-format'
          - include: '#embedded-placeholder'
      - comment: multi- single-quoted interpolated, format, and template string
        begin: \s*([\$%#]+)('''+)\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expression'
          - include: '#embedded-format'
          - include: '#embedded-placeholder'
      - comment: multi- double-quoted interpolated, format, and template string
        begin: \s*([\$%#]+)("""+)\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expression'
          - include: '#embedded-format'
          - include: '#embedded-placeholder'
      - comment: single-quoted interpolated, format, and template string
        begin: \s*([\$%#]+)(')\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expression'
          - include: '#embedded-format'
          - include: '#embedded-placeholder'
      - comment: double-quoted interpolated, format, and template string
        begin: \s*([\$%#]+)(")\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expression'
          - include: '#embedded-format'
          - include: '#embedded-placeholder'
      - comment: multi- single-quoted verbatim and interpolated string
        begin: \s*([\\\$]+)('''+)\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - match: '''''|\$\$'
            name: constant.character.escape.ruko
          - include: '#embedded-expression'
      - comment: multi- double-quoted verbatim and interpolated string
        begin: \s*([\\\$]+)("""+)\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - match: "\"\"|\\$\\$"
            name: constant.character.escape.ruko
          - include: '#embedded-expression'
      - comment: single-quoted verbatim and interpolated string
        begin: \s*([\\\$]+)(')\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - match: '''''|\$\$'
            name: constant.character.escape.ruko
          - include: '#embedded-expression'
      - comment: double-quoted verbatim and interpolated string
        begin: \s*([\\\$]+)(")\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - match: "\"\"|\\$\\$"
            name: constant.character.escape.ruko
          - include: '#embedded-expression'
      - comment: multi- single-quoted verbatim and format string
        begin: \s*([\\%]+)('''+)\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - match: "''|%%"
            name: constant.character.escape.ruko
          - include: '#embedded-format'
      - comment: multi- double-quoted verbatim and format string
        begin: \s*([\\%]+)("""+)\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - match: '""|%%'
            name: constant.character.escape.ruko
          - include: '#embedded-format'
      - comment: single-quoted verbatim and format string
        begin: \s*([\\%]+)(')\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - match: "''|%%"
            name: constant.character.escape.ruko
          - include: '#embedded-format'
      - comment: double-quoted verbatim and format string
        begin: \s*([\\%]+)(")\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - match: '""|%%'
            name: constant.character.escape.ruko
          - include: '#embedded-format'
      - comment: multi- single-quoted interpolated and format string
        begin: \s*([\$%]+)('''+)\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expression'
          - include: '#embedded-format'
      - comment: multi- double-quoted interpolated and format string
        begin: \s*([\$%]+)("""+)\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expression'
          - include: '#embedded-format'
      - comment: single-quoted interpolated and format string
        begin: \s*([\$%]+)(')\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expression'
          - include: '#embedded-format'
      - comment: double-quoted interpolated and format string
        begin: \s*([\$%]+)(")\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expression'
          - include: '#embedded-format'
      - comment: multi- single-quoted verbatim and template string
        begin: \s*([\\#]+)('''+)\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - match: "''|##"
            name: constant.character.escape.ruko
          - include: '#embedded-placeholder'
      - comment: multi- double-quoted verbatim and template string
        begin: \s*([\\#]+)("""+)\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - match: '""|##'
            name: constant.character.escape.ruko
          - include: '#embedded-placeholder'
      - comment: single-quoted verbatim and template string
        begin: \s*([\\#]+)(')\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - match: "''|##"
            name: constant.character.escape.ruko
          - include: '#embedded-placeholder'
      - comment: double-quoted verbatim and template string
        begin: \s*([\\#]+)(")\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - match: '""|##'
            name: constant.character.escape.ruko
          - include: '#embedded-placeholder'
      - comment: multi- single-quoted interpolated and template string
        begin: \s*([\$#]+)('''+)\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expression'
          - include: '#embedded-placeholder'
      - comment: multi- double-quoted interpolated and template string
        begin: \s*([\$#]+)("""+)\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expression'
          - include: '#embedded-placeholder'
      - comment: single-quoted interpolated and template string
        begin: \s*([\$#]+)(')\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expression'
          - include: '#embedded-placeholder'
      - comment: double-quoted interpolated and template string
        begin: \s*([\$#]+)(")\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expression'
          - include: '#embedded-placeholder'
      - comment: multi- single-quoted format and template string
        begin: \s*([%#]+)('''+)\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-format'
          - include: '#embedded-placeholder'
      - comment: multi- double-quoted format and template string
        begin: \s*([%#]+)("""+)\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-format'
          - include: '#embedded-placeholder'
      - comment: single-quoted format and template string
        begin: \s*([%#]+)(')\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-format'
          - include: '#embedded-placeholder'
      - comment: double-quoted format and template string
        begin: \s*([%#]+)(")\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-format'
          - include: '#embedded-placeholder'
      - comment: multi- single-quoted verbatim string
        begin: \s*(\\)('''+)\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - match: "''"
            name: constant.character.escape.ruko
      - comment: multi- double-quoted verbatim string
        begin: \s*(\\)("""+)\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - match: '""'
            name: constant.character.escape.ruko
      - comment: single-quoted verbatim string
        begin: \s*(\\)(')\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - match: "''"
            name: constant.character.escape.ruko
      - comment: double-quoted verbatim string
        begin: \s*(\\)(")\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - match: '""'
            name: constant.character.escape.ruko
      - comment: multi- single-quoted interpolated string
        begin: \s*(\$)('''+)\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expression'
      - comment: multi- double-quoted interpolated string
        begin: \s*(\$)("""+)\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expression'
      - comment: single-quoted interpolated string
        begin: \s*(\$)(')\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expression'
      - comment: double-quoted interpolated string
        begin: \s*(\$)(")\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expression'
      - comment: multi- single-quoted format string
        begin: \s*(%)('''+)\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-format'
      - comment: multi- double-quoted format string
        begin: \s*(%)("""+)\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-format'
      - comment: single-quoted format string
        begin: \s*(%)(')\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-format'
      - comment: double-quoted format string
        begin: \s*(%)(")\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-format'
      - comment: multi- single-quoted template string
        begin: \s*(#)('''+)\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-placeholder'
      - comment: multi- double-quoted template string
        begin: \s*(#)("""+)\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-placeholder'
      - comment: single-quoted template string
        begin: \s*(#)(')\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-placeholder'
      - comment: double-quoted template string
        begin: \s*(#)(")\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-placeholder'
      - comment: multi- single-quoted plain string
        begin: \s*()('''+)\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - include: '#string-escapes'
      - comment: multi- double-quoted plain string
        begin: \s*()("""+)\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - include: '#string-escapes'
      - comment: single-quoted plain string
        begin: \s*()(')\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - include: '#string-escapes'
      - comment: double-quoted plain string
        begin: \s*()(")\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - include: '#string-escapes'

  string-content:
    patterns:
      - include: '#string-escapes'
      - include: '#embedded'

  string-escapes:
    patterns:
      - begin: (\\)(?=\s*$)
        end: ^\s*(?=\S)
        captures:
          1: {name: constant.character.escape.newline.ruko}
      - include: '#named-escapes'
      - include: '#numeric-escapes'
      - match: \\([cm][a-z])
        name: constant.character.control.ruko
      - match: \\[abefprnstv]
        name: constant.character.escape.ruko
      - match: \\\p{S}
        name: constant.character.escape.symbol.ruko
      - match: \\\p{P}
        name: constant.character.escape.punctuation.ruko
      - match: \\[a-zA-Z\p{C}]
        name: invalid.illegal.escape.ruko
      - match: \\\s
        name: constant.character.escape.space.ruko
      - match: \\\p{L}
        name: constant.character.escape.letter.ruko
      - match: \\\p{N}
        name: constant.character.escape.number.ruko
      - match: \\.
        name: constant.character.escape.other.ruko

  named-characters:
    name: string.unquoted.plain.in.ruko
    comment: Grammar for the Unicode Named Character Mini-Language.
    patterns:
      - applyEndPatternLast: true
        name: constant.other.function.ruko
        begin: \b([\p{Pc}\p{L}]\w*\b([:.][\p{Pc}\p{L}]\w*)*)\b(?=\{)
        beginCaptures:
          1: {patterns: [include: '#function-namespace']}
        end: (?=)|$
        patterns:
          - begin: (\{)
            end: (\})
            captures:
              1: {name: constant.other.function.ruko}
            patterns:
              - include: '#named-characters'
      - match: \b([\p{Pc}\p{L}]\w*\b([:.][\p{Pc}\p{L}]\w*)*)\b([;,]|(?=\W))
        name: constant.character.escape.ruko
        captures:
          1: {patterns: [include: '#character-namespace']}
      - include: '#string-content'
      - include: '#punctuation'
      - include: '#illegal'

  function-namespace:
    patterns:
      - match: ([\p{Pc}\p{L}]\w*)\b(?=[.:])
        name: support entity.name.tag.namespace.ruko
      - match: ([\p{Pc}\p{L}]\w*)\b
        name: support entity.name.function.member.ruko

  character-namespace:
    patterns:
      - match: ([\p{Pc}\p{L}]\w*)\b(?=[.:])
        name: constant.other.character-class.ruko
      - match: ([\p{Pc}\p{L}]\w*)\b
        name: constant.character.escape.unicode.ruko

  named-escapes:
    patterns:
      - applyEndPatternLast: true
        name: constant.other.function.ruko
        begin: \\j([\p{Pc}\p{L}]\w*\b([:.][\p{Pc}\p{L}]\w*)*)\b(?=\{)
        beginCaptures:
          1: {patterns: [include: '#function-namespace']}
        end: (?=)|$
        patterns:
          - begin: (\{)
            end: (\})
            captures:
              1: {name: constant.other.function.ruko}
            patterns:
              - include: '#named-characters'
      - match: \\j([\p{Pc}\p{L}]\w*\b([:.][\p{Pc}\p{L}]\w*)*)\b([;,]|(?=\W))
        name: constant.character.escape.ruko
        captures:
          1: {patterns: [include: '#character-namespace']}
      - begin: \\j{\s*
        end: \s*}
        name: constant.other.character-class.unicode.ruko
        patterns:
          - applyEndPatternLast: true
            name: constant.other.function.ruko
            begin: \b([\p{Pc}\p{L}]\w*\b([:.][\p{Pc}\p{L}]\w*)*)\b(?=\{)
            beginCaptures:
              1: {patterns: [include: '#function-namespace']}
            end: (?=)|$
            patterns:
              - begin: (\{)
                end: (\})
                captures:
                  1: {name: constant.other.function.ruko}
                patterns:
                  - include: '#named-characters'
          - match: \b([\p{Pc}\p{L}]\w*\b([:.][\p{Pc}\p{L}]\w*)*)\b([;,]|(?=\W))
            name: constant.character.escape.ruko
            captures:
              1: {patterns: [include: '#character-namespace']}
          - include: '#string-content'
          - include: '#punctuation'
          - include: '#illegal'

  numeric-escapes:
    comments: |
      Hexadecimal escapes \u encode UTF-16 and 32
      while \x encodes UTF-8 code points in addition
      to Unicode characters.
    patterns:
      - comment: Binary escape sequences (0 to 417777)
        match: |
          (?x)
          \\b # prefix
            0* # leading zeroes
          (?: # numbers leading to 0001 0000 1111 1111 1111 1111
              10000[01]{16}
            | [01]{1,20}
          )
            (?![01])
        name: constant.character.escape.binary.ruko
      - comment: Decimal escape sequences
        match: |
          (?x)
          \\b # prefix
            [01]+
            (?![01])
        name: invalid.illegal.escape.binary.ruko
      - begin: \\b{
        end: \s*}
        name: constant.character.escape.binary.ruko
        patterns:
          - include: '#punctuation'
          - match: |
              (?x)
                \b
              0* # leading zeroes
              (?: # numbers leading to 0001 0000 1111 1111 1111 1111
                  10000[01]{16}
                | [01]{1,20}
              )
                (?![01])
            name: constant.character.escape.binary.ruko
          - include: '#illegal'

      - comment: Quaternary escape sequences (0 to 10033333)
        match: |
          (?x)
          \\q # prefix
            0* # leading zeroes
          (?: # numbers leading to 0001 0000 1111 1111 1111 1111 (in quaternary)
              100[0-3]{8}
            | [1-3][0-3]{1,9}
            | [0-3]
          )
            (?![0-3])
        name: constant.character.escape.quaternary.ruko
      - comment: Invalid quaternary escape sequences
        match: |
          (?x)
          \\q # prefix
            [0-3]+
            (?![0-3])
        name: invalid.illegal.escape.quaternary.ruko
      - begin: \\q{
        end: \s*}
        name: constant.character.escape.quaternary.ruko
        patterns:
          - include: '#punctuation'
          - match: |
              (?x)
                \b
              0* # leading zeroes
              (?: # numbers leading to 0001 0000 1111 1111 1111 1111 (in quaternary)
                  100[0-3]{8}
                | [1-3][0-3]{1,9}
                | [0-3]
              )
                (?![0-3])
            name: constant.character.escape.quaternary.ruko
          - include: '#illegal'

      - comment: Senary escape sequences (0 to 1223043)
        match: |
          (?x)
          \\s # prefix
            0* # leading zeroes
          (?: # numbers leading to 0001 0000 1111 1111 1111 1111 (in senary)
              122304[0-3]
            | 12230[0-3][0-5]
            | 1223[0][0-5]{2}
            | 122[0-2][0-5]{3}
            | 12[0-1][0-5]{4}
            | 1[0-1][0-5]{5}
            | [1-5][0-5]{1,6}
            | [0-5]
          )
            (?![0-5])
        name: constant.character.escape.senary.ruko
      - comment: Invalid senary escape sequences
        match: |
          (?x)
          \\s # prefix
            [0-5]+
            (?![0-5])
        name: invalid.illegal.escape.senary.ruko
      - begin: \\s{
        end: \s*}
        name: constant.character.escape.senary.ruko
        patterns:
          - include: '#punctuation'
          - match: |
              (?x)
                \b
              0* # leading zeroes
              (?: # numbers leading to 0001 0000 1111 1111 1111 1111 (in senary)
                  122304[0-3]
                | 12230[0-3][0-5]
                | 1223[0][0-5]{2}
                | 122[0-2][0-5]{3}
                | 12[0-1][0-5]{4}
                | 1[0-1][0-5]{5}
                | [1-5][0-5]{1,6}
                | [0-5]
              )
                (?![0-5])
            name: constant.character.escape.senary.ruko
          - include: '#illegal'

      - comment: Octal escape sequences (0 to 4177777)
        match: |
          (?x)
          \\o # prefix
            0* # leading zeroes
          (?: # numbers leading to 4177777
              4[01][0-7]{4}
            | [1-3][0-7]{5}
            | [1-7][0-7]{1,4}
            | [0-7]
          )
            (?![0-7])
        name: constant.character.escape.octal.ruko
      - comment: Octal escape sequences
        match: |
          (?x)
          \\o # prefix
            [0-7]+
            (?![0-7])
        name: invalid.illegal.escape.octal.ruko
      - begin: \\o{
        end: \s*}
        name: constant.character.escape.octal.ruko
        patterns:
          - include: '#punctuation'
          - match: |
              (?x)
                \b
              0* # leading zeroes
              ( # numbers up to 4177777
                  4[01][0-7]{4}
                | [1-3][0-7]{5}
                | [1-7][0-7]{1,4}
                | [0-7]
              )
                (?![0-7])
            name: constant.character.escape.octal.ruko
          - include: '#illegal'

      - comment: Duodecimal escapes (0 to 4588A7)
        match: |
          (?x)
          \\z # prefix
            0* # leading zeroes
          (?i: # numbers leading to 4588A7
              4588 [\u218aatx] [0-7]
            | 4588 \d          [\d\u218a\u218babetx]
            | 458  [0-7]       [\d\u218a\u218babetx]{2}
            | 45   [0-7]       [\d\u218a\u218babetx]{3}
            | 4    [0-4]       [\d\u218a\u218babetx]{4}
            | [1-3]            [\d\u218a\u218babetx]{5}
            | [\d\u218a\u218babetx]{1,5}
          )
            (?![\d\u218a\u218babetx])
        name: constant.character.escape.duodecimal.ruko
      - comment: Duodecimal escape sequences
        match: |
          (?x)
          \\z # prefix
            [\d\u218a\u218babetx]+
            (?![\d\u218a\u218babetx])
        name: invalid.illegal.escape.duodecimal.ruko
      - begin: \\z{
        end: \s*}
        name: constant.character.escape.duodecimal.ruko
        patterns:
          - include: '#punctuation'
          - match: |
              (?x)
                \b
              0* # leading zeroes
              (?i: # numbers up to 4588A7
                  4588 [\u218aatx] [0-7]
                | 4588 \d          [\d\u218a\u218babetx]
                | 458  [0-7]       [\d\u218a\u218babetx]{2}
                | 45   [0-7]       [\d\u218a\u218babetx]{3}
                | 4    [0-4]       [\d\u218a\u218babetx]{4}
                | [1-3]            [\d\u218a\u218babetx]{5}
                | [\d\u218a\u218babetx]{1,5}
              )
                (?![\d\u218a\u218babetx])
            name: constant.character.escape.duodecimal.ruko
          - include: '#illegal'

      - comment: Decimal escapes (0 to 1114111)
        match: |
          (?x)
          \\d? # prefix
            0* # leading zeroes
          (?: # numbers up to 1114111
              111411    [01]
            | 111410    \d
            | 11140     \d{2}
            | 111 [0-3] \d{3}
            | 110       \d{4}
            | 10        \d{5}
            | [1-9]     \d{1,5}
            | \d
          )
            (?!\d)
        name: constant.character.escape.decimal.ruko
      - comment: Decimal escape sequences
        match: |
          (?x)
          \\d? # prefix
            \d+
            (?!\d)
        name: invalid.illegal.escape.decimal.ruko
      - begin: \\d{
        end: \s*}
        name: constant.character.escape.decimal.ruko
        patterns:
          - include: '#punctuation'
          - match: |
              (?x)
                \b
              0* # leading zeroes
              (?: # numbers up to 1114111
                    111411    [01]
                  | 111410    \d
                  | 11140     \d{2}
                  | 111 [0-3] \d{3}
                  | 110       \d{4}
                  | 10        \d{5}
                  | [1-9]     \d{1,5}
                  | \d
              )
                (?!\d)
            name: constant.character.escape.decimal.ruko
          - include: '#illegal'

      - comment: Trailing byte pair U+80-U+BF
        match: |
          (?x)
            \\x # prefix
          (?i:
            0* # leading zeroes
            [89ab]\h
          )
            (?!\h)
        name: constant.character.escape.trailing.ruko
      - comment: Leading byte pair U+C0-U+FF
        match: |
          (?x)
            \\x # prefix
          (?i:
            0* # leading zeroes
            (?: # C0 to FF
                [c-f]\h
            )
          )
            (?!\h)
        name: constant.character.escape.leading.ruko
      - comment: Hexadecimal escape sequences
        match: |
          (?x)
            \\x # prefix
          (?i:
            0* # leading zeroes
            (?: # 0 to 10FFFF
                10\h{4}
              | [1-9a-f]\h{1,4}
              | \h
            )
          )
            (?!\h)
        name: constant.character.escape.hexadecimal.ruko
      - comment: Hexadecimal escape sequences
        match: |
          (?x)
          \\x # prefix
            \h+
            (?!\h)
        name: invalid.illegal.escape.hexadecimal.ruko
      - begin: \\x{
        end: \s*}
        name: constant.character.escape.hexadecimal.ruko
        patterns:
          - include: '#punctuation'
          - comment: Trailing byte pair U+80-U+BF
            match: |
              (?x)
                \b
              (?i:
                0* # leading zeroes
                [89ab]\h # 80 to BF
              )
                (?!\h)
            name: constant.character.escape.trailing.ruko
          - comment: Leading byte pair U+C0-U+FF
            match: |
              (?x)
                \b # prefix
              (?i:
                0* # leading zeroes
                (?: # C0 to FF
                    [c-f]\h
                )
              )
              (?!\h)
            name: constant.character.escape.leading.ruko
          - match: |
              (?x)
                \b
              (?i:
                0* # leading zeroes
                (?: # 0 to 10FFFF
                    10\h{4}
                  | [1-9a-f]\h{1,4}
                  | \h
                )
              )
                (?!\h)
            name: constant.character.escape.hexadecimal.ruko
          - include: '#illegal'

      - comment: Low surrogate pairs U+DC00-DFFF
        match: |
          (?x)
            \\u # prefix
          (?i:
            0* # leading zeroes
            d[c-f] \h{2}
          )
            (?!\h)
        name: constant.character.escape.surrogate.low.ruko
      - comment: High surrogate pairs U+D800-DBFF
        match: |
          (?x)
            \\u # prefix
          (?i:
            0* # leading zeroes
            d[89ab] \h{2}
          )
            (?!\h)
        name: constant.character.escape.surrogate.high.ruko
      - comment: Hexadecimal escape sequences
        match: |
          (?x)
            \\u # prefix
          (?i:
            0* # leading zeroes
            (?: # 0 to 10FFFF
                10\h{4}
              | [1-9a-f]\h{1,4}
              | \h
            )
          )
            (?!\h)
        name: constant.character.escape.unicode.ruko
      - comment: Unicode escape sequences
        match: |
          (?x)
          \\u # prefix
            \h+
            (?!\h)
        name: invalid.illegal.escape.unicode.ruko
      - comment: Unicode escape sequences
        match: |
          (?x)
            \\u # prefix
          (?i:
            0* # leading zeroes
            (?: # 0 to 10FFFF
                10\h{4}
              | [1-9a-f]\h{1,4}
              | \h
            )
            (?!\h)
          )
        name: constant.character.escape.unicode.ruko
      - comment: Unicode escapes
        begin: \\u{
        end: \s*}
        name: constant.character.escape.unicode.ruko
        patterns:
          - include: '#punctuation'
          - match: |
              (?x)
                \b
              (?i:
                0* # leading zeroes
                d [c-f] \h{2}
              )
                (?!\h)
            name: constant.character.escape.surrogate.low.ruko
          - match: |
              (?x)
                \b
              (?i:
                0* # leading zeroes
                d [89ab] \h{2}
              )
                (?!\h)
            name: constant.character.escape.surrogate.high.ruko
          - match: |
              (?x)
                \b
              (?i:
                0* # leading zeroes
                (?: # 0 to 10FFFF
                    10\h{4}
                  | [1-9a-f]\h{1,4}
                  | \h
                )
              )
                (?!\h)
            name: constant.character.escape.unicode.ruko
          - include: '#illegal'

  # Embedded expressions

  embedded:
    patterns:
      - include: '#embedded-expression'
      - include: '#embedded-format'
      - include: '#embedded-placeholder'

  embedded-verbatim:
    patterns:
      - match: \#\#|\$\$|\%\%
        name: constant.character.escape.ruko
      - include: '#embedded-expression'
      - include: '#embedded-format'
      - include: '#embedded-placeholder'

  embedded-expression:
    patterns:
      - comment: Interpolated expression
        begin: (\${)\s*
        end: \s*(})
        name: meta.embedded.expression.ruko
        captures:
          1: {name: punctuation.definition.variable.ruko}
        patterns:
          - include: $self
      - comment: Interpolated expression
        applyEndPatternLast: true
        name: meta.embedded.expression.ruko
        begin: |
          (?x)
          (\$) # beginning of identifier
          # ignore all keywords
          (?!
            (?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b
            (?: # keywords
              [io]n|of|[ai]s|has|old|new|del
              |unset|ref|and|x?or|not
              |const|let|mut|dyn
              |va[rl]|use|given|state
              |func|proc|prop|type|class|actor
              |impl|enum|module|struct|record
              |union|iter|macro|query|elem|temp
              |object|realm|trait|style|script|quote
              |go|defer|do|with|from|where
              |if|else|then|guard|when
              |for|loop|while|goto|move
              |try|throw|catch|switch
              |match|case|pass|def
              |break|skip|redo|retry
              |return|yield|await|scope
              |import|export|intern|extern
              |debug|assert|check|decl
            )
            \b
          )
          (?=[\p{Pc}\p{L}]) # next to a word
        end: (?=)|$
        captures:
          1: {name: punctuation.definition.variable.ruko}
        patterns:
          - include: '#constants'
          - include: '#generics'
          - include: '#brackets'
          - include: '#embedded-function-calls'
          - match: (?<=>|\w)(!)(?=#?[({])
            captures:
              1: {name: keyword.operator.macro.ruko}
          - include: '#variables'
          - include: '#numbers'
          - *qualified-name-separators

  interpolated-code:
    patterns:
      - comment: Interpolated expression
        begin: (\#{)\s*
        end: \s*(})
        name: meta.embedded.expression.ruko
        captures:
          1: {name: punctuation.definition.variable.ruko}
        patterns:
          - include: $self
      - comment: Interpolated expression
        applyEndPatternLast: true
        name: meta.embedded.expression.ruko
        begin: |
          (?x)
          (\#) # beginning of identifier
          # ignore all keywords
          (?!
            (?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b
            (?: # keywords
              [io]n|of|[ai]s|has|old|new|del
              |unset|ref|and|x?or|not
              |const|let|mut|dyn
              |va[rl]|use|given|state
              |func|proc|prop|type|class|actor
              |impl|enum|module|struct|record
              |union|iter|macro|query|elem|temp
              |object|realm|trait|style|script|quote
              |go|defer|do|with|from|where
              |if|else|then|guard|when
              |for|loop|while|goto|move
              |try|throw|catch|switch
              |match|case|pass|def
              |break|skip|redo|retry
              |return|yield|await|scope
              |import|export|intern|extern
              |debug|assert|check|decl
            )
            \b
          )
          (?=[\p{Pc}\p{L}]) # next to a word
        end: (?=)|$
        captures:
          1: {name: punctuation.definition.variable.ruko}
        patterns:
          - include: '#constants'
          - include: '#generics'
          - include: '#brackets'
          - include: '#embedded-function-calls'
          - include: '#variables'
          - include: '#numbers'
          - *qualified-name-separators

  embedded-placeholder:
    patterns:
      - name: meta.embedded.placeholder.ruko
        match: |
          (?x)
          (\#) # sigil
          (
            (?:
              (?:&|%|\$|~~?|\*\*?)? # sigil
              [!?]? # required or optional
            )?
            [+-]? \d+ # start of range
            (?:
              (?:[>.]\.[.<]|\.\.|[=.]\.[.=]|\.\.=?|=\.=) # range operator
              [+-]? \d+ # end of range
              (?:
                \.{1,3}
                [+-]? \d+ # increment
              )?
            )?
          )
        captures:
          1: {name: punctuation.definition.anchor.ruko}
          2:
            name: constant.numeric.decimal.ruko
            patterns:
              - match: '[+-]'
                name: keyword.operator.arithmetic.ruko
              - match: (?:[>.]\.[.<]|\.\.|[=.]\.[.=]|\.\.=?|=\.=)
                name: keyword.operator.range.ruko
      - name: meta.embedded.placeholder.ruko
        match: |
          (?x)
          (\#) # sigil
          (
            (?:
              (?:&|%|\$|~~?|\*\*?) # sigil
              [!?]? # required or optional
            )
            \b
              [\p{Pc}\p{L}]\w*
            \b
            |
            # ignore all keywords
            (?!
              (?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b
              (?: # keywords
                [io]n|of|[ai]s|has|old|new|del
                |unset|ref|and|x?or|not
                |const|let|mut|dyn
                |va[rl]|use|given|state
                |func|proc|prop|type|class|actor
                |impl|enum|module|struct|record
                |union|iter|macro|query|elem|temp
                |object|realm|trait|style|script|quote
                |go|defer|do|with|from|where
                |if|else|then|guard|when
                |for|loop|while|goto|move
                |try|throw|catch|switch
                |match|case|pass|def
                |break|skip|redo|retry
                |return|yield|await|scope
                |import|export|intern|extern
                |debug|assert|check|decl
              )
              \b
            )
            \b
            [\p{Pc}\p{L}]\w* # identifier
            \b
          )
        captures:
          1: {name: punctuation.definition.anchor.ruko}
          2: {patterns: [include: '#placeholder-variables']}
      - name: meta.embedded.placeholder.ruko
        begin: (\#{)\s*
        end: \s*(})
        captures:
          1: {name: punctuation.definition.anchor.ruko}
        patterns:
          - include: '#parameter-variables'
          - include: $self

  # Format and flag specifiers

  format-switch-clause:
    patterns:
      - comment: // for multiple flags at once with single-character aliases
        applyEndPatternLast: true
        begin: (?:(?<=%)|(//))([\p{Pc}\p{L}]\w*)\b
        end: (?=)|$
        captures:
          1: {name: punctuation.definition.flag.ruko}
          2: {name: storage.type.format.ruko}
        patterns:
          - comment: Format switch without value
            match: ([\p{Pc}\p{L}]\w*)
            captures:
              1: {name: keyword.other.flag.ruko}
      - comment: / for a single flag, with optional arguments
        applyEndPatternLast: true
        begin: (?:(?<=%)|(/))([\p{Pc}\p{L}]\w*)\b
        end: (?=)|$
        captures:
          1: {name: punctuation.definition.flag.ruko}
          2: {name: storage.type.format.ruko}
        patterns:
          - comment: Format switch without value
            match: ([\p{Pc}\p{L}]\w*)
            captures:
              1: {name: keyword.modifier.ruko}

  embedded-format:
    comment: Oniguruma supports only 20 levels of recursion
    applyEndPatternLast: true
    name: meta.embedded.formatting.ruko
    begin: (?<!%)(%)(?=[\p{Pc}\p{L}])
    end: (?=)|$
    captures:
      1: {name: punctuation.definition.directive.ruko}
    patterns:
      - include: '#format-syntax'

  format-syntax:
    comment: Format specifier language, inspired by MS-DOS, Bash and Python's f-strings.
    patterns:
      - comment: with optional value
        applyEndPatternLast: true
        begin: (?:(?<=%)|(\|))([\p{Pc}\p{L}]\w*)\b(:)
        end: (?=)|$
        name: storage.type.format.ruko
        captures:
          1: {name: punctuation.separator.mapping.ruko}
          2: {name: storage.type.format.ruko}
          3: {name: punctuation.separator.key-value.ruko}
        patterns:
          - include: '#constants'
          - include: '#generics'
          - include: '#brackets'
          - include: '#embedded-function-calls'
          - match: (?<=>|\w)(!)(?=#?[({])
            captures:
              1: {name: keyword.operator.macro.ruko}
          - include: '#variables'
          - include: '#numbers'
          - include: '#regexps'
          - include: '#symbols'
          - *qualified-name-separators
      - comment: type specifier
        match: (?:(?<=%)|(\|))([\p{Pc}\p{L}]\w*)\b
        name: storage.type.format.ruko
        captures:
          1: {name: punctuation.separator.mapping.ruko}
          2: {name: storage.type.format.ruko}
      - comment: // for multiple flags at once with single-character aliases
        match: (?:(?<=%)|(//))([\p{Pc}\p{L}]\w*)\b
        name: storage.type.format.ruko
        captures:
          1: {name: punctuation.definition.flag.ruko}
          2: {name: storage.type.format.ruko}
      - comment: / for a single flag, with optional arguments
        match: (?:(?<=%)|(/))([\p{Pc}\p{L}]\w*)\b
        name: storage.type.format.ruko
        captures:
          1: {name: punctuation.definition.flag.ruko}
          2: {name: storage.type.format.ruko}
      - include: '#format-switch-clause'

  # Regular expressions

  old-regexp--patterns:
    patterns:
      - applyEndPatternLast: true
        comment: Pattern section
        begin: (/>)\s*
        end: \s*(</)(\p{L}*)
        name: string.regexp.pattern.ruko
        captures:
          1: {name: punctuation.definition.regexp.ruko}
          2: {name: keyword.other.flag.ruko}
        patterns:
          - include: '#comments'
          - include: '#regexp-patterns'
          - comment: Replacement section
            begin: (</>)\s*
            end: \s*(?=</)
            name: string.regexp.replace.ruko
            captures:
              1: {name: punctuation.definition.regexp.ruko}
            patterns:
              - include: '#back-references'
              - include: '#string-content'
      - comment: Pattern section
        begin: (/)\s*
        end: \s*(/)(\p{L}*)
        name: string.regexp.pattern.ruko
        captures:
          1: {name: punctuation.definition.regexp.ruko}
          2: {name: keyword.other.flag.ruko}
        patterns:
          - include: '#regexp-patterns'

  regexps:
    applyEndPatternLast: true
    begin: |
      (?x)
      (?<=
        (?:
            # beginning of line
            ^
          | # separator
            [,;]
          | # opening bracket
            [({\[]
          | # postfix or infix operator
            [\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]+ \s
        ) \s*
        | # a keyword
        (?:
          (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
          \b
            (?: # keywords
              [io]n|of|[ai]s|has|old|new|del
              |unset|ref|and|x?or|not
              |const|let|mut|dyn
              |va[rl]|use|given|state
              |func|proc|prop|type|class|actor
              |impl|enum|module|struct|record
              |union|iter|macro|query|elem|temp
              |object|realm|trait|style|script|quote
              |go|defer|do|with|from|where
              |if|else|then|guard|when
              |for|loop|while|goto|move
              |try|throw|catch|switch
              |match|case|pass|def
              |break|skip|redo|retry
              |return|yield|await|scope
              |import|export|intern|extern
              |debug|assert|check|decl
            )
          \b
        ) \s*
      ) \s*
      (?= />?)
    end: (?=)|$
    name: meta.regexp.ruko
    patterns:
      - applyEndPatternLast: true
        comment: Multi-line pattern section
        begin: (/>)\s*
        end: \s*(</)(\p{L}*)
        name: string.regexp.pattern.ruko
        captures:
          1: {name: punctuation.definition.regexp.ruko}
          2: {name: keyword.other.flag.ruko}
        patterns:
          - include: '#comments'
          - include: '#regexp-patterns'
          - comment: Multi-line replacement section
            begin: (:)\s*
            end: \s*(\|)|\s*(?=</)
            name: string.regexp.replace.ruko
            captures:
              1: {name: punctuation.definition.regexp.ruko}
            patterns:
              - include: '#back-references'
              - include: '#string-content'
      - comment: Single-line pattern section
        begin: (/)\s*(?=(?:[^\\/]|\\.)+/\p{L}*)
        end: \s*(/)(\p{L}*)
        name: string.regexp.pattern.ruko
        captures:
          1: {name: punctuation.definition.regexp.ruko}
          2: {name: keyword.other.flag.ruko}
        patterns:
          - include: '#regexp-patterns'
          - comment: Single-line replacement section
            begin: (:)\s*
            end: \s*(\|)|\s*(?=/)
            name: string.regexp.replace.ruko
            captures:
              1: {name: punctuation.definition.regexp.ruko}
            patterns:
              - include: '#back-references'
              - include: '#string-content'

  fuzzy-expression:
    patterns:
      - include: '#punctuation'
      - include: '#comments'
      - include: '#function-calls'
      - include: '#literals'
      - include: '#embedded'
      - include: '#operators'
      - include: '#clauses'
      - include: '#declarations'
      - include: '#keywords'
      - include: '#fuzzy-brackets'
      - match: \b[\p{Pc}\p{L}]\w*\b
        name: keyword.other.unit.ruko
      - include: '#space'

  fuzzy-brackets:
    patterns:
      - begin: (\{)\s*
        end: \s*(\})
        captures:
          1: {name: punctuation.definition.mapping.ruko}
        patterns:
          - match: ','
            name: punctuation.separator.mapping.ruko
          - include: '#labels'
          - include: '#fuzzy-expression'
          - include: $self
      - begin: (\[)\s*
        end: \s*(\])
        captures:
          1: {name: punctuation.definition.array.ruko}
        patterns:
          - match: ','
            name: punctuation.separator.sequence.ruko
          - include: '#fuzzy-expression'
          - include: $self
      - begin: (\()\s*
        end: \s*(\))
        captures:
          1: {name: punctuation.definition.expression.ruko}
        patterns:
          - match: ','
            name: punctuation.separator.arguments.ruko
          - include: '#fuzzy-expression'
          - include: $self

  back-references:
    patterns:
      - match: \$(\d+[+-]?|[+-]\d*)
        name: keyword.other.back-reference.ruko
      - begin: (\$<)\s*
        end: \s*(>)
        name: keyword.other.back-reference.ruko
        captures:
          1: {name: keyword.other.back-reference.ruko}
        patterns: &regex-back-references
          - include: '#variables'
          - include: '#numbers'
          - include: '#operators'
          - include: '#string-content'
      - begin: (\$(['"]))\s*
        end: \s*(\2)
        name: keyword.other.back-reference.ruko
        captures:
          1: {name: keyword.other.back-reference.ruko}
        patterns: *regex-back-references

  regexp-patterns:
    comment: |
      See https://gist.github.com/CMCDragonkai/6c933f4a7d713ef712145c5eb94a1816
      and https://www.regular-expressions.info/
    patterns:
      - include: '#comments'
      - include: '#embedded'
      - include: '#strings'
      - match: \|
        name: keyword.operator.or.ruko
      - match: \&
        name: keyword.operator.compose.ruko
      - match: \.
        name: constant.character.all.ruko
      - match: (?i)\\[by](?:{(?:[^\\{}]|\\.)+})?
        name: keyword.control.anchor.ruko
      - match: (\\[aAm<]|\^+)(?:{(?:[^\\{}]|\\.)+})?
        name: keyword.control.begin.ruko
      - match: (\\[zZM>]|\$+)(?:{(?:[^\\{}]|\\.)+})?
        name: keyword.control.end.ruko}
      - match: \\K
        name: keyword.control.keep-out.ruko
      - match: \\G
        name: keyword.control.search.ruko
      - match: \\R
        name: constant.character.control.ruko
      - match: \\[XO]
        name: constant.character.unicode.ruko
      - match: \\\d+
        name: keyword.other.back-reference.ruko
      - match: \{\s*(?:\d*\s*,){,2}\s*\d*\s*}\s*(?:(\?)|(\+)|(\*))?
        captures:
          0: {name: keyword.operator.quantifier.ruko}
          1: {name: keyword.operator.modifier.lazy.ruko}
          2: {name: keyword.operator.modifier.eager.ruko}
          3: {name: keyword.operator.modifier.greedy.ruko}
      - match: (?:(\?)|(\+)|(\*))\s*(?:(\?)|(\+)|(\*))?
        captures:
          1: {name: keyword.operator.quantifier.lazy.ruko}
          2: {name: keyword.operator.quantifier.eager.ruko}
          3: {name: keyword.operator.quantifier.greedy.ruko}
          4: {name: keyword.operator.modifier.lazy.ruko}
          5: {name: keyword.operator.modifier.eager.ruko}
          6: {name: keyword.operator.modifier.greedy.ruko}
      - begin: (\\k<)
        end: \s*(>)
        name: constant.other.back-reference.ruko
        captures:
          1: {name: keyword.other.back-reference.ruko}
        patterns: *regex-back-references
      - begin: (\\g<)
        end: \s*(>)
        name: constant.other.subroutine.ruko
        captures:
          1: {name: keyword.other.subroutine.ruko}
        patterns: *regex-back-references
      - begin: (\\k('''+|"""+|['"]))
        end: \s*(\2)
        name: constant.other.back-reference.ruko
        captures:
          1: {name: keyword.other.back-reference.ruko}
        patterns: *regex-back-references
      - begin: (\\g('''+|"""+|['"]))
        end: \s*(\2)
        name: constant.other.subroutine.ruko
        captures:
          1: {name: keyword.other.subroutine.ruko}
        patterns: *regex-back-references
      - begin: ({)
        end: \s*(})
        name: meta.fuzzy.ruko
        captures:
          1: {name: punctuation.definition.fuzzy.ruko}
        patterns:
          - applyEndPatternLast: true
            begin: (?<=^|\\.|[,;'"`({\[)}\]\w\s])(:)
            beginCaptures:
              1: {name: punctuation.separator.key-value.ruko}
            end: (?=[,;}]|)|$
            patterns: &regexp-patterns
              - include: '#regexp-patterns'
          - include: '#fuzzy-expression'
      - match: \\[abefrntv]
        name: constant.character.escape.ruko
      - match: \\[wsdhulqmji]
        name: constant.other.character-class.ruko
      - match: \\[WSDHULQMJI]
        name: constant.other.character-class.negated.ruko
      - include: '#regexp-groups'
      - include: '#regexp-character-set'
      - include: '#regexp-character-class'
      - include: '#space'

  regexp-groups:
    patterns:
      - comment: Backtracking control verb
        begin: (\(\*([\p{Pc}\p{L}]\w*)?(:)?)
        end: \s*(\))
        name: meta.group.backtrack.ruko
        captures:
          1: {name: punctuation.section.expression.ruko}
          2: {name: keyword.control.ruko}
          3: {name: punctuation.separator.colon.ruko}
        patterns:
          - include: '#regexp-patterns'
      - comment: Block comment
        begin: (\()(\?#)
        contentName: comment.block.regexp.ruko
        end: \s*(\))
        name: comment.block.regexp.ruko
        captures:
          1: {name: punctuation.definition.comment.ruko}
        patterns:
          - match: \\.
            name: comment.block.regexp.ruko
      - comment: Lookahead assertion
        begin: (\(\?=)
        end: \s*(\))
        name: meta.group.look-ahead.ruko
        captures:
          1: {name: punctuation.definition.group.look-ahead.ruko}
        patterns:
          - include: '#regexp-patterns'
      - comment: Lookbehind assertion
        begin: (\(\?<=)
        end: \s*(\))
        name: meta.group.look-behind.ruko
        captures:
          1: {name: punctuation.definition.group.look-behind.ruko}
        patterns:
          - include: '#regexp-patterns'
      - comment: Negative lookahead assertion
        begin: (\(\?!)
        end: \s*(\))
        name: meta.group.negative-look-ahead.ruko
        captures:
          1:
            name: punctuation.definition.group.negative-look-ahead.ruko
        patterns: *regexp-patterns
      - comment: Negative lookbehind assertion
        begin: (\(\?<!)
        end: \s*(\))
        name: meta.group.negative-look-behind.ruko
        captures:
          1:
            name: punctuation.definition.group.negative-look-behind.ruko
        patterns:
          - include: '#regexp-patterns'
      - comment: Match directive Oniguruma supports only 20 levels of recursion
        begin: (?x)(\(\?)(?=%)
        captures:
          1: {name: punctuation.definition.group.directive.ruko}
        end: \s*(\))
        name: meta.group.directive.ruko
        patterns:
          - include: '#format-syntax'
          - include: '#regexp-patterns'
      - comment: Longest match
        begin: (\(\?/=?)
        end: \s*(\))
        name: meta.group.longest.ruko
        captures:
          1: {name: punctuation.definition.group.longest.ruko}
        patterns:
          - include: '#regexp-patterns'
      - comment: Back-reference groups
        begin: \((\?&(?:([+-]?\d+)|([\p{Pc}\p{L}]\w*)))(:)?
        end: \s*\)
        name: meta.group.back-reference.ruko
        captures:
          0: {name: punctuation.definition.group.back-reference.ruko}
          1: {name: punctuation.definition.group.back-reference.ruko}
          2: {name: constant.numeric.index.ruko}
          3: {patterns: [include: '#variables']}
          4: {name: punctuation.separator.colon.ruko}
        patterns:
          - include: '#regexp-patterns'
      - comment: Back-reference groups
        begin: \((\?&)
        end: \s*\)
        name: meta.group.back-reference.ruko
        captures:
          0: {name: punctuation.definition.group.back-reference.ruko}
          1: {name: punctuation.definition.group.back-reference.ruko}
        patterns:
          - begin: (?<=\(\?&)('''+|"""+|['"])
            end: \s*(\1)
            name: constant.other.group.ruko
            captures:
              1: {name: punctuation.definition.group.back-reference.ruko}
            patterns: *regex-back-references
          - include: '#regexp-patterns'
      - comment: Flag modifier group
        begin: (\(\?\^?(?:([+-]?\d+?)|((?:[+-]\p{Lu}+)+|\p{Lu}+(?:[+-]\p{Lu}+)*)|((?:[+-]\p{Ll}+)+|\p{Ll}+(?:[+-]\p{Ll}+)*)))\s*(:)?
        end: \s*(\))
        name: meta.group.flag.ruko
        captures:
          0: {name: punctuation.definition.group.flag.ruko}
          1: {name: punctuation.definition.group.flag.ruko}
          2: {name: constant.numeric.index.ruko}
          3: {name: keyword.control.recursion.ruko}
          4: {name: keyword.other.flag.ruko}
          5: {name: punctuation.separator.colon.ruko}
        patterns:
          - include: '#regexp-patterns'
      - comment: Call-outs
        begin: (\(\?)(?={)
        end: \s*(\))
        name: meta.group.call-out.ruko
        captures:
          1: {name: punctuation.definition.group.call-out.ruko}
        patterns:
          - begin: (?<=\(\?)({)
            end: \s*(\})\s*([<*>])?(?:(\[)(.*?)(\]))?
            name: punctuation.definition.group.call-out.ruko
            captures:
              1: {name: punctuation.definition.group.call-out.ruko}
              2: {name: keyword.operator.range.ruko}
              3: {name: punctuation.definition.tag.ruko}
              4: {patterns: [include: '#function-names']}
              5: {name: punctuation.definition.tag.ruko}
            patterns:
              - include: $self
          - include: '#regexp-patterns'
      - comment: Atomic groups
        begin: (\(\?>)
        end: \s*(\))
        name: meta.group.atomic.ruko
        captures:
          1: {name: punctuation.definition.group.atomic.ruko}
        patterns:
          - include: '#regexp-patterns'
      - comment: Non-capturing groups
        begin: (\(\?:)
        end: \s*(\))
        name: meta.group.non-capturing.ruko
        captures:
          1: {name: punctuation.definition.group.non-capturing.ruko}
        patterns:
          - include: '#regexp-patterns'
      - comment: Branch groups
        begin: (\(\?)(?=[(|])
        end: \s*(\))
        name: meta.group.branch.ruko
        captures:
          1: {name: punctuation.definition.group.branch.ruko}
        patterns:
          - include: '#regexp-patterns'
      - comment: Absent groups
        begin: (\(\?~)
        end: \s*(\))
        name: meta.group.absent.ruko
        captures:
          1: {name: punctuation.definition.group.absent.ruko}
        patterns:
          - include: '#regexp-patterns'
      - comment: Named groups (angle brackets)
        begin: \(\?(?=<(?![!=]))
        end: \s*(\))
        name: meta.group.named.ruko
        captures:
          0: {name: punctuation.definition.group.named.ruko}
        patterns:
          - begin: (?<=\(\?)(<)
            end: \s*(>)
            name: constant.other.group.ruko
            captures:
              1: {name: punctuation.definition.group.named.ruko}
            patterns: *regex-back-references
          - include: '#regexp-patterns'
      - comment: Named groups (single or double-quotes)
        begin: \(\?(?=['"])
        end: \s*(\))
        name: meta.group.named.ruko
        captures:
          0: {name: punctuation.definition.group.named.ruko}
        patterns:
          - begin: (?<=\(\?)('''+|"""+|['"])
            end: \s*(\1)
            name: constant.other.group.ruko
            captures:
              1: {name: punctuation.definition.group.named.ruko}
            patterns: *regex-back-references
          - include: '#regexp-patterns'
      - comment: Unnamed groups
        begin: (\()
        end: (\s*\))
        name: meta.group.ruko
        captures:
          1: {name: punctuation.definition.group.ruko}
        patterns:
          - include: '#regexp-patterns'

  regexp-character-class:
    patterns:
      - include: '#embedded'
      - begin: (\\)(?=\s*$)
        end: ^\s*(?=\S)
        captures:
          1: {name: constant.character.escape.newline.ruko}
      - include: '#named-escapes'
      - include: '#numeric-escapes'
      - begin: (?i)\\p{
        end: \s*}
        name: constant.other.character-class.unicode.ruko
        patterns:
          - include: '#attribute-selectors'
      - match: (?i)\\([cm][a-z])
        name: constant.character.control.ruko
      - match: (?i)\\p[a-z]{1,2}
        name: constant.other.character-class.unicode.ruko
      - match: (?i)\\[ci]({\w+})?
        name: constant.other.character-class.xml.ruko
      - match: (?i)\\n{(?:[^\\{}]|\\.)+}
        name: constant.character.escape.unicode.name.ruko
      - match: \\[abefprntv]
        name: constant.character.escape.ruko
      - match: \\[a-z]
        name: constant.other.character-class.ruko
      - match: \\[A-Z]
        name: constant.other.character-class.negated.ruko
      - match: \\\p{S}
        name: constant.character.escape.symbol.ruko
      - match: \\\p{P}
        name: constant.character.escape.punctuation.ruko
      - match: \\[a-zA-Z\p{C}]
        name: invalid.illegal.escape.ruko
      - match: \\\s
        name: constant.character.escape.space.ruko
      - match: \\\p{L}
        name: constant.character.escape.letter.ruko
      - match: \\\p{N}
        name: constant.character.escape.number.ruko
      - match: \\.
        name: constant.character.escape.other.ruko

  regexp-character-operators:
    patterns:
      - match: |
          (?x)
          ( # from
              \\(?:d?\d+|d{[\d\s,;]+}) # decimal escape
            | \\[xu](?:\h+|{[\h\s,;]+}) # hex escape
            | \\z(?:[\d\u218a\u218babetx]+|{[\d\u218a\u218babetx\s,;]+}) # duodecimal escape
            | \\o(?:[0-7]+|{[0-7\s,;]+}) # octal escape
            | \\b(?:[01]+|{[01\s,;]+}) # binary escape
            | \\[cm][a-z] # meta-character
            | \\n{(?:[^\\{}]|\\.)+} # Unicode named character
            | \\(?:[abefprntv]|[^a-zA-Z]) # any escape character
            | [^-\\\[\]] # any unescaped character
          )
            \s*
              (-|->|>-|>>) # range
            \s*
          ( # to
              \\(?:d?\d+|d{[\d\s,;]+}) # decimal escape
            | \\[xu](?:\h+|{[\h\s,;]+}) # hex escape
            | \\z(?:[\d\u218a\u218babetx]+|{[\d\u218a\u218babetx\s,;]+}) # duodecimal escape
            | \\o(?:[0-7]+|{[0-7\s,;]+}) # octal escape
            | \\b(?:[01]+|{[01\s,;]+}) # binary escape
            | \\[cm][a-z] # meta-character
            | \\n{(?:[^\\{}]|\\.)+} # Unicode named character
            | \\(?:[abefprntv]|[^a-zA-Z]) # any escape character
            | [^-\\\[\]] # any unescaped character
          ) (?:
              \s*
                (:) # range
              \s*
            ( # to
                \d+ # number
              | \\(?:d?\d+|d{[\d\s,;]+}) # decimal escape
              | \\[xu](?:\h+|{[\h\s,;]+}) # hex escape
              | \\z(?:[\d\u218a\u218babetx]+|{[\d\u218a\u218babetx\s,;]+}) # duodecimal escape
              | \\o(?:[0-7]+|{[0-7\s,;]+}) # octal escape
              | \\b(?:[01]+|{[01\s,;]+}) # binary escape
              | \\[cm][a-z] # meta-character
              | \\n{(?:[^\\{}]|\\.)+} # Unicode named character
              | \\(?:[abefprntv]|[^a-zA-Z]) # any escape character
              | [^-\\\[\]] # any unescaped character
            )
          )?
        captures:
          1:
            name: constant.other.character-class.range.from.ruko
            patterns:
              - include: '#regexp-character-operators'
              - include: '#regexp-character-class'
          2:
            name: keyword.operator.range.ruko
          3:
            name: constant.other.character-class.range.to.ruko
            patterns:
              - include: '#regexp-character-operators'
              - include: '#regexp-character-class'
          4:
            name: keyword.operator.range.ruko
          5:
            name: constant.other.character-class.range.by.ruko
            patterns:
              - include: '#numbers'
              - include: '#regexp-character-operators'
              - include: '#regexp-character-class'
      - match: \|\|
        name: keyword.operator.union.ruko
      - match: \&&
        name: keyword.operator.intersection.ruko
      - match: \^\^
        name: keyword.operator.symmetric.ruko
      - match: ~~
        name: keyword.operator.negation.ruko
      - match: --
        name: keyword.operator.difference.ruko

  regexp-character-set:
    patterns:
      - begin: (\[:)
        end: \s*(:\])
        name: constant.other.character-set.posix.ruko
        captures:
          1: {name: punctuation.definition.character-class.posix.ruko}
        patterns:
          - include: '#attribute-selectors'
      - begin: (\[\^)
        end: \s*(\])
        name: constant.other.character-set.negated.ruko
        captures:
          1:
            name: punctuation.definition.character-class.negated.ruko
        patterns:
          - include: '#comments'
          - include: '#regexp-character-operators'
          - include: '#regexp-character-class'
          - include: '#regexp-character-set'
      - begin: (\[)
        end: \s*(\])
        name: constant.other.character-set.ruko
        captures:
          1: {name: punctuation.definition.character-class.ruko}
        patterns:
          - include: '#comments'
          - include: '#regexp-character-operators'
          - include: '#regexp-character-class'
          - include: '#regexp-character-set'

  attribute-selectors:
    name: meta.attribute-selector.ruko
    patterns:
      - match: '[:!=</>.^$%?*+|&~]?='
        name: keyword.operator.pattern.ruko
      - match: \&\&|\|\||\^\^|\!
        name: keyword.operator.logical.ruko
      - match: ','
        name: punctuation.separator.sequence.ruko
      - match: \b(is\s+not|is|has)\b
        name: keyword.operator.expression.is.ruko
      - match: \b(not\s+)?([io]n|of)\b
        name: keyword.operator.expression.$2.ruko
      - begin: \b([\p{Pc}\p{L}]\w*)\b([:!=</>.^$%?*+|&~]?=)
        beginCaptures:
          1: {name: entity.other.attribute-name.key.ruko}
          2: {name: keyword.operator.pattern.ruko}
        end: (?=\&\&|\|\||\^\^|[\s,:;'"`)}\]]|\\.)
        name: string.unquoted.attribute-name.ruko
        patterns:
          - include: '#regexp-patterns'
      - match: (?xi)\b[is]\b\s*(?=[)}\]]|([&|^])\1)
        name: storage.modifier.ignore-when.ruko
      - include: '#string-escapes'
      - comment: Attribute names
        match: \b([\p{Pc}\p{L}]\w*)\b
        captures:
          1: {name: entity.other.attribute-name.ruko}
          2: {name: keyword.operator.pattern.ruko}
      - include: '#comments'
      - include: '#operators'

  # XML (JSX) and Markdown

  xml:
    applyEndPatternLast: true
    comment: Only captured when next to opening brackets, commas, semicolons, keywords, and operators. XML also supports functional components, so we need to be careful to also match those.
    begin: |
      (?x)
      (?<=
        (?:
            # beginning of line
            ^
          | # separator
            [,;]
          | # opening bracket
            [({\[]
          | # postfix or infix operator
            [\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]+ \s
        ) \s*
        | # a keyword
        (?:
          (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
          \b
            (?: # keywords
              [io]n|of|[ai]s|has|old|new|del
              |unset|ref|and|x?or|not
              |const|let|mut|dyn
              |va[rl]|use|given|state
              |func|proc|prop|type|class|actor
              |impl|enum|module|struct|record
              |union|iter|macro|query|elem|temp
              |object|realm|trait|style|script|quote
              |go|defer|do|with|from|where
              |if|else|then|guard|when
              |for|loop|while|goto|move
              |try|throw|catch|switch
              |match|case|pass|def
              |break|skip|redo|retry
              |return|yield|await|scope
              |import|export|intern|extern
              |debug|assert|check|decl
            )
          \b
        ) \s*
      ) \s*
      (?=<[>\p{Pc}\p{L}])
    end: (?=)|$
    patterns:
      - include: '#tag-component-name'

  tag-component-name:
    patterns:
      - comment: XML Fragment
        contentName: text.html.fragment.ruko
        begin: (<)(?=>)
        end: (?<=</)(>)
        beginCaptures:
          1: {name: punctuation.definition.tag.ruko}
        endCaptures:
          1: {name: punctuation.definition.tag.ruko}
        patterns:
          - include: '#tag-termination'
      - comment: Tags that end > are trapped in tag-termination
        contentName: text.html.ruko
        begin: |
          (?x)
          (<) # start tag begin
          (
            (?:
              \b
              [\p{Pc}\p{L}]\w* # identifier
              \b
              (?:[?!:]:|[?!]?\.) # qualified name separator
            )*
            [\p{Pc}\p{L}]\w* # last part of identifier
            \b
          )
          (?=[,;'"`({\[)}\]/>\s])
        end: |
          (?x) \s*
          (?:
              (?<=</)(\2)(>)
            | (<?/>)
            | ((?<=</).*?)>
          )
        beginCaptures:
          1: {name: punctuation.definition.tag.ruko}
          2: {patterns: [include: '#tag-names']}
        endCaptures:
          1: {patterns: [include: '#tag-names']}
          2: {name: punctuation.definition.tag.ruko}
          3: {name: punctuation.definition.tag.ruko}
          4: {name: invalid.illegal.termination.ruko}
        patterns:
          - include: '#tag-attributes'
          - include: '#tag-termination'

  xml-comments:
    begin: (<!--)
    end: (-->)
    captures:
      1: {name: punctuation.definition.comment.ruko}
    name: comment.block.html.ruko
    patterns:
      - include: '#xml-comments'

  tag-termination:
    comment: uses non consuming search for </ in </tag>
    contentName: meta.xml.children.ruko
    begin: (>)
    end: (</)
    captures:
      0: {name: punctuation.definition.tag.ruko}
    patterns:
      - include: '#evaluated-code'
      - include: '#xml-entities'
      - include: '#tag-component-name'
      - include: '#markdown'
      - include: '#xml-comments'

  tag-attributes:
    patterns:
      - match: \s*([@#&*|%.:~^?]|::)(?=[\w$'"`])
        name: punctuation.definition.entity.ruko
      - include: '#spread-attribute'
      - include: '#style-attribute'
      - include: '#attribute-directive'
      - include: '#attribute-assignment'
      - include: '#attribute-names'
      - include: '#literals'
      - include: '#hex-colors'
      - include: '#embedded-expression'
      - include: '#embedded-format'
      - include: '#embedded-placeholder'
      - include: '#function-calls'
      - include: '#variables'
      - include: '#brackets'
      - include: '#comments'
      - include: '#punctuation'
      - include: '#space'

  attribute-directive:
    patterns:
      - match: \s*([@#&*%|:?])([\p{Pc}\p{L}][\p{Pd}\w]*)\b\s*
        name: meta.attribute.directive.ruko
        captures:
          1: {name: punctuation.definition.directive.ruko}
          2: {name: entity.other.attribute-name.directive.ruko}

  style-attribute:
    begin: \s*(style)\s*(=)\s*({)\s*
    beginCaptures:
      1: {name: storage.type.style.ruko}
      2: {name: punctuation.separator.key-value.ruko}
      3: {name: punctuation.definition.style-block.ruko}
    end: \s*(})\s*
    endCaptures:
      1: {name: punctuation.definition.style-block.ruko}
    name: meta.attribute.style.ruko
    patterns:
      - include: '#style-properties'

  attribute-assignment:
    applyEndPatternLast: true
    begin: \s*([\p{Pc}\p{L}][\p{Pd}\w]*)\s*(=)
    beginCaptures:
      1: &attribute-name
        name: entity.other.attribute-name.ruko
        patterns:
          - match: \s*(?<=\@)[\p{Pc}\p{L}]\w*\b\s*
            name: keyword.control.at-rule.ruko
          - match: \s*(?<=\#)[\p{Pc}\p{L}]\w*\b\s*
            name: entity.other.attribute-name.id.ruko
          - match: \s*(?<=\.)[\p{Pc}\p{L}]\w*\b\s*
            name: entity.other.attribute-name.class.ruko
          - match: \s*(?<=::)[\p{Pc}\p{L}]\w*\b\s*
            name: entity.other.attribute-name.pseudo-component.ruko
          - match: \s*(?<=\~)[\p{Pc}\p{L}]\w*\b\s*
            name: entity.other.attribute-name.key.ruko
          - match: \s*(?<=\&)[\p{Pc}\p{L}]\w*\b\s*
            name: entity.other.attribute-name.ruko entity.name.type.anchor.ruko
          - match: \s*(?<=\*)[\p{Pc}\p{L}]\w*\b\s*
            name: entity.other.attribute-name.ruko entity.name.type.alias.ruko
          - match: \s*(?<=\%)[\p{Pc}\p{L}]\w*\b\s*
            name: entity.other.attribute-name.ruko entity.name.function.ruko
          - match: \s*(?<=\|)[\p{Pc}\p{L}]\w*\b\s*
            name: entity.other.attribute-name.ruko entity.name.method.ruko
          - match: \s*(?<=\:)[\p{Pc}\p{L}]\w*\b\s*
            name: entity.other.attribute-name.ruko entity.name.procedure.ruko
          - match: \s*(?<=\^)[\p{Pc}\p{L}]\w*\b\s*
            name: entity.other.attribute-name.ruko entity.name.property.ruko
          - match: \s*(?<=\?)[\p{Pc}\p{L}]\w*\b\s*
            name: entity.other.attribute-name.ruko entity.name.predicate.ruko
          - include: '#css-property-names'
      2: {name: punctuation.separator.key-value.ruko}
    end: (?=)|$
    name: meta.attribute.assignment.ruko
    patterns:
      - include: '#attribute-values'

  attribute-values:
    patterns:
      - include: '#literals'
      - include: '#embedded-expression'
      - include: '#brackets'

  attribute-names:
    match: \s*([\p{Pc}\p{L}][\p{Pd}\w]*)\b(?!\s*=)\s*
    name: meta.attribute.boolean.ruko
    captures:
      1: *attribute-name

  spread-attribute:
    comment: Spread *attribute
    match: (?<!\*)\*(?!\*)
    name: keyword.operator.spread.ruko

  xml-entities:
    patterns:
      - match: |
          (?xi)
          (&)(?:
              (\#\d+)
            | (\#b[01]+)
            | (\#q[0-3]+)
            | (\#s[0-5]+)
            | (\#o[0-7]+)
            | (\#z(?i:[\d\u218a\u218babetx]+))
            | (\#x\h+)
            | ([\p{Pc}\p{L}]\w*)
            | ((?:\\.|[^({\[)}\]\s;])+?)
          )(;)
        name: constant.other.entity.ruko
        captures: &xml-entities
          1: {name: punctuation.definition.entity.ruko}
          2: {name: constant.character.escape.decimal.ruko}
          3: {name: constant.character.escape.binary.ruko}
          4: {name: constant.character.escape.quaternary.ruko}
          5: {name: constant.character.escape.senary.ruko}
          6: {name: constant.character.escape.octal.ruko}
          7: {name: constant.character.escape.duodecimal.ruko}
          8: {name: constant.character.escape.hexadecimal.ruko}
          9: {name: constant.character.entity.named.ruko}
          10: {name: constant.character.entity.ruko}
          11: {name: punctuation.definition.entity.ruko}
      - match: '&(?=\w*;)'
        name: invalid.illegal.ambiguous-ampersand.ruko
      - comment: Entity with & and invalid name
        match: '&\s*+;'
        name: invalid.illegal.bad-ampersand.ruko

  inline-markdown:
    patterns:
      - include: '#ampersand'
      - include: '#bracket'
      - include: '#bold'
      - include: '#italic'
      - include: '#underline'
      - include: '#strikethrough'
      - include: '#superscript'
      - include: '#subscript'
      - include: '#spoiler'
      - include: '#highlight'
      - include: '#string-content'
      - include: '#raw'
      - include: '#escape'
      - include: '#image-inline'
      - include: '#image-ref'
      - include: '#link-email'
      - include: '#link-inet'
      - include: '#link-inline'
      - include: '#link-ref'
      - include: '#link-ref-literal'
      - include: '#link-ref-shortcut'

  ampersand:
    comment: Markdown will convert this for us. We match it so that the HTML grammar will not mark it up as invalid.
    match: '&(?!([a-zA-Z\d]+|#[\d]+|#x\h+);)'
    name: meta.other.valid-ampersand.markdown

  bold:
    begin: |
      (?x)
      (?<open>(\*\*(?=\w)|(?<!\w)\*\*|(?<!\w)\b__))(?=\S)
      (?=
        (
          <[^>]*+> # HTML tags
          | (?<raw>`+)([^`]|(?!(?<!`)\k<raw>(?!`))`)*+\k<raw>
          # Raw
          | \\[\\`*_{}\[\]() #.!+\->]?+ # Escapes
          | \[
          (
              (?<square> # Named group
                [^\[\]\\] # Match most chars
                | \\. # Escaped chars
                | \[ \g<square>*+ \] # Nested brackets
              )*+
            \]
            (
              ( # Reference Link
                [ ]? # Optional space
                \[[^\]]*+\] # Ref name
              )
              | ( # Inline Link
                \( # Opening paren
                  [ \t]*+ # Optional whitespace
                  <?(.*?)>? # URL
                  [ \t]*+ # Optional whitespace
                  ( # Optional Title
                    (?<title>['"])
                    (.*?)
                    \k<title>
                  )?
                \)
              )
            )
          )
          | (?!(?<=\S)\k<open>). # Everything besides
          # style closer
        )++
        (?<=\S)(?=__\b|\*\*)\k<open> # Close
      )
    captures:
      1: {name: punctuation.definition.bold.markdown}
    end: (?<=\S)(\1)
    name: markup.bold.markdown
    patterns:
      - include: '#ampersand'
      - include: '#bracket'
      - include: '#italic'
      - include: '#underline'
      - include: '#strikethrough'
      - include: '#superscript'
      - include: '#subscript'
      - include: '#spoiler'
      - include: '#highlight'
      - include: '#string-content'
      - include: '#raw'
      - include: '#escape'
      - include: '#image-inline'
      - include: '#image-ref'
      - include: '#link-email'
      - include: '#link-inet'
      - include: '#link-inline'
      - include: '#link-ref'
      - include: '#link-ref-literal'
      - include: '#link-ref-shortcut'

  italic:
    begin: |
      (?x) (?<open>(\*(?=\w)|(?<!\w)\*|(?<!\w)\b_))(?=\S) # Open
      (?=
        (
          <[^>]*+> # HTML tags
          | (?<raw>`+)([^`]|(?!(?<!`)\k<raw>(?!`))`)*+\k<raw>
          # Raw
          | \\[\\`*_{}\[\]() #.!+\->]?+ # Escapes
          | \[
          (
              (?<square> # Named group
                [^\[\]\\] # Match most chars
                | \\. # Escaped chars
                | \[ \g<square>*+ \] # Nested brackets
              )*+
            \]
            (
              ( # Reference Link
                [ ]? # Optional space
                \[[^\]]*+\] # Ref name
              )
              | ( # Inline Link
                \( # Opening paren
                  [ \t]*+ # Optional whitespace
                  <?(.*?)>? # URL
                  [ \t]*+ # Optional whitespace
                  ( # Optional Title
                    (?<title>['"])
                    (.*?)
                    \k<title>
                  )?
                \)
              )
            )
          )
          | \k<open>\k<open> # Must be bold closer
          | (?!(?<=\S)\k<open>). # Everything besides
          # style closer
        )++
        (?<=\S)(?=_\b|\*)\k<open> # Close
      )
    captures:
      1: {name: punctuation.definition.italic.markdown}
    end: (?<=\S)(\1)((?!\1)|(?=\1\1))
    name: markup.italic.markdown
    patterns:
      - include: '#ampersand'
      - include: '#bracket'
      - include: '#bold'
      - include: '#underline'
      - include: '#strikethrough'
      - include: '#superscript'
      - include: '#subscript'
      - include: '#spoiler'
      - include: '#highlight'
      - include: '#string-content'
      - include: '#raw'
      - include: '#escape'
      - include: '#image-inline'
      - include: '#image-ref'
      - include: '#link-email'
      - include: '#link-inet'
      - include: '#link-inline'
      - include: '#link-ref'
      - include: '#link-ref-literal'
      - include: '#link-ref-shortcut'

  strikethrough:
    begin: (~~)(?=\S)
    captures:
      1: {name: punctuation.definition.strikethrough.markdown}
    end: (?<=\S)(~~)
    name: markup.strikethrough.markdown
    patterns:
      - include: '#ampersand'
      - include: '#bracket'
      - include: '#bold'
      - include: '#italic'
      - include: '#underline'
      - include: '#superscript'
      - include: '#subscript'
      - include: '#spoiler'
      - include: '#highlight'
      - include: '#string-content'
      - include: '#raw'
      - include: '#escape'
      - include: '#image-inline'
      - include: '#image-ref'
      - include: '#link-email'
      - include: '#link-inet'
      - include: '#link-inline'
      - include: '#link-ref'
      - include: '#link-ref-literal'
      - include: '#link-ref-shortcut'

  underline:
    begin: (\+\+)(?=\S)
    captures:
      1: {name: punctuation.definition.underline.markdown}
    end: (?<=\S)(\+\+)
    name: markup.underline.markdown
    patterns:
      - include: '#ampersand'
      - include: '#bracket'
      - include: '#bold'
      - include: '#italic'
      - include: '#strikethrough'
      - include: '#superscript'
      - include: '#subscript'
      - include: '#spoiler'
      - include: '#highlight'
      - include: '#string-content'
      - include: '#raw'
      - include: '#escape'
      - include: '#image-inline'
      - include: '#image-ref'
      - include: '#link-email'
      - include: '#link-inet'
      - include: '#link-inline'
      - include: '#link-ref'
      - include: '#link-ref-literal'
      - include: '#link-ref-shortcut'

  spoiler:
    begin: (\|\|)(?=\S)
    captures:
      1: {name: punctuation.definition.spoiler.markdown}
    end: (?<=\S)(\|\|)
    name: markup.spoiler.markdown
    patterns:
      - include: '#ampersand'
      - include: '#bracket'
      - include: '#bold'
      - include: '#italic'
      - include: '#underline'
      - include: '#strikethrough'
      - include: '#superscript'
      - include: '#subscript'
      - include: '#highlight'
      - include: '#string-content'
      - include: '#raw'
      - include: '#escape'
      - include: '#image-inline'
      - include: '#image-ref'
      - include: '#link-email'
      - include: '#link-inet'
      - include: '#link-inline'
      - include: '#link-ref'
      - include: '#link-ref-literal'
      - include: '#link-ref-shortcut'

  highlight:
    begin: (==)(?=\S)
    captures:
      1: {name: punctuation.definition.highlight.markdown}
    end: (?<=\S)(==)
    name: markup.highlight.markdown
    patterns:
      - include: '#ampersand'
      - include: '#bracket'
      - include: '#bold'
      - include: '#italic'
      - include: '#underline'
      - include: '#strikethrough'
      - include: '#superscript'
      - include: '#subscript'
      - include: '#spoiler'
      - include: '#string-content'
      - include: '#raw'
      - include: '#escape'
      - include: '#image-inline'
      - include: '#image-ref'
      - include: '#link-email'
      - include: '#link-inet'
      - include: '#link-inline'
      - include: '#link-ref'
      - include: '#link-ref-literal'
      - include: '#link-ref-shortcut'

  superscript:
    begin: (\^)(?=\S)
    captures:
      1: {name: punctuation.definition.superscript.markdown}
    end: (?<=\S)(\^)
    name: markup.superscript.markdown
    patterns:
      - include: '#ampersand'
      - include: '#bracket'
      - include: '#bold'
      - include: '#italic'
      - include: '#underline'
      - include: '#strikethrough'
      - include: '#subscript'
      - include: '#spoiler'
      - include: '#highlight'
      - include: '#string-content'
      - include: '#raw'
      - include: '#escape'
      - include: '#image-inline'
      - include: '#image-ref'
      - include: '#link-email'
      - include: '#link-inet'
      - include: '#link-inline'
      - include: '#link-ref'
      - include: '#link-ref-literal'
      - include: '#link-ref-shortcut'

  subscript:
    begin: (~)(?=\S)
    captures:
      1: {name: punctuation.definition.subscript.markdown}
    end: (?<=\S)(~)
    name: markup.subscript.markdown
    patterns:
      - include: '#ampersand'
      - include: '#bracket'
      - include: '#bold'
      - include: '#italic'
      - include: '#underline'
      - include: '#strikethrough'
      - include: '#superscript'
      - include: '#spoiler'
      - include: '#highlight'
      - include: '#string-content'
      - include: '#raw'
      - include: '#escape'
      - include: '#image-inline'
      - include: '#image-ref'
      - include: '#link-email'
      - include: '#link-inet'
      - include: '#link-inline'
      - include: '#link-ref'
      - include: '#link-ref-literal'
      - include: '#link-ref-shortcut'

  bracket:
    comment: Markdown will convert this for us. We match it so that the HTML grammar will not mark it up as invalid.
    match: <(?![a-zA-Z/?\$!])
    name: meta.other.valid-bracket.markdown

  escape:
    match: \\[-`*_#+.!({\[)}\]\\>~|=]
    name: constant.character.escape.markdown

  image-inline:
    captures:
      1: {name: punctuation.definition.string.begin.markdown}
      2: {name: string.other.link.description.markdown}
      4: {name: punctuation.definition.string.end.markdown}
      5: {name: punctuation.definition.metadata.markdown}
      6: {name: punctuation.definition.link.markdown}
      7: {name: markup.underline.link.image.markdown}
      8: {name: punctuation.definition.link.markdown}
      9: {name: string.other.link.description.title.markdown}
      10: {name: punctuation.definition.string.markdown}
      11: {name: punctuation.definition.string.markdown}
      12: {name: string.other.link.description.title.markdown}
      13: {name: punctuation.definition.string.markdown}
      14: {name: punctuation.definition.string.markdown}
      15: {name: string.other.link.description.title.markdown}
      16: {name: punctuation.definition.string.markdown}
      17: {name: punctuation.definition.string.markdown}
      18: {name: punctuation.definition.metadata.markdown}
    match: |
      (?x)
      (\!\[)((?<square>[^\[\]\\]|\\.|\[\g<square>*+\])*+)(\])
      # Match the link text.
      (\() # Opening paren for url
        (<?)(\S+?)(>?) # The url
        [ \t]* # Optional whitespace
        (?:
            ((\().+?(\))) # Match title in parens...
          | ((").+?(")) # or in double quotes...
          | ((').+?(')) # or in single quotes.
        )? # Title is optional
        \s* # Optional whitespace
      (\))
    name: meta.image.inline.markdown

  image-ref:
    captures:
      1: {name: punctuation.definition.string.begin.markdown}
      2: {name: string.other.link.description.markdown}
      4: {name: punctuation.definition.string.begin.markdown}
      5: {name: punctuation.definition.constant.markdown}
      6: {name: constant.other.reference.link.markdown}
      7: {name: punctuation.definition.constant.markdown}
    match: (\!\[)((?<square>[^\[\]\\]|\\.|\[\g<square>*+\])*+)(\])[ ]?(\[)(.*?)(\])
    name: meta.image.reference.markdown
    patterns:
      - include: '#string-content'

  link-email:
    captures:
      1: {name: punctuation.definition.link.markdown}
      2: {name: markup.underline.link.markdown}
      4: {name: punctuation.definition.link.markdown}
    match: (<)((?:mailto:)?[a-zA-Z\d.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z\d-]+(?:\.[a-zA-Z\d-]+)*)(>)
    name: meta.link.email.lt-gt.markdown
    patterns:
      - include: '#string-content'

  link-inet:
    captures:
      1: {name: punctuation.definition.link.markdown}
      2: {name: markup.underline.link.markdown}
      3: {name: punctuation.definition.link.markdown}
    match: (<)((?:https?|ftp)://.*?)(>)
    name: meta.link.inet.markdown
    patterns:
      - include: '#string-content'

  link-inline:
    captures:
      1: {name: punctuation.definition.string.begin.markdown}
      2: {name: string.other.link.title.markdown}
      4: {name: punctuation.definition.string.end.markdown}
      5: {name: punctuation.definition.metadata.markdown}
      6: {name: punctuation.definition.link.markdown}
      7: {name: markup.underline.link.markdown}
      9: {name: punctuation.definition.link.markdown}
      10: {name: string.other.link.description.title.markdown}
      11: {name: punctuation.definition.string.begin.markdown}
      12: {name: punctuation.definition.string.end.markdown}
      13: {name: string.other.link.description.title.markdown}
      14: {name: punctuation.definition.string.begin.markdown}
      15: {name: punctuation.definition.string.end.markdown}
      16: {name: string.other.link.description.title.markdown}
      17: {name: punctuation.definition.string.begin.markdown}
      18: {name: punctuation.definition.string.end.markdown}
      19: {name: punctuation.definition.metadata.markdown}
    match: |
      (?x)
      (\[)((?<square>[^\[\]\\]|\\.|\[\g<square>*+\])*+)(\])
      # Match the link text.
      (\() # Opening paren for url
        (<?)((?<url>(?>[^\s()]+)|\(\g<url>*\))*)(>?) # The url
        [ \t]* # Optional whitespace
        (?:
            ((\().+?(\))) # Match title in parens...
          | ((").+?(")) # or in double quotes...
          | ((').+?(')) # or in single quotes.
        )? # Title is optional
        \s* # Optional whitespace
      (\))
    name: meta.link.inline.markdown
    patterns:
      - include: '#string-content'

  link-ref:
    captures:
      1: {name: punctuation.definition.string.begin.markdown}
      2: {name: string.other.link.title.markdown}
      4: {name: punctuation.definition.string.end.markdown}
      5: {name: punctuation.definition.constant.begin.markdown}
      6: {name: constant.other.reference.link.markdown}
      7: {name: punctuation.definition.constant.end.markdown}
    match: (\[)((?<square>[^\[\]\\]|\\.|\[\g<square>*+\])*+)(\])(\[)([^\]]*+)(\])
    name: meta.link.reference.markdown
    patterns:
      - include: '#string-content'

  link-ref-literal:
    captures:
      1: {name: punctuation.definition.string.begin.markdown}
      2: {name: string.other.link.title.markdown}
      4: {name: punctuation.definition.string.end.markdown}
      5: {name: punctuation.definition.constant.begin.markdown}
      6: {name: punctuation.definition.constant.end.markdown}
    match: (\[)((?<square>[^\[\]\\]|\\.|\[\g<square>*+\])*+)(\])[ ]?(\[)(\])
    name: meta.link.reference.literal.markdown
    patterns:
      - include: '#string-content'

  link-ref-shortcut:
    captures:
      1: {name: punctuation.definition.string.begin.markdown}
      2: {name: string.other.link.title.markdown}
      3: {name: punctuation.definition.string.end.markdown}
    match: (\[)(\S+?)(\])
    name: meta.link.reference.markdown
    patterns:
      - include: '#string-content'

  raw:
    captures:
      1: {name: punctuation.definition.raw.markdown}
      2: {patterns: [include: '#string-content']}
      3: {name: punctuation.definition.raw.markdown}
    match: (`+)([^`]|(?!(?<!`)\1(?!`))`)*+(\1)
    name: markup.inline.raw.string.markdown
    patterns:
      - include: '#string-content'

  markdown:
    patterns:
      - include: '#comments'
      - include: '#xml-entities'
      - include: '#html-tag'
      - include: '#string-content'
      - include: '#evaluated-code'
      - include: '#executed-code'
      - include: '#inline-styles'
      - include: '#blockquote'
      - include: '#unordered-list'
      - include: '#ordered-list'
      - include: '#inline-markdown'

    repository:
      blockquote:
        comment: '> blockquote'
        begin: ^\s*(\>)(\s+.*)\n*
        end: ^(?=\S)|(?!\G)
        beginCaptures:
          1: {name: punctuation.definition.quote.begin.markdown}
          2:
            name: markup.quote.markdown
            patterns: [include: '#markdown']
        name: markup.quote.markdown
        patterns:
          - begin: ^(\s+)(?!\s)
            end: ^(?!\1|\s*$)
            name: markup.quote.markdown
            patterns: [include: '#markdown']

      unordered-list:
        comment: '- unordered list'
        begin: ^\s*(\-)(?!>)\s+(.*)\n*
        end: ^(?=\S)|(?!\G)
        beginCaptures:
          1: {name: punctuation.definition.list.begin.markdown}
          2:
            name: markup.list.unnumbered.markdown
            patterns: [include: '#markdown']
        name: markup.list.unnumbered.markdown
        patterns:
          - begin: ^(\s+)(?!\s)
            end: ^(?!\1|\s*$)
            name: markup.list.unnumbered.markdown
            patterns: [include: '#markdown']

      ordered-list:
        comment: '+ ordered list'
        begin: ^\s*(\+)(?!>)\s+(.*)\n*
        end: ^(?=\S)|(?!\G)
        beginCaptures:
          1: {name: punctuation.definition.list.begin.markdown}
          2:
            name: markup.list.numbered.markdown
            patterns: [include: '#markdown']
        name: markup.list.numbered.markdown
        patterns:
          - begin: ^(\s+)(?!\s)
            end: ^(?!\1|\s*$)
            name: markup.list.numbered.markdown
            patterns: [include: '#markdown']

      evaluated-code:
        applyEndPatternLast: true
        comment: Evaluated code
        begin: (?<=^|[\w\s'"`])(=>)
        end: (?=|$)
        captures:
          1: {name: storage.type.method.ruko}
        patterns:
          - include: $self

      executed-code:
        applyEndPatternLast: true
        comment: Executed code
        begin: (?<=^|[\w\s'"`])(->)
        end: (?=|$)
        captures:
          1: {name: storage.type.subroutine.ruko}
        patterns:
          - include: $self

      html-tag:
        comment: <Tags
        applyEndPatternLast: true
        begin: (?<=^|[\w\s'"`])(<)\b
        end: (<?>?=?)|(?=)|$
        name: meta.tag.ruko
        captures:
          1: {name: punctuation.definition.tag.ruko}
        patterns:
          - comment: Tag name
            match: (?<=<)\b([\p{Pc}\p{L}]\w*\b(?:(?:[?!:]:|[?!]?\.)[\p{Pc}\p{L}]\w*)*)\b
            captures:
              1:
                name: entity.name.tag.ruko
                patterns: *html-tag-names
          - include: '#style-selectors'
          - begin: (\[)\s*
            end: \s*(\])\s*
            captures:
              1: {name: punctuation.definition.directive.ruko}
            patterns:
              - include: '#attribute-selectors'
              - include: $self
          - begin: (\{)\s*
            end: \s*(\})\s*
            captures:
              1: {name: punctuation.definition.mapping.ruko}
            patterns:
              - include: '#style-properties'
              - include: $self
          - begin: (\()\s*
            end: \s*(\))
            captures:
              1: {name: punctuation.definition.parameters.ruko}
            patterns:
              - include: '#tag-attributes'
              - include: $self
          - include: '#literals'
          - include: '#regexps'
          - include: '#punctuation'
          - include: '#comments'
          - include: '#space'

      inline-styles:
        begin: (?<=^|[\w\s'"`])(\+>)(.*)\n*
        beginCaptures:
          1:
            name: storage.type.style.ruko
          2:
            patterns:
              - match: (?<=^|\s)([?:]?=)(?=\s+|$)
                captures:
                  1: {name: keyword.operator.assignment.ruko}
              - include: '#comments'
              - include: '#style-pair'
              - include: '#style-rules'
              - include: '#declaration-clause'
              - match: *entity-name
                name: entity.name.style.ruko
        end: ^(?=\S)|(?!\G)
        patterns:
          - begin: ^(\s+)(?!\s)
            end: ^(?!\1|\s*$)
            name: meta.style.yaml
            patterns: [include: '#style-properties']

  # Special code blocks

  html-builtins:
    patterns:
      - include: source.css.scss#constant_functions
      - include: source.css.scss#constant_sass_functions
      - include: source.css.scss#constant_important
      - include: source.css.scss#constant_default
      - include: source.css.scss#constant_optional

  property-name:
    match: \b([\p{Pc}\p{L}]\w*\b(?:(?:(?:[?!:]:|[?!]?\.)?[\p{Pc}\p{L}]\w*)*)\b
    name: meta.property-name.ruko
    captures:
      1:
        patterns:
          - include: '#css-value-names'
          - match: ([\p{Pc}\p{L}]\w*)\b(?=[.:])
            name: constant.other.ruko
          - match: ([\p{Pc}\p{L}]\w*)\b
            name: constant.language.ruko
          - match: '[?!:]:|[?!]?\.'
            name: punctuation.separator.namespace.ruko

  style-list:
    begin: \s*(\[)\s*
    end: \s*(\])
    name: meta.brace.square.ruko
    captures:
      1: {name: punctuation.definition.expression.ruko}
    patterns:
      - include: '#punctuation'
      - include: '#style-property-values'
      - include: $self

  style-property-values:
    patterns:
      - include: '#hex-colors'
      - include: '#embedded-expression'
      - include: '#embedded-format'
      - include: '#embedded-placeholder'
      - include: '#css-value-names'
      - include: $self

  hex-colors:
    match: \s*(#)\b(?:\h{3,4}|\h{6}|\h{8})\b\s*
    name: constant.other.color.rgb-value.hex.css
    captures:
      1: {name: punctuation.definition.constant.css}

  tag-names:
    match: \s*\b([\p{Pc}\p{L}]\w*\b(?:(?:[?!:]:|[?!]?\.)?[\p{Pc}\p{L}]\w*)*)\b\s*
    name: entity.name.tag.ruko
    captures:
      1:
        name: entity.name.tag.ruko
        patterns: *html-tag-names

  script-block:
    begin: \s*(\{)\s*
    end: \s*(\})\s*
    name: meta.brace.script.ruko
    captures:
      1: {name: punctuation.definition.block.script.ruko}
    patterns:
      - include: '#interpolated-code'
      - include: source.js
      - include: $self

  style-block:
    begin: \s*(\{)\s*
    end: \s*(\})\s*
    name: meta.brace.style.ruko
    captures:
      1: {name: punctuation.section.property-list.ruko}
    patterns:
      - include: '#style-properties'

  style-pair:
    begin: (?<=^|[;,{\[(])\s*([\p{Pd}\w]+)\b(:)\s*
    end: (?=[;,}\])]|$)
    name: meta.property.css.ruko
    beginCaptures:
      1:
        name: support.type.property-name.ruko
        patterns: [include: '#css-property-names']
      2:
        name: punctuation.separator.key-value.ruko
    patterns:
      - include: '#style-property-values'
      - match: \s+
        name: meta.var.expr.ruko

  style-properties:
    patterns:
      - include: '#comments'
      - include: '#embedded'
      - include: '#clauses'
      - include: '#declarations'
      - include: '#keywords'
      - include: '#style-pair'
      - include: '#style-rules'
      - include: '#style-block'
      - include: '#space'
      - include: $self

  style-rules:
    patterns:
      - comment: CSS operators
        match: |
          (?x)
          \s*
            (?:
               (\+)|(\-)|(\*)|(\/)|(\%)|(\!)
              |(\?)|(\&)|(\^)|(\~)|(\$)|(\\)
              |([<>])|(\#)
            )
          \s*
        captures:
          1: {name: keyword.operator.sum.ruko}
          2: {name: keyword.operator.difference.ruko}
          3: {name: keyword.operator.product.ruko}
          4: {name: keyword.operator.quotient.ruko}
          5: {name: keyword.operator.remainder.ruko}
          6: {name: keyword.operator.only.ruko}
          7: {name: keyword.operator.maybe.ruko}
          8: {name: keyword.operator.intersection.ruko}
          9: {name: keyword.operator.symmetric.ruko}
          10: {name: keyword.operator.negation.ruko}
          11: {name: keyword.operator.macro.dollar.ruko}
          12: {name: keyword.operator.successor.ruko}
          13: {name: keyword.operator.class.ruko}
          14: {name: keyword.operator.id.ruko}
      - begin: \s*(\()\s*
        end: \s*(\))
        captures:
          1: {name: punctuation.definition.parameters.ruko}
        patterns:
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(as)\b\s*
            name: keyword.operator.expression.as.ruko
          - include: '#clauses'
          - include: '#constants'
          - include: '#declarations'
          - include: '#expression-keywords'
          - include: '#style-pair'
          - include: '#parameter-variables'
          - include: $self
      - begin: \s*(\[)\s*
        end: \s*(\])\s*
        captures:
          1: {name: punctuation.definition.selector.ruko}
        patterns:
          - include: '#attribute-selectors'
          - include: $self
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(from|to|except|only|as)\b\s*
        name: keyword.operator.expression.ruko
      - include: '#style-selectors'
      - include: '#format-syntax'
      - include: '#tag-names'

  style-selectors:
    patterns:
      - match: \s*([@#&*|%.:~^?]|::)(?=[\w$'"`])
        name: punctuation.definition.entity.ruko
      - match: \s*(?<=\@)[\p{Pc}\p{L}]\w*\b\s*
        name: keyword.control.at-rule.ruko
      - match: \s*(?<=\#)[\p{Pc}\p{L}]\w*\b\s*
        name: entity.other.attribute-name.id.ruko
      - match: \s*(?<=\.)[\p{Pc}\p{L}]\w*\b\s*
        name: entity.other.attribute-name.class.ruko
      - match: \s*(?<=::)[\p{Pc}\p{L}]\w*\b\s*
        name: entity.other.attribute-name.pseudo-component.ruko
      - match: \s*(?<=\~)[\p{Pc}\p{L}]\w*\b\s*
        name: entity.other.attribute-name.key.ruko
      - match: \s*(?<=\&)[\p{Pc}\p{L}]\w*\b\s*
        name: entity.other.attribute-name.ruko entity.name.type.anchor.ruko
      - match: \s*(?<=\*)[\p{Pc}\p{L}]\w*\b\s*
        name: entity.other.attribute-name.ruko entity.name.type.alias.ruko
      - match: \s*(?<=\%)[\p{Pc}\p{L}]\w*\b\s*
        name: entity.other.attribute-name.ruko entity.name.function.ruko
      - match: \s*(?<=\|)[\p{Pc}\p{L}]\w*\b\s*
        name: entity.other.attribute-name.ruko entity.name.method.ruko
      - match: \s*(?<=\:)[\p{Pc}\p{L}]\w*\b\s*
        name: entity.other.attribute-name.ruko entity.name.procedure.ruko
      - match: \s*(?<=\^)[\p{Pc}\p{L}]\w*\b\s*
        name: entity.other.attribute-name.ruko entity.name.property.ruko
      - match: \s*(?<=\?)[\p{Pc}\p{L}]\w*\b\s*
        name: entity.other.attribute-name.ruko entity.name.predicate.ruko

  # Comments

  comments:
    patterns:
      - include: '#block-comments'
      - include: '#line-comments'
      - include: '#nested-comments'

  block-comments:
    patterns:
      - begin: \s*(/\*\*)(?![\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]+)
        end: \s*(\*/)
        name: comment.block.documentation.ruko
        captures:
          1: {name: punctuation.definition.comment.ruko}
        patterns:
          - include: '#jsdoc'
          - include: text.html.markdown#inline
          - include: '#nested-jsdoc'
      - begin: \s*(/\*)(?![\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]+)
        end: \s*(\*/)
        name: comment.block.ruko
        captures:
          1: {name: punctuation.definition.comment.ruko}
        patterns:
          - include: text.html.markdown#inline
          - include: '#nested-block'

  line-comments:
    patterns:
      - begin: \s*(///)(?![\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]+)
        end: \s*$
        name: comment.line.documentation.ruko
        captures:
          1: {name: punctuation.definition.comment.ruko}
        patterns:
          - include: '#jsdoc'
          - include: text.html.markdown#inline
      - begin: \s*(//)(?![\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]+)
        end: \s*$
        name: comment.line.number-sign.ruko
        captures:
          1: {name: punctuation.definition.comment.ruko}
        patterns:
          - include: text.html.markdown#inline

  nested-jsdoc:
    begin: (/\*\*?)(?![\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]+)
    end: \s*(\*/)
    name: comment.block.documentation.nested.ruko
    captures:
      1: {name: punctuation.definition.comment.ruko}
    patterns:
      - include: '#jsdoc'
      - include: text.html.markdown#inline
      - include: '#nested-jsdoc'

  nested-block:
    begin: (/\*)(?![\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]+)
    end: \s*(\*/)
    name: comment.block.nested.ruko
    captures:
      1: {name: punctuation.definition.comment.ruko}
    patterns:
      - include: text.html.markdown#inline
      - include: '#nested-block'

  # JSDoc

  jsdoc:
    patterns:
      - include: '#jsdoc-inline-tags'
      - include: '#jsdoc-access'
      - include: '#jsdoc-as-name-path'
      - include: '#jsdoc-simple'
      - include: '#jsdoc-simple-name-path'
      - include: '#jsdoc-module'
      - include: '#jsdoc-type-name'
      - include: '#jsdoc-type-no-name'
      - comment: additional jsdoc V2 keywords
        match: (?<!\w)@(add|api|body|codeend|codestart|demo|download|group|hide|iframe|image|inherits|option|outline|page|parent|signature|tag)\b
        name: storage.type.class.jsdoc
      - comment: additional jsdoc keywords
        match: (?<!\w)@(accessor|alternateClassName|aside|cfg|chainable|docauthor|evented|experimental|ftype|hide|inheritable|localdoc|markdown|mixins|new|override|preventable|ptype|removed|scss mixin|object|template|uses|xtype)\b
        name: storage.type.class.jsdoc

  jsdoc-access:
    comment: '@tag protected....'
    match: (@(access))\s*(private|protected|public)?(?=\s|$)
    captures:
      1: {name: storage.type.class.jsdoc}
      3: {name: storage.modifier.jsdoc}

  jsdoc-module:
    comment: '@tag {optional type} module:file'
    begin: (@(exports|module|listens|requires)\b)\s*(?=({(?:(?>(?:[^\\{}]|\\.)+)|\g<-1>)*\})?\s*(\S*)([\S\s]*))
    end: ^|(?=\*/)|(?=\5$)
    beginCaptures:
      1: {name: storage.type.class.jsdoc}
    patterns:
      - include: '#jsdoc-typedef-scopes'
      - match: (?:(module)(:))?(((?!\*/)\S)+)
        captures:
          1: {name: keyword.module.jsdoc}
          2: {name: punctuation.jsdoc}
          3: {name: string.modulename.jsdoc}

  jsdoc-as-name-path:
    comment: to terminate the block
    begin: (@(borrows|lends)\b)\s*(?=(?!\*/)\S+(?:(?:\s*\bas\b\s*(?!\*/)\S+)?)?([\S\s]*))
    end: ^|(?=\*/)|(?=\3$)
    beginCaptures:
      1: {name: storage.type.class.jsdoc}
    patterns:
      - include: '#jsdoc-name-path-scopes'

  jsdoc-simple:
    comment: '@tag'
    match: (@(abs|author|classdesc|copyright|default|defaultvalue|deprecated|description|desc|example|external|fileoverview|file|global|host|ignore|inheritdoc|inner|instance|license|override|overview|readonly|see|since|stat|summary|todo|tutorial|virtual|variation|version)\b)(?=$|\s)
    captures:
      1: {name: storage.type.class.jsdoc}

  jsdoc-simple-name-path:
    comment: '@tag {opt type} Class#xxx or Class#Event:aaaa etc'
    begin: (@(alias|augments|callback|extends|emits|event|fires|impl|memberof|mixes|name|property|property|this|typedef)\b)\s*(?=({(?:(?>(?:[^\\{}]|\\.)+)|\g<-1>)*\})?\s*\S*([\S*\s]*))
    end: ^|(?=\*/)|(?=\4$)
    beginCaptures:
      1: {name: storage.type.class.jsdoc}
    patterns:
      - include: '#jsdoc-typedef-scopes'
      - include: '#jsdoc-name-path-scopes'

  jsdoc-type-name:
    comment: '@tag {optional type} name'
    begin: (@(arg|argument|class|constant|constructor|constructs|const|function|fn|kind|member|method|mixin|actor|param|var)\b)\s*(?=({(?:(?>(?:[^\\{}]|\\.)+)|\g<-1>)*\})?\s*(((\[(?:(?>[^\[\]]+)|\g<-1>)*\])|\S)+)?([\S\s]*))
    end: ^|(?=\*/)|(?=\7$)
    beginCaptures:
      1: {name: storage.type.class.jsdoc}
    patterns:
      - include: '#jsdoc-typedef-scopes'
      - include: '#jsdoc-name-scopes'

  jsdoc-type-no-name:
    comment: '@tag {types}'
    begin: (@(enum|exception|implements|private|protected|public|returns|return|throws|type)\b)\s*(?=({(?:(?>(?:[^\\{}]|\\.)+)|\g<-1>)*\})?\s*([\S\s]*))
    end: ^|(?=\*/)|(?=\4$)
    beginCaptures:
      1: {name: storage.type.class.jsdoc}
    patterns:
      - include: '#jsdoc-typedef-scopes'

  jsdoc-inline-tags:
    name: meta.tag.inline.jsdoc
    begin: (\[(?:(?>[^\[\]]+)|\g<-1>)*\])?({)(?=@)
    end: \s*(})
    beginCaptures:
      1: {name: string.linktext.jsdoc}
      2: {name: meta.brace.curly.jsdoc}
    endCaptures:
      1: {name: meta.brace.curly.jsdoc}
    patterns:
      - match: (@(link|tutorial))\b([^}]*)
        captures:
          1: {name: storage.type.class.jsdoc}
          3: {name: string.jsdoc}

  jsdoc-typedef-scopes:
    name: entity.name.type.instance.jsdoc
    begin: '{'
    end: '}|^'
    captures:
      0: {name: meta.brace.curly.jsdoc}
    patterns:
      - include: '#jsdoc-typedef-primitives'
      - include: '#jsdoc-name-path-scopes'
      - include: '#jsdoc-typedef-obj'

  jsdoc-typedef-primitives:
    match: \b(null|undefined|boolean|string|number)\b
    captures:
      1: {name: support.type.builtin.primitive.jsdoc}

  jsdoc-typedef-obj:
    comment: typedef object
    begin: '{'
    end: '}|^'
    captures:
      0: {name: meta.brace.curly.jsdoc}
    patterns:
      - include: '#jsdoc-typedef-primitives'
      - match: \b([\p{Pc}\p{L}]\w*)\b\s*(:)
        captures:
          1: {name: variable.other.readwrite.jsdoc}
      - include: '#jsdoc-name-path-scopes'
      - include: '#jsdoc-typedef-obj'

  jsdoc-name-scopes:
    patterns:
      - match: ((?!\*/)[\S&&[^\[\]"']])+
        captures:
          0: {name: variable.other.jsdoc}
      - name: variable.other.jsdoc
        begin: \[
        end: \]|^
        patterns:
          - include: '#jsdoc-string'
          - include: '#jsdoc-name-scopes'

  jsdoc-name-path-scopes:
    patterns:
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(as)\b\s*(?=[\p{Pc}\p{L}])
        captures:
          1: {name: keyword.as.jsdoc}
      - match: \s*(?:([\p{Pc}\p{L}&&\P{Ll}]+\w*)|([\p{Pc}\p{L}]\w*))(?=[\s\-~.#]|$)
        captures:
          1: {name: entity.name.class.jsdoc}
          2: {name: entity.name.function.jsdoc}
      - match: (\.)([\p{Pc}\p{L}]\w*)\b(?=\s|$|\")
        captures:
          1: {name: keyword.operator.accessor.jsdoc}
          2: {name: entity.name.function.method.stat.jsdoc}
      - match: (\#)([\p{Pc}\p{L}]\w*)\b(?=\s|$|\")
        captures:
          1: {name: keyword.operator.accessor.jsdoc}
          2: {name: entity.name.function.method.instance.jsdoc}
      - match: (~|-)([\p{Pc}\p{L}]\w*)\b(?=\s|$|\")
        captures:
          1: {name: keyword.operator.accessor.jsdoc}
          2: {name: entity.name.function.method.inner.jsdoc}
      - match: (\#)(event)(:)
        captures:
          1: {name: keyword.operator.accessor.jsdoc}
          2: {name: keyword.event.jsdoc}
          3: {name: keyword.operator.jsdoc}
      - name: string.method.jsdoc
        begin: \.(?="|')
        end: (?=.)
        applyEndPatternLast: true
        patterns:
          - include: '#jsdoc-string'

  jsdoc-string:
    name: string.jsdoc
    match: \"(\\"|[^"])*"|'(\\'|[^'])*'

  # Function and method calls

  sigil-function-calls:
    name: meta.function.arguments.ruko
    match: |
      (?x)
      \b
      (
        (?:
          \b
          [\p{Pc}\p{L}]\w* # identifier
          \b
          (?:[!?]?\.=?|[?!:]:=?|[?!-]>=?) # qualified name separator
        )*
        [\p{Pc}\p{L}]\w* # last part of identifier
      )
      \b
      (?=
        \s*
        (?: # function application, composition and piping
            (?: [$@] | <\|+ | <!+ | <[-+]) ['"`({\[\w\s]
          | # C-style function call
            (?:[?!:]:=?|[?!]?\.=?|[?!-]>=?)? \#? [({]
          | # generics
            (?:[?!:]:=?|[?!]?\.=?|[?!-]>=?)? < [\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]* ['"`({\[\w]
          | # macro calls
            ! \#? [({]
          | # strings and symbols
            (?:\w*|[\\$#%]*)['"] | `\s*(?=\N) | :[\p{Pc}\p{L}]\w*
        )
      )
    captures:
      1: {patterns: [include: '#function-names']}

  function-calls:
    patterns:
      - name: meta.function.arguments.ruko
        match: |
          (?x)
          \b
          (
            # ignore all keywords
            (?!
              (?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b
              (?: # keywords
                [io]n|of|[ai]s|has|old|new|del
                |unset|ref|and|x?or|not
                |const|let|mut|dyn
                |va[rl]|use|given|state
                |func|proc|prop|type|class|actor
                |impl|enum|module|struct|record
                |union|iter|macro|query|elem|temp
                |object|realm|trait|style|script|quote
                |go|defer|do|with|from|where
                |if|else|then|guard|when
                |for|loop|while|goto|move
                |try|throw|catch|switch
                |match|case|pass|def
                |break|skip|redo|retry
                |return|yield|await|scope
                |import|export|intern|extern
                |debug|assert|check|decl
              )
              \b
            )
            (?:
              \b
              [\p{Pc}\p{L}]\w* # identifier
              \b
              (?:[!?]?\.=?|[?!:]:=?|[?!-]>=?) # qualified name separator
            )*
            [\p{Pc}\p{L}]\w* # last part of identifier
          )
          \b
          (?=
            (?: # function application, composition and piping
                \s (?: [$@] | <\|+ | <!+ | <[-+]) ['"`({\[\w\s]
              | # C-style function call
                (?:[?!:]:=?|[?!]?\.=?|[?!-]>=?)? \#? [({]
              | # generics
                (?:[?!:]:=?|[?!]?\.=?|[?!-]>=?)? < [\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]* ['"`({\[\w]
              | # macro calls
                ! \#? [({]
              | # strings
                (?:\w*|[\\$#%]*)['"] | `\s*(?=\N) | :[\p{Pc}\p{L}]\w*
            )
          )
        captures:
          1: {patterns: [include: '#function-names']}
      - name: meta.function.arguments.ruko
        match: |
          (?x)
          (?<=
            \s* # opening
            (?: \|+> | !+> | \+>) # operator
            \s*
          )
          \b
          (
            # ignore all keywords
            (?!
              (?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b
              (?: # keywords
                [io]n|of|[ai]s|has|old|new|del
                |unset|ref|and|x?or|not
                |const|let|mut|dyn
                |va[rl]|use|given|state
                |func|proc|prop|type|class|actor
                |impl|enum|module|struct|record
                |union|iter|macro|query|elem|temp
                |object|realm|trait|style|script|quote
                |go|defer|do|with|from|where
                |if|else|then|guard|when
                |for|loop|while|goto|move
                |try|throw|catch|switch
                |match|case|pass|def
                |break|skip|redo|retry
                |return|yield|await|scope
                |import|export|intern|extern
                |debug|assert|check|decl
              )
              \b
            )
            (?:
              \b
              [\p{Pc}\p{L}]\w* # identifier
              \b
              (?:[!?]?\.=?|[?!:]:=?|[?!-]>=?) # qualified name separator
            )*
            [\p{Pc}\p{L}]\w* # last part of identifier
          )
          \b
        captures:
          1: {patterns: [include: '#function-names']}

  embedded-function-calls:
    name: meta.function.name.ruko
    match: |
      (?x)
      (?:
        (?<=(?:^|[,;'"`(){}\[\]\w\s]|\\.)(?:[!?]?\.=?|[?!:]:=?|[?!-]>=?)) \b
          (?: # Properties
            # Leading underscore
            (\p{Pc}+\w*\b(?!\p{Pc}+))
          | # Train case
            ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)
          | # Pascal case
            ((?:[\p{Pc}\p{L}&&\P{Ll}][\w&&\P{Lu}]*)+)
          | # Camel or kebab case
            ([\p{Pc}\p{L}]\w*)
          )
        \b
          (?= # opening bracket
              \#? [({]
            | generics
              [?!:]: < | [?!]?\. < | <
            | # macro calls
              ! \#? [({]
          )
        |
        (?<= ^ # beginning of line
          | ['"`({\[)}\]\w\s] # literal
          (?: # operators
            [\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]+
          )?
        ) \b
          (?: # Regular variables
            # Leading underscore
            (\p{Pc}+\w*\b(?!\p{Pc}+))
          | # Train case
            ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)
          | # Pascal case
            ((?:[\p{Pc}\p{L}&&\P{Ll}][\w&&\P{Lu}]*)+)
          | # Camel or kebab case
            ([\p{Pc}\p{L}]\w*)
          )
        \b
          (?= # opening bracket
              \#? [({]
            | generics
              [?!:]: < | [?!]?\. < | <
            | # macro calls
              ! \#? [({]
          )
      )
    captures:
      1:
        patterns: &builtin-names
          - include: '#type-names'
          - include: '#support-functions'
        name: entity.name.tag.ruko
      2:
        patterns: *builtin-names
        name: entity.name.tag.ruko support.class.component.ruko
      3:
        patterns: *builtin-names
        name: entity.name.class.builtin.ruko
      4:
        patterns: *builtin-names
        name: entity.name.function.member.ruko
      5:
        patterns: *builtin-names
        name: entity.name.function.tagged-template.ruko
      6:
        patterns: *builtin-names
        name: entity.name.type.ruko
      7:
        patterns: *builtin-names
        name: entity.name.class.ruko
      8:
        patterns: *builtin-names
        name: entity.name.function.ruko

  function-names:
    patterns:
      - &function-names
        name: meta.function.name.ruko
        match: |
          (?x)
          (?:
            (?<=(?:^|[,;'"`(){}\[\]\w\s]|\\.)(?:[!?]?\.=?|[?!:]:=?|[?!-]>=?)) \b
              (?: # Properties
                # Leading underscore
                (\p{Pc}+\w*\b(?!\p{Pc}+))
              | # Train case
                ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)
              | # Pascal case
                ((?:[\p{Pc}\p{L}&&\P{Ll}][\w&&\P{Lu}]*)+)
              | # Camel or kebab case
                ([\p{Pc}\p{L}]\w*)
              )
            \b
              (?=
                  $ # end of line
                | (?: # operators
                    <\|{1,3} | <[-+] | \|{1,3}> | \+> | [$@]
                  )?
                  ['"`({\[)}\]\w\s]
              )
            |
            (?<=
              (?: ^ | [,;'"`({\[)}\]\w\s] | \\. ) # literal
              (?: # operators
                [\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]+
              )?
            ) \b
              (?: # Regular variables
                # Leading underscore
                (\p{Pc}+\w*\b(?!\p{Pc}+))
              | # Train case
                ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)
              | # Pascal case
                ((?:[\p{Pc}\p{L}&&\P{Ll}][\w&&\P{Lu}]*)+)
              | # Camel or kebab case
                ([\p{Pc}\p{L}]\w*)
              )
            \b
              (?=
                  $ # end of line
                | (?: # operators
                    <\|{1,3} | <[-+] | \|{1,3}> | \+> | [$@]
                  )?
                  ['"`({\[)}\]\w\s]
              )
          )
        captures:
          1:
            patterns: &builtin-names
              - include: '#type-names'
              - include: '#support-functions'
            name: entity.name.tag.ruko
          2:
            patterns: *builtin-names
            name: entity.name.tag.ruko support.class.component.ruko
          3:
            patterns: *builtin-names
            name: entity.name.class.builtin.ruko
          4:
            patterns: *builtin-names
            name: entity.name.function.member.ruko
          5:
            patterns: *builtin-names
            name: entity.name.function.tagged-template.ruko
          6:
            patterns: *builtin-names
            name: entity.name.type.ruko
          7:
            patterns: *builtin-names
            name: entity.name.class.ruko
          8:
            patterns: *builtin-names
            name: entity.name.function.ruko
      - include: '#variables'
      - include: '#primary-operators'

  # Variables

  parameter-variables:
    patterns:
      - match: |
          (?x)
          (?<=
            (?:
              ^ # SOL
              | (?:^ | [^|]) \| # open pipe
              | [({\[] # open bracket
              | [;,] # separator
              | [(|]\. \s # uncurried function
              | (?:^|[,;'"({\[)}\]|\s])
                \b (?:
                  const|let|mut|dyn
                  |va[rl]|use|given|state
                  |func|proc|prop|type|class|actor
                  |impl|enum|module|struct|record
                  |union|iter|macro|query|elem|temp
                  |object|realm|trait|style|script|quote
                  |given|use|as
                ) \b
                (?:$|[,;'"({\[)}\]\s]) # var/val/as/given/using keyword
            ) \s*
          )

          \s*
          ([\p{P}\p{S}&&[^,;'"`({\[|)}\]\p{Pc}]]*) # any sigils
          (
            \b
            [\p{Pc}\p{L}]\w* # identifier
            \s*\b 
          )*

          \s*
          (\b[\p{Pc}\p{L}]\w*\b) # identifier
          ([\p{P}\p{S}&&[^,;'"`({\[|)}\]\p{Pc}]]*) # any sigils
          \s*

          (?!\|\s*$)
          (?=
            $ # EOL
            | # close bracket or pipe
              \s* [)}\]] | \s* \|:? [\w\s'"`({\[)}\]]
            | # separator
              \s* [;,]
            | # as keyword (aliasing)
              \s*
              (?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(as)\b
              \s*
            | # type specifier and assignment
              (?::|[?:]?=) \s* [\w'"`({\[]
            | \s+ (?::|[?:]?=) \s+ [\w'"`({\[]
          )
        captures:
          1:
            name: keyword.operator.prefix.ruko
            patterns: [include: '#parameter-type-operators']
          2:
            name: storage.type.ruko
            patterns:
              - include: '#declaration-keywords'
              - include: '#modifiers'
          3:
            name: variable.parameter.ruko
            patterns: [include: '#constants']
          4:
            name: keyword.operator.suffix.ruko
            patterns: [include: '#parameter-type-operators']

  placeholder-variables:
    patterns:
      - match: (?i)\s*[?!][\p{Pc}\p{L}]\w*\b\s*
        name: variable.parameter.optional.ruko
      - match: (?i)\s*\*\*?[?!]?[\p{Pc}\p{L}]\w*\b\s*
        name: variable.parameter.spread.ruko
      - match: (?i)\s*~~?[?!]?[\p{Pc}\p{L}]\w*\b\s*
        name: variable.parameter.reference.ruko
      - match: (?i)\s*&[?!]?[\p{Pc}\p{L}]\w*\b\s*
        name: variable.parameter.reference.ruko
      - match: (?i)\s*%[?!]?[\p{Pc}\p{L}]\w*\b\s*
        name: variable.parameter.other.ruko
      - match: (?i)\s*\b[\p{Pc}\p{L}]\w*\b\s*
        name: variable.parameter.ruko

  variables:
    patterns:
      - match: |
          (?x)
          (?<=
            \b # qualified name
              [\p{Pc}\p{L}]\w* # identifier
              (?:(?:[?!]?\.|[?!:]:)=?)
            \b
          )
          (?:\d\w*)
        name: variable.other.index.ruko
      - &variable-name
        comment: |
          Four types of variables:
          - _lead_underscore
          - UPPERCASE
          - PascalCase
          - camelCase
        match: |
          (?x) \b

          (?:
            (?<=(?:^|[,;'"`(){}\[\]\w\s]|\\.)(?:[!?]?\.=?|[?!:]:=?|[?!-]>=?))
            (?: # Properties
                # Leading underscore
                (\p{Pc}+\w*\b(?!\p{Pc}+))
              | # Train case
                ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)
              | # Pascal case
                ((?:[\p{Pc}\p{L}&&\P{Ll}][\w&&\P{Lu}]*)+)
              | # Camel or kebab case
                ([\p{Pc}\p{L}]\w*)
            )
            |
            (?: # Objects
                # Leading underscore
                (\p{Pc}+\w*\b(?!\p{Pc}+))
              | # Train case
                ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)
              | # Pascal case
                ((?:[\p{Pc}\p{L}&&\P{Ll}][\w&&\P{Lu}]*)+)
              | # Camel or kebab case
                ([\p{Pc}\p{L}]\w*)
            )
            (?=(?:[!?]?\.=?|[?!:]:=?|[?!-]>=?|\s*\#?\[)(?:[,;'"`(){}\[\]\w\s]|$))
            |
            (?: # Regular variables
                # Leading underscore
                (\p{Pc}+\w*\b(?!\p{Pc}+))
              | # Train case
                ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)
              | # Pascal case
                ((?:[\p{Pc}\p{L}&&\P{Ll}][\w&&\P{Lu}]*)+)
              | # Camel or kebab case
                ([\p{Pc}\p{L}]\w*)
            )
          ) \b
        captures:
          1: {name: variable.other.property.dynamic.ruko}
          2: {name: variable.other.constant.property.ruko}
          3: {name: variable.other.property.stat.ruko}
          4: {name: variable.other.property.ruko}
          5: {name: variable.other.global.ruko}
          6: {name: variable.other.constant.object.ruko}
          7: {name: variable.other.class.stat.ruko}
          8: {name: variable.other.object.ruko}
          9: {name: variable.other.dollar.ruko}
          10: {name: variable.other.constant.ruko}
          11: {name: variable.other.class.ruko}
          12: {name: variable.other.readwrite.ruko}

  # Operators

  operators:
    patterns:
      - include: '#special-operators'
      - include: '#infix-operators'
      - include: '#primary-operators'
      - include: '#suffix-operators'
      - include: '#prefix-operators'

  special-operators:
    patterns:
      - match: (?<=>|\w)(!)(?=#?[({])
        captures:
          1: {name: keyword.operator.macro.ruko}
      - comment: '? ternary operator'
        begin: (?<=^|[\s({\[])(\?)(?=$|[)}\]\s])|(?<=['"`)}\]\w]|\\.)(\?)(?=['"`({\[\w])
        end: (?<=^|[\s({\[])(\:)(?=$|[)}\]\s])|(?<=['"`)}\]\w]|\\.)(\:)(?=['"`({\[\w])
        captures:
          1: {name: keyword.operator.conditional.ruko}
          2: {name: keyword.operator.conditional.ruko}
        patterns:
          - include: $self
      - comment: '! ternary operator'
        begin: (?<=^|[\s({\[])(\!)(?=$|[)}\]\s])|(?<=['"`)}\]\w]|\\.)(\!)(?=['"`({\[\w])
        end: (?<=^|[\s({\[])(\:)(?=$|[)}\]\s])|(?<=['"`)}\]\w]|\\.)(\:)(?=['"`({\[\w])
        captures:
          1: {name: keyword.operator.ternary.ruko}
          2: {name: keyword.operator.ternary.ruko}
        patterns:
          - include: $self

  infix-operators:
    name: keyword.operator.infix.ruko
    match: |
      (?xi)
      (?<=^|[\s({\[]) # opening
      (?:
        ( # 1: optional access/unwrap
        \?[.:>]=?
        ) |
        ( # 2: assert/unwrap operator
          ![.:>]=?
        ) |
        ( # 3: access operator
          (?:::|\.|->)=?
        ) |
        ( # 4: compound assignment operators
          # all operators except ~ < = > . : !
          [\p{P}\p{S}&&[^~<=>.,:;!'"`({\[)}\]\p{Pc}]]
          # operator character
          [\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]*
          = # ending equal sign
        ) |
        ( # 5: arithmetic operator
          [+-][\%\|]? | \*{1,3}[\%\|]? | ~?/ | %%?
        ) |
        ( # 6: string/regex/array/set
          \+\+ | \-\-
        ) |
        ( # 7: logical operator
          \&\& | \|\| | \^\^ | ! | /\\ | \\/
        ) |
        ( # 8: bitwise and set
          \& | \| | \^ | ~
        ) |
        ( # 9: bitwise shift/rotate
          <<[<>]? | [<>]?>>
        ) |
        ( # 10: pipeline
          <\|+ | \|+> | !+> | <!+
        ) |
        ( # 11: composition
          <\+ | \+>
        ) |
        ( # 12: membership
          [<>][:!] | [:!][<>]
        ) |
        ( # 13: comparison
          < | > | <= | >= | <> | <=>
        ) |
        ( # 14: equality
          == | != | === | !==
        ) |
        ( # 15: similarity
          ~[=!] | [=!]~ | =< | ><
        ) |
        ( # 16: functional
          <[/*|+$:]> | [/*|+$:]> | <[/*|+$:]
        ) |
        ( # 17: null coalescing
          \?+
        ) |
        ( # 18: non null coalescing
          !+
        ) |
        ( # 19: falsy coalescing
          \?:
        ) |
        ( # 20: truthy coalescing
          !:
        ) |
        ( # 21: function application
          [.$]
        ) |
        ( # 22: assignment
          :?=
        ) |
        ( # 23: range
          [>.]\.[.<] | \.\. | [=.]\.[.=]
        ) |
        ( # 24: double arrow
            =+> # right side
          | <=+ # left side
        ) |
        ( # 25: single arrow
            -+> # right side
          | <-+ # left side
        ) |
        ( # 26: wavy arrow
            ~+> # right side
          | <~+ # left side
        ) |
        ( # 27: custom logical
          [&|^~] # leading chars
          [\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]+
        ) |
        ( # 28: custom arithmetic
          [-+*/%] # leading chars
          [\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]+
        ) |
        ( # 29: custom prototype
          [@:] # leading chars
          [\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]+
        ) |
        ( # 30: custom accessor
          [.] # leading chars
          [\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]+
        ) |
        ( # 31: custom comparison
          [=!] # leading chars
          [\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]+
        ) |
        ( # 32: custom relational
          [<>] # leading chars
          [\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]+
        ) |
        ( # 33: custom private
          [?\#] # leading chars
          [\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]+
        ) |
        ( # 34: custom math
          \p{Sm} # leading chars
          [\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]+
        ) |
        ( # 35: custom currency
          \p{Sc} # leading chars
          [\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]+
        ) |
        ( # 36: custom ascii
          [\p{P}\p{S}&&[\x80-\xFF]] # leading chars
          [\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]+
        ) |
        ( # 37: catch all
          [\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]+
        )
      )
      (?=$|[)}\]\s]) # closing
    captures:
      1: {name: keyword.operator.optional.ruko}
      2: {name: keyword.operator.assert.ruko}
      3: {name: keyword.operator.accessor.ruko}
      4: {name: keyword.operator.assignment.augmented.ruko}
      5: {name: keyword.operator.arithmetic.ruko}
      6: {name: keyword.operator.successor.ruko}
      7: {name: keyword.operator.logical.ruko}
      8: {name: keyword.operator.bitwise.ruko}
      9: {name: keyword.operator.bitwise.shift.ruko}
      10: {name: keyword.operator.pipeline.ruko}
      11: {name: keyword.operator.compose.ruko}
      12: {name: keyword.operator.class.ruko}
      13: {name: keyword.operator.relational.ruko}
      14: {name: keyword.operator.comparison.ruko}
      15: {name: keyword.operator.similarity.ruko}
      16: {name: keyword.operator.function.ruko}
      17: {name: keyword.operator.null-coalescing.ruko}
      18: {name: keyword.operator.coalescing.ruko}
      19: {name: keyword.operator.conditional.ruko}
      20: {name: keyword.operator.ternary.ruko}
      21: {name: keyword.operator.macro.ruko}
      22: {name: keyword.operator.assignment.ruko}
      23: {name: keyword.operator.range.ruko}
      24: {name: keyword.operator.arrow.double.ruko}
      25: {name: keyword.operator.arrow.single.ruko}
      26: {name: keyword.operator.arrow.wavy.ruko}
      27: {name: keyword.operator.logical.custom.ruko}
      28: {name: keyword.operator.arithmetic.custom.ruko}
      29: {name: keyword.operator.prototype.custom.ruko}
      30: {name: keyword.operator.accessor.custom.ruko}
      31: {name: keyword.operator.comparison.custom.ruko}
      32: {name: keyword.operator.relational.custom.ruko}
      33: {name: keyword.operator.private.custom.ruko}
      34: {name: keyword.operator.math.custom.ruko}
      35: {name: keyword.operator.currency.custom.ruko}
      36: {name: keyword.operator.ascii.custom.ruko}
      37: {name: keyword.operator.primary.ruko}

  primary-operators:
    name: keyword.operator.primary.ruko
    match: |
      (?x)
      (?<=['"`)}\]\w]|\\.) # closing
      (?:
        ( # 1: optional access/unwrap
        \?[.:>]=?
        ) |
        ( # 2: assert/unwrap operator
          ![.:>]=?
        ) |
        ( # 3: access operator
          (?:::|\.|->)=?
        ) |
        ( # 4: compound assignment operators
          # all operators except ~ < = > . : !
          [\p{P}\p{S}&&[^~<=>.,:;!'"`({\[)}\]\p{Pc}]]
          # operator character
          [\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]*
          = # ending equal sign
        ) |
        ( # 5: arithmetic operator
          [+-][\%\|]? | \*{1,3}[\%\|]? | ~?/ | %%?
        ) |
        ( # 6: string/regex/array/set
          \+\+ | \-\-
        ) |
        ( # 7: logical operator
          \&\& | \|\| | \^\^ | ! | /\\ | \\/
        ) |
        ( # 8: bitwise and set
          \& | \| | \^ | ~
        ) |
        ( # 9: bitwise shift/rotate
          <<[<>]? | [<>]?>>
        ) |
        ( # 10: pipeline
          <\|+ | \|+> | !+> | <!+
        ) |
        ( # 11: composition
          <\+ | \+>
        ) |
        ( # 12: membership
          [<>][:!] | [:!][<>]
        ) |
        ( # 13: comparison
          < | > | <= | >= | <> | <=>
        ) |
        ( # 14: equality
          == | != | === | !==
        ) |
        ( # 15: similarity
          ~[=!] | [=!]~ | =< | ><
        ) |
        ( # 16: functional
          <[/*|+$:]> | [/*|+$:]> | <[/*|+$:]
        ) |
        ( # 17: null coalescing
          \?+
        ) |
        ( # 18: non null coalescing
          !+
        ) |
        ( # 19: falsy coalescing
          \?:
        ) |
        ( # 20: truthy coalescing
          !:
        ) |
        ( # 21: function application
          [.$]
        ) |
        ( # 22: assignment
          :?=
        ) |
        ( # 23: range
          [>.]\.[.<] | \.\. | [=.]\.[.=]
        ) |
        ( # 24: double arrow
            =+> # right side
          | <=+ # left side
        ) |
        ( # 25: single arrow
            -+> # right side
          | <-+ # left side
        ) |
        ( # 26: wavy arrow
            ~+> # right side
          | <~+ # left side
        ) |
        ( # 27: custom logical
          [&|^~] # leading chars
          [\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]+
        ) |
        ( # 28: custom arithmetic
          [-+*/%] # leading chars
          [\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]+
        ) |
        ( # 29: custom prototype
          [@:] # leading chars
          [\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]+
        ) |
        ( # 30: custom accessor
          [.] # leading chars
          [\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]+
        ) |
        ( # 31: custom comparison
          [=!] # leading chars
          [\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]+
        ) |
        ( # 32: custom relational
          [<>] # leading chars
          [\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]+
        ) |
        ( # 33: custom private
          [?\#] # leading chars
          [\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]+
        ) |
        ( # 34: custom math
          \p{Sm} # leading chars
          [\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]+
        ) |
        ( # 35: custom currency
          \p{Sc} # leading chars
          [\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]+
        ) |
        ( # 36: custom ascii
          [\p{P}\p{S}&&[\x80-\xFF]] # leading chars
          [\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]+
        ) |
        ( # 37: catch all
          [\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]+
        )
      )
      (?=['"`({\[\w]) # opening
    captures:
      1: {name: keyword.operator.optional.ruko}
      2: {name: keyword.operator.assert.ruko}
      3: {name: keyword.operator.accessor.ruko}
      4: {name: keyword.operator.assignment.augmented.ruko}
      5: {name: keyword.operator.arithmetic.ruko}
      6: {name: keyword.operator.successor.ruko}
      7: {name: keyword.operator.logical.ruko}
      8: {name: keyword.operator.bitwise.ruko}
      9: {name: keyword.operator.bitwise.shift.ruko}
      10: {name: keyword.operator.pipeline.ruko}
      11: {name: keyword.operator.compose.ruko}
      12: {name: keyword.operator.class.ruko}
      13: {name: keyword.operator.relational.ruko}
      14: {name: keyword.operator.comparison.ruko}
      15: {name: keyword.operator.similarity.ruko}
      16: {name: keyword.operator.function.ruko}
      17: {name: keyword.operator.null-coalescing.ruko}
      18: {name: keyword.operator.coalescing.ruko}
      19: {name: keyword.operator.conditional.ruko}
      20: {name: keyword.operator.ternary.ruko}
      21: {name: keyword.operator.macro.ruko}
      22: {name: keyword.operator.assignment.ruko}
      23: {name: keyword.operator.range.ruko}
      24: {name: keyword.operator.arrow.double.ruko}
      25: {name: keyword.operator.arrow.single.ruko}
      26: {name: keyword.operator.arrow.wavy.ruko}
      27: {name: keyword.operator.logical.custom.ruko}
      28: {name: keyword.operator.arithmetic.custom.ruko}
      29: {name: keyword.operator.prototype.custom.ruko}
      30: {name: keyword.operator.accessor.custom.ruko}
      31: {name: keyword.operator.comparison.custom.ruko}
      32: {name: keyword.operator.relational.custom.ruko}
      33: {name: keyword.operator.private.custom.ruko}
      34: {name: keyword.operator.math.custom.ruko}
      35: {name: keyword.operator.currency.custom.ruko}
      36: {name: keyword.operator.ascii.custom.ruko}
      37: {name: keyword.operator.primary.ruko}

  prefix-operators:
    comment: Prefix operators
    match: |
      (?x)
      (?:
        (\*) # 1
        |(\/) # 2
        |(\+) # 3
        |(\-) # 4
        |(\&) # 5
        |(\|) # 6
        |(\^) # 7
        |(\!) # 8
        |(\$) # 9
        |(\@) # 10
        |(\~) # 11
        |(\?) # 12
        |(\=) # 13
        |(\$) # 14
        |(\#) # 15
        |(\%) # 16
        |[\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]
      ) # 17
      (?=[\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]*
      ['"`({\[\w])
    name: keyword.operator.prefix.ruko
    captures:
      1: {name: keyword.operator.pointer.ruko}
      2: {name: keyword.operator.spread.ruko}
      3: {name: keyword.operator.increment.ruko}
      4: {name: keyword.operator.decrement.ruko}
      5: {name: keyword.operator.reference.ruko}
      6: {name: keyword.operator.union.ruko}
      7: {name: keyword.operator.symmetric.ruko}
      8: {name: keyword.operator.logical.ruko}
      9: {name: keyword.operator.private.ruko}
      10: {name: keyword.operator.decorator.ruko}
      11: {name: keyword.operator.bitwise.not.ruko}
      12: {name: keyword.operator.existential.ruko}
      13: {name: keyword.operator.assignment.ruko}
      14: {name: keyword.operator.pipeline.ruko}
      15: {name: keyword.operator.private.ruko}
      16: {name: keyword.operator.format.ruko}
      17: {name: keyword.operator.prefix.ruko}

  suffix-operators:
    comment: Suffix operators
    match: |
      (?x)
      (?<=(?:['"`)}\]\w]|\\.)
        [\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]*)
      (?:
        (\*) # 1
        |(\/) # 2
        |(\+) # 3
        |(\-) # 4
        |(\&) # 5
        |(\|) # 6
        |(\^) # 7
        |(\!) # 8
        |(\$) # 9
        |(\@) # 10
        |(\~) # 11
        |(\?) # 12
        |(\=) # 13
        |(\$) # 14
        |(\#) # 15
        |(\%) # 16
        |[\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]
      ) # 17
    name: keyword.operator.suffix.ruko
    captures:
      1: {name: keyword.operator.pointer.ruko}
      2: {name: keyword.operator.quotient.ruko}
      3: {name: keyword.operator.increment.ruko}
      4: {name: keyword.operator.decrement.ruko}
      5: {name: keyword.operator.reference.ruko}
      6: {name: keyword.operator.union.ruko}
      7: {name: keyword.operator.symmetric.ruko}
      8: {name: keyword.operator.logical.ruko}
      9: {name: keyword.operator.private.ruko}
      10: {name: keyword.operator.decorator.ruko}
      11: {name: keyword.operator.spread.ruko}
      12: {name: keyword.operator.existential.ruko}
      13: {name: keyword.operator.assignment.ruko}
      14: {name: keyword.operator.pipeline.ruko}
      15: {name: keyword.operator.private.ruko}
      16: {name: keyword.operator.format.ruko}
      17: {name: keyword.operator.suffix.ruko}

  # Clauses and Keywords

  parameter-brackets:
    begin: (\()\s*
    end: \s*(\))
    captures:
      1: {name: punctuation.definition.parameters.ruko}
    patterns:
      - include: '#binding-pattern'
      - include: $self

  modifier-keywords:
    name: storage.modifier.ruko
    match: |
      (?x)
      (
        (?:
          (?:
            \s*
            (?<!(?:(?<!\.)\.|[?!:]:)=?)
            \b
              [\p{Pc}\p{L}]\w*
            )
            \b
          \s*
        )*
      )
      (?=
        \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b
        (?:
          const|let|mut|dyn
          |va[rl]|use|given|state
          |func|proc|prop|type|class|actor
          |impl|enum|module|struct|record
          |union|iter|macro|query|elem|temp
          |object|realm|trait|style|script|quote
          |import|export|intern|extern
        )
        \b\s*
      )
    captures:
      1: {patterns: [include: '#modifiers']}

  type-modifiers:
    patterns:
      - name: storage.modifier.ruko
        match: |
          (?x)
          \s*\b
          (
            # ignore all keywords
            (?!
              (?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b
              (?: # keywords
                [io]n|of|[ai]s|has|old|new|del
                |unset|ref|and|x?or|not
                |const|let|mut|dyn
                |va[rl]|use|given|state
                |func|proc|prop|type|class|actor
                |impl|enum|module|struct|record
                |union|iter|macro|query|elem|temp
                |object|realm|trait|style|script|quote
                |go|defer|do|with|from|where
                |if|else|then|guard|when
                |for|loop|while|goto|move
                |try|throw|catch|switch
                |match|case|pass|def
                |break|skip|redo|retry
                |return|yield|await|scope
                |import|export|intern|extern
                |debug|assert|check|decl
              )
              \b
            )
            [\p{Pc}\p{L}]\w* # identifier
          )
          \b\s*
          (?=
            (?!
              (?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b
              (?: # keywords
                [io]n|of|[ai]s|has|old|new|del
                |unset|ref|and|x?or|not
                |const|let|mut|dyn
                |va[rl]|use|given|state
                |func|proc|prop|type|class|actor
                |impl|enum|module|struct|record
                |union|iter|macro|query|elem|temp
                |object|realm|trait|style|script|quote
                |go|defer|do|with|from|where
                |if|else|then|guard|when
                |for|loop|while|goto|move
                |try|throw|catch|switch
                |match|case|pass|def
                |break|skip|redo|retry
                |return|yield|await|scope
                |import|export|intern|extern
                |debug|assert|check|decl
              )
              \b
            )
            [\p{Pc}\p{L}]\w*
          )
        captures:
          1: {patterns: [include: '#modifiers']}

  modifiers:
    patterns:
      - comment: Visibility modifiers
        match: |
          (?x)\s*\b
          (?:
            pub|priv|prot|final|read|write|over
            |global|local|intern|extern|mut|immut
            |post|[gs]et|put|del|req|opt|shared|stable
            |(?:un)?safe|virt|seal|abst|friend|enemy
          ) \b\s*
        name: storage.modifier.ruko
      - comment: Visibility modifiers
        match: |
          (?x)\s*\b
          (?:
            in|out|inout|inplace|ref|defer|a?sync
            |stat|dyn|lazy|eager|bound|free|unique
            |union|open|closed?
          ) \b\s*
        name: storage.modifier.declaration.ruko
      - comment: Functional modifiers
        match: |
          (?x)\s*\b
          (?:
            rec|oper|curry|opaque|inline|prefix
            |infix|suffix|unary|left|right
          )\b\s*
        name: storage.modifier.function.ruko
      - include: '#expression-keywords'
      - comment: Custom modifiers
        match: \s*\b([\p{Pc}\p{L}]\w*)\b\s*
        name: storage.type.property.ruko

  declaration-keywords:
    patterns:
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(decl)\b\s*
        name: keyword.other.declare.ruko
      - match: |
          (?x)
          \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(
            const|let|mut|dyn
            |va[rl]|use|given|state
          )\b\s*
        name: storage.type.ruko
      - match: |
          (?x)
          \s*
            (?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b
            (
              func|proc|prop|type|class|actor
              |impl|enum|module|struct|record
              |union|iter|macro|query|elem|temp
              |object|realm|trait|style|script|quote
            )
            \b
          \s*
        name: storage.type.$1.ruko

  general-keywords:
    comment: general keywords
    patterns:
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(if|else|guard|when)\b\s*
        name: keyword.control.conditional.ruko
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(for|loop|while)\b\s*
        name: keyword.control.loop.ruko
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(try|throw|catch|then)\b\s*
        name: keyword.control.trycatch.ruko
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(switch|case|def)\b\s*
        name: keyword.control.switch.ruko
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(match)\b\s*
        name: keyword.control.match.ruko
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(break|skip|redo|retry|return|await|scope|yield|goto|move|pass)\b\s*
        name: keyword.control.flow.ruko
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(import|export|intern|extern)\b\s*
        name: keyword.control.module.ruko
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(with|do|from|ref|go|defer)\b\s*
        name: keyword.control.$1.ruko
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(debug|assert|check|decl|where)\b\s*
        name: keyword.other.$1.ruko

  expression-keywords:
    comment: expression keywords
    patterns:
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(as|old|new)\b\s*
        name: keyword.operator.expression.$1.ruko
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(not\s+)?([io]n|of)\b\s*
        name: keyword.operator.expression.$2.ruko
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(is\s+not|is)\b\s*
        name: keyword.operator.expression.is.ruko
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(delete)\b\s*
        name: keyword.operator.expression.delete.ruko
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(unset)\b\s*
        name: keyword.operator.expression.void.ruko
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(and|x?or|not)\b\s*
        name: keyword.operator.expression.logical.ruko

  keywords:
    patterns:
      - include: '#module-expression'
      - include: '#control-expression'
      - include: '#query-expression'
      - include: '#constraint-expression'
      - include: '#intern-extern-expression'
      - include: '#modifier-keywords'
      - include: '#declaration-keywords'
      - include: '#expression-keywords'
      - include: '#general-keywords'

  control-expression:
    applyEndPatternLast: true
    begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(break|skip|redo|retry|scope|goto|move|pass)\b\s*
    end: (?=)|$
    beginCaptures:
      1: {name: keyword.control.flow.ruko}
    patterns:
      - match: *entity-name
        name: constant.other.label.ruko

  intern-extern-expression:
    applyEndPatternLast: true
    begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(intern|extern)\b\s*
    end: (?=)|$
    beginCaptures:
      1: {name: keyword.control.module.ruko}
    patterns:
      - match: *entity-name
        name: constant.other.label.ruko

  module-expression:
    patterns:
      - applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(import|export)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: keyword.control.module.ruko}
        patterns:
          - include: '#module-content'
          - include: '#intern-extern-expression'

    repository:
      module-content:
        patterns:
          - begin: ({)\s*
            end: \s*(})
            captures:
              1: {name: punctuation.definition.block.ruko}
            patterns:
              - include: '#module-content'
              - include: '#intern-extern-expression'
              - include: $self
          - include: '#strings'
          - include: '#regexps'
          - include: '#symbols'
          - include: '#comments'
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(as)\b\s*
            name: keyword.control.module.ruko
          - include: '#type-operators'
          - include: '#accessor-operators'
          - match: \s*(?<!:):(?!:)\s*
            name: keyword.operator.alias.ruko
          - include: '#regexp-patterns'
          - include: '#type-keywords'
          - match: \s*(?<!\*)\*(?!\*)\s*
            name: constant.language.import-export-all.js
          - include: '#type-modifiers'
          - include: '#comma'
          - include: '#line-continuation'
          - match: *entity-name
            name: variable.other.readwrite.alias.ruko

  constraint-expression:
    comment: most of the keywords come from Dafny
    begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(where)\b\s*
    beginCaptures:
      1: {name: keyword.control.validate.ruko}
    end: (?=[,;)}\]])
    patterns:
      - match: &constraint-keyword |
          (?x)
          (?<=^|{|;|,)\s*
          (
            \b
            # ignore all keywords
            (?!
              (?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b
              (?: # keywords
                [io]n|of|[ai]s|has|old|new|del
                |unset|ref|and|x?or|not
                |const|let|mut|dyn
                |va[rl]|use|given|state
                |func|proc|prop|type|class|actor
                |impl|enum|module|struct|record
                |union|iter|macro|query|elem|temp
                |object|realm|trait|style|script|quote
                |go|defer|do|with|from|where
                |if|else|then|guard|when
                |for|loop|while|goto|move
                |try|throw|catch|switch
                |match|case|pass|def
                |break|skip|redo|retry
                |return|yield|await|scope
                |import|export|intern|extern
                |debug|assert|check|decl
              )
              \b
            )
            \b
            [\p{Pc}\p{L}]\w* # identifier
            \b
          )
        name: keyword.control.validate.ruko
      - include: $self

  query-expression:
    begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(from)\b\s*
    beginCaptures:
      1: {name: keyword.control.query.ruko}
    end: (?=[,;)}\]])
    patterns:
      - include: '#query-body'
      - include: $self

  query-body:
    patterns:
      - include: '#in-clause'
      - include: '#where-clause'
      - include: '#join-clause'
      - include: '#sort-clause'
      - include: '#select-clause'
      - include: '#group-clause'
      - include: '#limit-clause'
      - include: '#reduce-clause'

    repository:
      in-clause:
        begin: |
          (?x)
          \s*
          (?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b
            (
              [io]n|of
            )
          \b
          \s*
        beginCaptures:
          1: {name: keyword.control.query.ruko}
          2: {patterns: [include: $self]}
          3: {name: keyword.control.query.ruko}
        end: (?=[,;)}\]])
        patterns:
          - include: '#query-body'
          - include: $self

      join-clause:
        begin: |
          (?x)
          \s*
          (?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b
            (
              \b (?:full|part|self|cross)? \b \s*
              \b (?:inner|outer|left|right)? \b \s*
              \b (?:join)
            )
          \b
          \s*
        beginCaptures:
          1: {name: keyword.control.query.ruko}
          2: {patterns: [include: $self]}
          3: {name: keyword.control.query.ruko}
        end: (?=[,;)}\]])
        patterns:
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b([io]nto|equal|[io]n|of)\b\s*
            name: keyword.control.query.ruko
          - include: '#query-body'
          - include: $self

      where-clause:
        begin: |
          (?x)
          \s*
          (?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b
            (
              where|having|filter|reject
            )
          \b
          \s*
        beginCaptures:
          1: {name: keyword.control.query.ruko}
        end: (?=[,;)}\]])
        patterns:
          - include: '#query-body'
          - include: $self

      sort-clause:
        begin: |
          (?x)
          \s*
          (?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b
            (
              \b (?:sort|order|then) \b \s*
              \b (?:asc|desc)? \b \s*
              \b (?:by|with)?
            )
          \b
          \s*
        beginCaptures:
          1: {name: keyword.control.query.ruko}
        end: (?=[,;)}\]])
        patterns:
          - include: '#query-body'
          - include: $self

      select-clause:
        begin: |
          (?x)
          \s*
          (?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b
            (
              \b (?:select|map) \b \s*
              \b (?:unique|any|all|some|every)?
            )
          \b
          \s*
        beginCaptures:
          1: {name: keyword.control.query.ruko}
        end: (?=[,;)}\]])
        patterns:
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(by|while|with)\b\s*
            name: keyword.control.query.ruko
          - include: '#query-body'
          - include: $self

      limit-clause:
        begin: |
          (?x)
          \s*
          (?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b
            (
              \b (?:take|drop|limit|offset) \b \s*
              \b (?:first|last|head|tail)?
            )
          \b
          \s*
        beginCaptures:
          1: {name: keyword.control.query.ruko}
        end: (?=[,;)}\]])
        patterns:
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(by|while|with)\b\s*
            name: keyword.control.query.ruko
          - include: '#query-body'
          - include: $self

      reduce-clause:
        begin: |
          (?x)
          \s*
          (?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b
            (
              \b (?:fold|reduce|scan) \b \s*
              \b (?:first|last|left|right)?
            )
          \b
          \s*
        beginCaptures:
          1: {name: keyword.control.query.ruko}
        end: (?=[,;)}\]])
        patterns:
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(by|while|with)\b\s*
            name: keyword.control.query.ruko
          - include: '#query-body'
          - include: $self

      group-clause:
        begin: |
          (?x)
          \s*
          (?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b
            (
              group
            )
          \b
          \s*
        beginCaptures:
          1: {name: keyword.control.query.ruko}
        end: (?=[,;)}\]])
        patterns:
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(by|[io]nto)\b\s*
            name: keyword.control.query.ruko
          - include: '#query-body'
          - include: $self

  namespace-separators:
    patterns:
      - include: '#accessor-operators'
      - match: (?<!\\)\\(?!\\)
        name: punctuation.separator.namespace.ruko

  declarations:
    patterns:
      - include: '#variable'
      - include: '#declare'
      - include: '#quote'
      - include: '#style'
      - include: '#script'
      - include: '#markup'
      - include: '#function'
      - include: '#procedure'
      - include: '#property'
      - include: '#class'
      - include: '#interface'
      - include: '#enum'
      - include: '#module'
      - include: '#iterator'
      - include: '#macro'
      - include: '#query'
      - include: '#object'
      - include: '#trait'
      - include: '#component'
      - include: '#record'
      - include: '#realm'
      - include: '#struct'
      - include: '#union'
      - include: '#model'
      - include: '#namespace'
      - include: '#template'

    repository:
      quote:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(quote)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.quote.ruko}
        name: meta.quote.ruko
        patterns:
          - begin: \s*(\{)\s*
            end: \s*(\})\s*
            name: meta.quote.ruko
            captures:
              1: {name: punctuation.definition.block.ruko}
            patterns:
              - include: '#embedded-expression'
              - include: '#embedded-format'
              - include: '#embedded-placeholder'
              - include: $self
          - include: '#declaration-clause'
          - include: '#namespace-separators'
          - match: *entity-name
            name: entity.name.quote.ruko

      style:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(style)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.style.ruko}
        name: meta.style.ruko
        patterns:
          - include: '#style-rules'
          - include: '#style-pair'
          - include: '#style-block'
          - include: '#declaration-clause'
          - include: '#namespace-separators'
          - match: *entity-name
            name: entity.name.style.ruko

      script:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(script)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.script.ruko}
        name: meta.script.ruko
        patterns:
          - include: '#script-block'
          - include: '#declaration-clause'
          - include: '#namespace-separators'
          - match: *entity-name
            name: entity.name.script.ruko

      component:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(elem)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.component.ruko}
        patterns:
          - include: '#declaration-clause'
          - include: '#namespace-separators'
          - match: *entity-name
            name: entity.name.component.ruko
            patterns: *html-tag-names

      variable:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(const|let|mut|dyn|va[rl]|use|given|state)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.variable.ruko}

      declare:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(decl)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: keyword.other.declare.ruko}

      function:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(func)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.function.ruko}
        patterns:
          - include: '#declaration-clause'
          - include: '#namespace-separators'
          - match: *entity-name
            name: entity.name.function.ruko

      namespace:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(actor)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.namespace.ruko}
        patterns:
          - include: '#declaration-clause'
          - include: '#namespace-separators'
          - match: *entity-name
            name: entity.name.namespace.ruko

      property:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(prop)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.property.ruko}
        patterns:
          - include: '#declaration-clause'
          - include: '#namespace-separators'
          - match: *entity-name
            name: entity.name.property.ruko

      procedure:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(proc)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.procedure.ruko}
        patterns:
          - include: '#declaration-clause'
          - include: '#namespace-separators'
          - match: *entity-name
            name: entity.name.procedure.ruko

      template:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(temp)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.template.ruko}
        patterns:
          - include: '#declaration-clause'
          - include: '#namespace-separators'
          - match: *entity-name
            name: entity.name.template.ruko

      class:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(class)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.class.ruko}
        patterns:
          - include: '#declaration-clause'
          - include: '#namespace-separators'
          - match: *entity-name
            name: entity.name.class.ruko

      interface:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(impl)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.interface.ruko}
        patterns:
          - include: '#declaration-clause'
          - include: '#namespace-separators'
          - match: *entity-name
            name: entity.name.interface.ruko

      enum:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(enum)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.enum.ruko}
        patterns:
          - include: '#declaration-clause'
          - include: '#namespace-separators'
          - match: *entity-name
            name: entity.name.enum.ruko

      module:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(module)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.module.ruko}
        patterns:
          - include: '#declaration-clause'
          - include: '#namespace-separators'
          - match: *entity-name
            name: entity.name.module.ruko

      iterator:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(iter)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.iterator.ruko}
        patterns:
          - include: '#declaration-clause'
          - include: '#namespace-separators'
          - match: *entity-name
            name: entity.name.iterator.ruko

      model:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(model)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.model.ruko}
        patterns:
          - include: '#declaration-clause'
          - include: '#namespace-separators'
          - match: *entity-name
            name: entity.name.model.ruko

      macro:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(macro)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.macro.ruko}
        patterns:
          - include: '#declaration-clause'
          - include: '#namespace-separators'
          - match: *entity-name
            name: entity.name.macro.ruko

      query:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(query)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.query.ruko}
        patterns:
          - include: '#declaration-clause'
          - include: '#namespace-separators'
          - match: *entity-name
            name: entity.name.query.ruko

      object:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(object)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.object.ruko}
        patterns:
          - include: '#declaration-clause'
          - include: '#namespace-separators'
          - match: *entity-name
            name: entity.name.object.ruko

      trait:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(trait)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.trait.ruko}
        patterns:
          - include: '#declaration-clause'
          - include: '#namespace-separators'
          - match: *entity-name
            name: entity.name.trait.ruko

      realm:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(realm)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.realm.ruko}
        patterns:
          - include: '#declaration-clause'
          - include: '#namespace-separators'
          - match: *entity-name
            name: entity.name.realm.ruko

      union:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(union)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.union.ruko}
        patterns:
          - include: '#declaration-clause'
          - match: *entity-name
            name: entity.name.union.ruko

      struct:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(struct)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.struct.ruko}
        patterns:
          - include: '#declaration-clause'
          - include: '#namespace-separators'
          - match: *entity-name
            name: entity.name.struct.ruko

      record:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(record)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.record.ruko}
        patterns:
          - include: '#declaration-clause'
          - include: '#namespace-separators'
          - match: *entity-name
            name: entity.name.record.ruko

  declaration-clause:
    name: meta.declaration.ruko
    patterns:
      - match: *constraint-keyword
        name: keyword.other.$1.ruko
      - match: \b([\p{Pc}\p{L}]\w*)\b(?=::|\.)
        name: entity.name.namespace.ruko
      - include: '#type-square-brackets'
      - include: '#type-signature'
      - include: '#decorators'
      - include: '#type-keywords'
      - match: \s*(?<!\*)\*(?!\*)\s*
        name: keyword.generator.asterisk.ruko
      - include: '#comments'
      - include: '#comma'
      - include: '#line-continuation'
      - begin: (\()\s*
        end: \s*(\))
        captures:
          1: {name: punctuation.definition.parameters.ruko}
        patterns:
          - include: '#binding-pattern'
          - include: $self
      - begin: (\#\{)\s*
        end: \s*(\})
        name: meta.brace.curly.ruko
        captures:
          1: {name: punctuation.section.class.ruko}
        patterns:
          - include: $self
      - begin: (\{)\s*
        end: \s*(\})
        name: meta.brace.curly.ruko
        captures:
          1: {name: punctuation.definition.block.ruko}
        patterns:
          - include: $self
      - include: '#embedded-expression'
      - include: '#embedded-format'
      - include: '#embedded-placeholder'
      - include: '#brackets'
      - include: '#literals'
      - match: ::|\.|\\
        name: punctuation.separator.namespace.ruko
      - match: \s+
        name: meta.block.ruko

  function-clause:
    patterns:
      - comment: |
          Function def before function keyword
          x = def()
        match: |
          (?x)
          \s*
          (?<=[?!:]:|\b\.|[?!]\.) # lookbehind for valid assignment
          \s*
          \b([\p{Pc}\p{L}]\w*)\b\s+ # Label
          (:?=)\s+ # Assignment operator

          (
            # ignore all keywords
            (?!
              (?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b
              (?: # keywords
                [io]n|of|[ai]s|has|old|new|del
                |unset|ref|and|x?or|not
                |const|let|mut|dyn
                |va[rl]|use|given|state
                |func|proc|prop|type|class|actor
                |impl|enum|module|struct|record
                |union|iter|macro|query|elem|temp
                |object|realm|trait|style|script|quote
                |go|defer|do|with|from|where
                |if|else|then|guard|when
                |for|loop|while|goto|move
                |try|throw|catch|switch
                |match|case|pass|def
                |break|skip|redo|retry
                |return|yield|await|scope
                |import|export|intern|extern
                |debug|assert|check|decl
              )
              \b
            )
            [\p{Pc}\p{L}]\w* # identifier
            \b
          )?

          \s*
          (?=
            \b
            (?: # Function types
              func|proc|prop|type|class|actor
              |impl|enum|module|struct|record
              |union|iter|macro|query|elem|temp
              |object|realm|trait|style|script|quote
            )
            \b
          )
        name: meta.function.declaration.ruko
        captures:
          1: {name: entity.name.method.ruko}
          2: {name: keyword.operator.assignment.ruko}
          3: {patterns: [include: '#modifiers']}
      - begin: |
          (?x)
          \s*
          (?<=[?!:]:|\b\.|[?!]\.) # lookbehind for valid assignment
          \s*
          \b([\p{Pc}\p{L}]\w*)\b\s+ # Label
          (:?=)\s+ # Assignment operator

          (
            # ignore all keywords
            (?!
              (?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b
              (?: # keywords
                [io]n|of|[ai]s|has|old|new|del
                |unset|ref|and|x?or|not
                |const|let|mut|dyn
                |va[rl]|use|given|state
                |func|proc|prop|type|class|actor
                |impl|enum|module|struct|record
                |union|iter|macro|query|elem|temp
                |object|realm|trait|style|script|quote
                |go|defer|do|with|from|where
                |if|else|then|guard|when
                |for|loop|while|goto|move
                |try|throw|catch|switch
                |match|case|pass|def
                |break|skip|redo|retry
                |return|yield|await|scope
                |import|export|intern|extern
                |debug|assert|check|decl
              )
              \b
            )
            [\p{Pc}\p{L}]\w* # identifier
            \b
          )?

          \s*
          \b(fn)\b\s* # function keyword
          (\|)(?!\|)
        end: (?<!\|)(\|)(?!\|)
        name: meta.function.declaration.ruko
        captures:
          1: {name: entity.name.method.ruko}
          2: {name: keyword.operator.assignment.ruko}
          3: {patterns: [include: '#modifiers']}
          4: {name: storage.type.function.ruko}
          5: {name: punctuation.separator.arguments.ruko}
        endCaptures:
          1: {name: punctuation.separator.arguments.ruko}
        patterns:
          - include: '#argument-list-content'
      - comment: |
          Function def before function keyword
          x = def()
        match: |
          (?x)
          \s*
          \b([\p{Pc}\p{L}]\w*)\b\s+ # Label
          (:?=)\s+ # Assignment operator

          (
            # ignore all keywords
            (?!
              (?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b
              (?: # keywords
                [io]n|of|[ai]s|has|old|new|del
                |unset|ref|and|x?or|not
                |const|let|mut|dyn
                |va[rl]|use|given|state
                |func|proc|prop|type|class|actor
                |impl|enum|module|struct|record
                |union|iter|macro|query|elem|temp
                |object|realm|trait|style|script|quote
                |go|defer|do|with|from|where
                |if|else|then|guard|when
                |for|loop|while|goto|move
                |try|throw|catch|switch
                |match|case|pass|def
                |break|skip|redo|retry
                |return|yield|await|scope
                |import|export|intern|extern
                |debug|assert|check|decl
              )
              \b
            )
            [\p{Pc}\p{L}]\w* # identifier
            \b
          )?

          \s*
          (?=
            \b
            (?: # Function types
              func|proc|prop|type|class|actor
              |impl|enum|module|struct|record
              |union|iter|macro|query|elem|temp
              |object|realm|trait|style|script|quote
            )
            \b
          )
        name: meta.function.declaration.ruko
        captures:
          1: {name: entity.name.ruko}
          2: {name: keyword.operator.assignment.ruko}
          3: {patterns: [include: '#modifiers']}
      - begin: |
          (?x)

          \s*
          \b([\p{Pc}\p{L}]\w*)\b\s+ # Label
          (:?=)\s+ # Assignment operator
          \s*

          (
            # ignore all keywords
            (?!
              (?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b
              (?: # keywords
                [io]n|of|[ai]s|has|old|new|del
                |unset|ref|and|x?or|not
                |const|let|mut|dyn
                |va[rl]|use|given|state
                |func|proc|prop|type|class|actor
                |impl|enum|module|struct|record
                |union|iter|macro|query|elem|temp
                |object|realm|trait|style|script|quote
                |go|defer|do|with|from|where
                |if|else|then|guard|when
                |for|loop|while|goto|move
                |try|throw|catch|switch
                |match|case|pass|def
                |break|skip|redo|retry
                |return|yield|await|scope
                |import|export|intern|extern
                |debug|assert|check|decl
              )
              \b
            )
            [\p{Pc}\p{L}]\w* # identifier
            \b
          )?

          \s*
          \b(fn)\b\s* # function keyword
          (\|)(?!\|)
        end: (?<!\|)(\|)(?!\|)
        name: meta.function.declaration.ruko
        captures:
          1: {name: entity.name.ruko}
          2: {name: keyword.operator.assignment.ruko}
          3: {patterns: [include: '#modifiers']}
          4: {name: storage.type.function.ruko}
          5: {name: punctuation.separator.arguments.ruko}
        endCaptures:
          1: {name: punctuation.separator.arguments.ruko}
        patterns:
          - include: '#argument-list-content'

  argument-list:
    name: meta.function.arguments.ruko
    begin: |
      (?x)
      (?<=
        (?:
            # beginning of line
            ^
          | # separator
            [,;]
          | # opening bracket
            [({\[]
          | # postfix or infix operator
            [\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]+ \s
        ) \s*
        | # a keyword
        (?:
          (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
          \b
            (?: # keywords
              [io]n|of|[ai]s|has|old|new|del
              |unset|ref|and|x?or|not
              |const|let|mut|dyn
              |va[rl]|use|given|state
              |func|proc|prop|type|class|actor
              |impl|enum|module|struct|record
              |union|iter|macro|query|elem|temp
              |object|realm|trait|style|script|quote
              |go|defer|do|with|from|where
              |if|else|then|guard|when
              |for|loop|while|goto|move
              |try|throw|catch|switch
              |match|case|pass|def
              |break|skip|redo|retry
              |return|yield|await|scope
              |import|export|intern|extern
              |debug|assert|check|decl
            )
          \b
        ) \s*
      ) \s*
      (\|)(?!\|)
    captures:
      1: {name: punctuation.separator.arguments.ruko}
    end: (?<!\|)(\|)(?!\|)
    patterns:
      - include: '#argument-list-content'

  argument-list-content:
    patterns:
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(as)\b\s*
        name: keyword.operator.expression.as.ruko
      - match: (?<=[\w\s][(|])\.
        name: punctuation.definition.metadata.ruko
      - match: ','
        name: punctuation.separator.arguments.ruko
      - include: '#binding-pattern'

  clauses:
    patterns:
      - include: '#for-clause'
      - include: '#if-clause'
      - include: '#match-clause'
      - include: '#switch-clause'
      - include: '#try-clause'
      - include: '#catch-clause'
      - include: '#with-clause'
      - include: '#do-clause'
      - include: '#type-clause'
      - include: '#new-clause'

    repository:
      new-clause:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(old|new)\b
        end: (?=)|$
        beginCaptures:
          1: {name: keyword.operator.expression.$1.ruko}
        patterns:
          - match: *entity-name
            name: entity.name.instance.ruko
          - include: '#type-clause'
          - include: '#type-keywords'
          - include: '#type-square-brackets'
          - include: '#parameter-brackets'
          - include: '#namespace-separators'
          - include: '#round-brackets'

      type-clause:
        patterns:
          - applyEndPatternLast: true
            begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(as)\b\s*
            end: (?=)|$
            beginCaptures:
              1: {name: keyword.operator.expression.as.ruko}
            patterns:
              - include: '#types'
          - applyEndPatternLast: true
            begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(is\s+not|is|has)\b\s*
            end: (?=)|$
            beginCaptures:
              1: {name: keyword.operator.expression.is.ruko}
            patterns:
              - include: '#types'
          - applyEndPatternLast: true
            begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(type)\b\s*
            end: (?=)|$
            captures:
              1: {name: keyword.other.typedef.ruko}
            patterns:
              - include: '#types'
              - match: \s*([:!=</>.^$%?*+|&~]?=)\s*
                captures:
                  1: {name: keyword.operator.assignment.ruko}

      try-clause:
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(try|then)\b\s*
        end: \s*(:)(?=['"`({\[)}\]\w\s])|(?=[,;)}\]])|$
        name: meta.try.ruko
        beginCaptures:
          1: {name: keyword.control.error.ruko}
        endCaptures:
          1: {name: punctuation.definition.section.ruko}
        patterns:
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(await)\b\s*
            name: keyword.control.error.ruko
          - include: $self

      catch-clause:
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(catch)\b\s*
        end: \s*(?=[,;)}\]])|$
        name: meta.catch.ruko
        beginCaptures:
          1: {name: keyword.control.error.ruko}
        patterns:
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(as)\b\s*
            name: keyword.control.error.ruko
          - begin: \s*(\{)\s*
            end: \s*(\})\s*
            captures:
              1: {name: punctuation.definition.block.ruko}
            patterns:
              - include: '#catch-case-clause'
              - include: $self
          - include: $self

      catch-case-clause:
        patterns:
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(def|else)\b\s*(:)
            captures:
              1: {name: keyword.control.error.ruko}
              2: {name: punctuation.definition.case-statement.ruko}
          - begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(case)\b\s*
            end: \s*(:)(?=['"`({\[)}\]\w\s])|$
            beginCaptures:
              1: {name: keyword.control.error.ruko}
            endCaptures:
              1: {name: punctuation.definition.case-statement.ruko}
            patterns:
              - include: '#argument-list'
              - applyEndPatternLast: true
                begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(is\s+not|is)\b\s*
                end: (?=)|$
                beginCaptures:
                  1: {name: keyword.control.error.ruko}
                patterns:
                  - include: '#types'
              - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(if\s+not|if|guard|when|as)\b\s*
                name: keyword.control.error.ruko
              - include: '#type-keywords'
              - include: $self

      for-clause:
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(for|while\s+not|while)\b\s*
        end: \s*(:)(?=['"`({\[)}\]\w\s])|(?=[,;)}\]])|$
        name: meta.for.ruko
        beginCaptures:
          1: {name: keyword.control.loop.ruko}
        endCaptures:
          1: {name: punctuation.definition.block.ruko}
        patterns:
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b([io]n|of)\b\s*
            name: keyword.control.loop.ruko
          - include: $self

      if-clause:
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(if\s+not|if|guard|when)\b\s*
        end: \s*(:)(?=['"`({\[)}\]\w\s])|(?=[,;)}\]])|$
        name: meta.if.ruko
        beginCaptures:
          1: {name: keyword.control.conditional.ruko}
        endCaptures:
          1: {name: punctuation.definition.block.ruko}
        patterns:
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(await)\b\s*
            name: keyword.control.conditional.ruko
          - include: $self

      match-clause:
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(match)\b\s*
        end: \s*(?=[,;)}\]])|$
        name: meta.match.ruko
        beginCaptures:
          1: {name: keyword.control.match.ruko}
        patterns:
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(await)\b\s*
            name: keyword.control.match.ruko
          - begin: \s*(\{)\s*
            end: \s*(\})\s*
            captures:
              1: {name: punctuation.definition.block.ruko}
            patterns:
              - include: '#match-case-clause'
              - include: $self
          - include: $self

      match-case-clause:
        patterns:
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(def|else)\b\s*(:)
            captures:
              1: {name: keyword.control.match.ruko}
              2: {name: punctuation.definition.case-statement.ruko}
          - begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(case)\b\s*
            end: \s*(:)(?=['"`({\[)}\]\w\s])|$
            beginCaptures:
              1: {name: keyword.control.match.ruko}
            endCaptures:
              1: {name: punctuation.definition.case-statement.ruko}
            patterns:
              - include: '#argument-list'
              - applyEndPatternLast: true
                begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(is\s+not|is)\b\s*
                end: (?=)|$
                beginCaptures:
                  1: {name: keyword.control.match.ruko}
                patterns:
                  - include: '#types'
              - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(if\s+not|if|guard|when|as)\b\s*
                name: keyword.control.match.ruko
              - include: '#type-keywords'
              - include: $self

      switch-clause:
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(switch)\b\s*
        end: \s*(:)(?=['"`({\[)}\]\w\s])|(?=[,;)}\]])|$
        name: meta.switch.ruko
        beginCaptures:
          1: {name: keyword.control.switch.ruko}
        patterns:
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(await)\b\s*
            name: keyword.control.switch.ruko
          - begin: \s*(\{)\s*
            end: \s*(\})\s*
            captures:
              1: {name: punctuation.definition.block.ruko}
            patterns:
              - include: '#switch-case-clause'
              - include: $self
          - include: $self

      switch-case-clause:
        patterns:
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(def|else)\b\s*(:)
            captures:
              1: {name: keyword.control.switch.ruko}
              2: {name: punctuation.definition.case-statement.ruko}
          - begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(case)\b\s*
            end: \s*(:)(?=['"`({\[)}\]\w\s])|$
            beginCaptures:
              1: {name: keyword.control.switch.ruko}
            endCaptures:
              1: {name: punctuation.definition.case-statement.ruko}
            patterns:
              - include: '#argument-list'
              - applyEndPatternLast: true
                begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(is\s+not|is)\b\s*
                end: (?=)|$
                beginCaptures:
                  1: {name: keyword.control.switch.ruko}
                patterns:
                  - include: '#types'
              - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(if\s+not|if|guard|when|as)\b\s*
                name: keyword.control.switch.ruko
              - include: '#type-keywords'
              - include: $self

      with-clause:
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(with)\b\s*
        end: \s*(:)(?=['"`({\[)}\]\w\s])|(?=[,;)}\]])|$
        name: meta.if.ruko
        beginCaptures:
          1: {name: keyword.control.with.ruko}
        endCaptures:
          1: {name: punctuation.definition.block.ruko}
        patterns:
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(await)\b\s*
            name: keyword.control.with.ruko
          - include: $self

  # Binding patterns

  object-key:
    begin: (?<=^|{|;|,)\s*
    end: \s*(?=,|;|}|$)|\s*(:)
    name: meta.object-key.ruko
    endCaptures:
      1: {name: punctuation.separator.key-value.ruko}
    patterns:
      - include: '#literals'
      - include: '#embedded-expression'
      - include: '#brackets'
      - match: (?<=^|{|;|,)\s*\b[\p{Pc}\p{L}]\w*\b\s*(?=,|;|}|:|$)
        name: constant.other.object.key.ruko
      - include: '#space'
      - include: '#comments'
      - include: '#line-continuation'
      - include: $self

  object-value:
    patterns:
      - match: (?<=(?:^|{|;|,)\s*)\b[\p{Pc}\p{L}]\w*\b(?=\s*(?:,|;|}|=['"`({\[\w\s]|$))
        name: variable.other.constant.ruko
      - match: (?<=^|{|;|,)\s*\b[\p{Pc}\p{L}]\w*\b\s*(?=,|;|}|=['"`({\[\w\s]|$)
        name: variable.other.constant.ruko

  object-argument:
    patterns:
      - match: (?<=(?:^|{|;|,)\s*)\b[\p{Pc}\p{L}]\w*\b(?=\s*(?:,|;|}|=['"`({\[\w\s]|$))
        name: variable.parameter.ruko
      - match: (?<=^|{|;|,)\s*\b[\p{Pc}\p{L}]\w*\b\s*(?=,|;|}|=['"`({\[\w\s]|$)
        name: variable.parameter.ruko

  as-keyword:
    match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(as)\b\s*
    name: keyword.operator.expression.as.ruko

  given-using-keyword:
    match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(given|using)\b\s*
    name: keyword.operator.expression.$1.ruko

  binding-pattern-object:
    begin: (#?{)\s*
    end: \s*(})
    name: meta.brace.curly.ruko
    captures:
      1: {name: punctuation.definition.binding-pattern.object.ruko}
    patterns:
      - include: '#object-argument'
      - include: '#labels'
      - include: '#object-key'
      - match: ;|,
        name: punctuation.separator.mapping.ruko
      - include: '#binding-pattern'
      - include: '#illegal'

  binding-pattern-tuple:
    begin: (#?\()\s*
    end: \s*(\))
    name: meta.brace.curly.ruko
    captures:
      1: {name: punctuation.definition.binding-pattern.tuple.ruko}
    patterns:
      - include: '#labels'
      - match: ;|,
        name: punctuation.separator.arguments.ruko
      - include: '#binding-pattern'
      - include: '#illegal'

  binding-pattern-array:
    begin: (#?\[)\s*
    end: \s*(])
    name: meta.brace.curly.ruko
    captures:
      1: {name: punctuation.definition.binding-pattern.array.ruko}
    patterns:
      - include: '#labels'
      - match: ;|,
        name: punctuation.separator.sequence.ruko
      - include: '#binding-pattern'
      - include: '#illegal'

  default-value:
    begin: (?<=^|[\s({\[])(\=)(?=$|[)}\]\s])|(?<=['"`)}\]\w]|\\.)(\=)(?=['"`({\[\w])
    captures:
      1: {name: keyword.operator.assignment.ruko}
      2: {name: keyword.operator.assignment.ruko}
    end: (?=\|(?:$|[^|])|[,;)}\]])
    patterns:
      - include: $self

  binding-pattern:
    patterns:
      - include: '#default-value'
      - include: '#as-keyword'
      - include: '#given-using-keyword'
      - include: '#binding-pattern-object'
      - include: '#binding-pattern-tuple'
      - include: '#binding-pattern-array'
      - include: '#illegal-identifiers'
      - include: '#parameter-variables'
      - include: '#type-operators'
      - include: '#type-signature'
      - include: '#space'
      - include: '#comments'
      - include: '#calls'

  # Object labels

  labels:
    patterns:
      - comment: |
          Function def before function keyword
          x = def()
        match: |
          (?x)
          (?<=^\s*|[{;,]\s*)

          \s*
          (\b[\p{Pc}\p{L}][\p{Pd}\w]*\b) # Label
          (:) # Key value separator
          \s*\b

          (
            # ignore all keywords
            (?!
              (?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b
              (?: # keywords
                [io]n|of|[ai]s|has|old|new|del
                |unset|ref|and|x?or|not
                |const|let|mut|dyn
                |va[rl]|use|given|state
                |func|proc|prop|type|class|actor
                |impl|enum|module|struct|record
                |union|iter|macro|query|elem|temp
                |object|realm|trait|style|script|quote
                |go|defer|do|with|from|where
                |if|else|then|guard|when
                |for|loop|while|goto|move
                |try|throw|catch|switch
                |match|case|pass|def
                |break|skip|redo|retry
                |return|yield|await|scope
                |import|export|intern|extern
                |debug|assert|check|decl
              )
              \b
            )
            [\p{Pc}\p{L}]\w* # identifier
            \b
          )?

          \s*
          (?=
            \b
            (?: # Function types
              func|proc|prop|type|class|actor
              |impl|enum|module|struct|record
              |union|iter|macro|query|elem|temp
              |object|realm|trait|style|script|quote
            )
            \b
          )
        name: meta.object-literal.key.ruko
        captures:
          1: {name: entity.name.ruko}
          2: {name: punctuation.separator.key-value.ruko}
          3: {patterns: [include: '#modifiers']}
      - begin: |
          (?x)
          (?<=^\s*|[{;,]\s*)

          \s*
          (\b[\p{Pc}\p{L}][\p{Pd}\w]*\b) # Label
          (:) # Key value separator
          \s*\b

          (
            # ignore all keywords
            (?!
              (?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b
              (?: # keywords
                [io]n|of|[ai]s|has|old|new|del
                |unset|ref|and|x?or|not
                |const|let|mut|dyn
                |va[rl]|use|given|state
                |func|proc|prop|type|class|actor
                |impl|enum|module|struct|record
                |union|iter|macro|query|elem|temp
                |object|realm|trait|style|script|quote
                |go|defer|do|with|from|where
                |if|else|then|guard|when
                |for|loop|while|goto|move
                |try|throw|catch|switch
                |match|case|pass|def
                |break|skip|redo|retry
                |return|yield|await|scope
                |import|export|intern|extern
                |debug|assert|check|decl
              )
              \b
            )
            [\p{Pc}\p{L}]\w* # identifier
            \b
          )?

          \s*
          \b(fn)\b\s* # function keyword
          (\|)(?!\|)
        end: (?<!\|)(\|)(?!\|)
        name: meta.object-literal.key.ruko
        beginCaptures:
          1: {name: entity.name.ruko}
          2: {name: punctuation.separator.key-value.ruko}
          3: {patterns: [include: '#modifiers']}
          4: {name: storage.type.function.ruko}
          5: {name: punctuation.separator.arguments.ruko}
        endCaptures:
          1: {name: punctuation.separator.arguments.ruko}
        patterns:
          - include: '#argument-list-content'
      - match: |
          (?x)
          (?<=^\s*|[{;,]\s*)
          \s*
          (\b[\p{Pc}\p{L}][\p{Pd}\w]*\b) # label
          (?=: ['"`({\[)}\]\w\s])
        name: meta.object-literal.key.ruko
        captures:
          1:
            name: constant.other.object.key.ruko
            patterns:
              - include: '#constants'
              - include: '#numbers'
              - include: '#symbols'
              - include: '#string-content'
      - include: '#type-signature' # patch to allow type signatures

  # Punctuation

  punctuation:
    patterns:
      - include: '#line-continuation'
      - include: '#comma'
      - include: '#double-semicolon'
      - include: '#semicolon'

  line-continuation:
    begin: \s*(`)\s*(?=/[/*](?![\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]+)|$)
    end: ^\s*(?=\S)
    captures:
      1: {name: punctuation.separator.continuation.line.ruko}
    patterns:
      - include: '#comments'

  comma:
    match: \s*(,)
    name: punctuation.separator.expression.ruko

  double-semicolon:
    match: \s*(;;)
    name: punctuation.terminator.expression.ruko

  semicolon:
    match: \s*(;)
    name: punctuation.terminator.statement.ruko

  brackets:
    patterns:
      - include: '#angle-brackets'
      - include: '#curly-brackets'
      - include: '#square-brackets'
      - include: '#round-brackets'

  generics:
    patterns:
      - comment: <> exception.
        match: (?<=^|['"`)}\]>\w\s])(<>)\s*
        captures:
          1: {name: punctuation.type.arguments.ruko}
      - comment: Support for Turbofish syntax
        name: meta.type-arguments
        begin: (?<=^|['"`)}\]>\w\s])([?!:]:|[?!]?\.)(<)(?=[\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]*['"`({\[\w])
        end: (?<=^|['"`)}\]>\w])()(>)(!\b)?
        captures:
          1:
            name: punctuation.type.arguments.ruko
            patterns: [include: '#generic-operators']
          2: {name: punctuation.type.arguments.ruko}
          3: {name: keyword.operator.macro.ruko}
        patterns:
          - include: '#punctuation'
          - include: '#brackets'
          - include: '#types'
          - include: '#type-signature'
          - include: '#embedded-expression'
          - include: '#embedded-format'
          - include: '#embedded-placeholder'

  generic-operators:
    name: punctuation.type.arguments.ruko
    match: |
      (?x)
      (?:
        ( # 1: optional access/unwrap
          \?[.:>]=?
        ) |
        ( # 2: assert/unwrap operator
          ![.:>]=?
        ) |
        ( # 3: access operator
          (?:::|\.|->)=?
        )
      )
    captures:
      1: {name: keyword.operator.optional.ruko}
      2: {name: keyword.operator.assert.ruko}
      3: {name: keyword.operator.accessor.ruko}

  accessor-operators:
    name: punctuation.type.arguments.ruko
    match: |
      (?x)
      (?<=\b|>)
      (?:
        ( # 1: optional access/unwrap
          \?[.:>]=?
        ) |
        ( # 2: assert/unwrap operator
          ![.:>]=?
        ) |
        ( # 3: access operator
          (?:::|\.|->)=?
        )
      )
      (?=\b|<)
    captures:
      1: {name: keyword.operator.optional.ruko}
      2: {name: keyword.operator.assert.ruko}
      3: {name: keyword.operator.accessor.ruko}

  angle-brackets:
    patterns:
      - comment: <> exception.
        match: (?<=^|['"`)}\]>\w\s])(<>)\s*
        captures:
          1: {name: punctuation.type.arguments.ruko}
      - comment: Type arguments. This is complicated since we don't want to match things like foo < 123 || bar > baz
        name: meta.type-arguments
        begin: (?<=^|['"`)}\]>\w\s])(<)(?=[\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]*['"`({\[\w])
        end: (?<=^|['"`)}\]>\w]?)(>)
        captures:
          1: {name: punctuation.type.arguments.ruko}
        patterns:
          - include: '#punctuation'
          - include: '#brackets'
          - include: '#types'
          - include: '#type-signature'
          - include: '#embedded-expression'
          - include: '#embedded-format'
          - include: '#embedded-placeholder'

  curly-brackets:
    repository:
      punctuation:
        patterns:
          - match: ','
            name: punctuation.separator.mapping.ruko
          - match: (?<=(?:['"`)}\]\w]|\\.)[\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]*):(?=['"`({\[\w\s]|$)
            name: punctuation.separator.key-value.ruko

    patterns:
      - begin: |
          (?x)
          (?<=
            (?:
                (?:^|[\s\p{P}\p{S}]):\|\s*\| # beside a lambda pipe
              | (?:^|[,;'"`)}\]\w\s]|\\.)\|
              | ^\s*\|
            )
          )
          \s*
          (\#\{)
          \s*
        end: \s*(\})
        name: meta.brace.curly.ruko
        captures:
          1: {name: punctuation.section.class.ruko}
        patterns:
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:
                (?:^|[\s\p{P}\p{S}]):\|\s*\| # beside a lambda pipe
              | (?:^|[,;'"`)}\]\w\s]|\\.)\|
              | ^\s*\|
            )
          )
          \s*
          (\{)
          \s*
        end: \s*(\})
        name: meta.brace.curly.ruko
        captures:
          1: {name: punctuation.definition.block.ruko}
        patterns:
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \b
              (?: # destructuring keywords
                const|let|mut|dyn
                |va[rl]|use|given|state
                |case
              )
            \b
            (?:$|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \s*
          )
          (\#?\{)\s*
        end: \s*(\})
        name: meta.brace.curly.ruko
        captures:
          1:
            name: punctuation.definition.binding-pattern.object.ruko
        patterns:
          - include: '#labels'
          - include: '#punctuation'
          - include: '#object-value'
          - include: '#object-key'
          - include: '#as-keyword'
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \b
              (?: # expression keywords
                [io]n|of|[ai]s|has|old|new|del
                |unset|ref|and|x?or|not
              )
            \b
            (?:$|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \s*
          )
          (\#\{)\s*
        end: \s*(\})
        name: meta.brace.curly.ruko
        captures:
          1: {name: punctuation.definition.mapping.ruko}
        patterns:
          - include: '#labels'
          - include: '#punctuation'
          - include: '#object-value'
          - include: '#object-key'
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \b
              (?: # expression keywords
                [io]n|of|[ai]s|has|old|new|del
                |unset|ref|and|x?or|not
              )
            \b
            (?:$|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \s*
          )
          (\{)\s*
        end: \s*(\})
        name: meta.brace.curly.ruko
        captures:
          1: {name: punctuation.definition.dictionary.ruko}
        patterns:
          - include: '#labels'
          - include: '#punctuation'
          - include: '#object-value'
          - include: '#object-key'
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:
                ^
              | [,;({\[]
              | (?:^|[,;({\[)}\]\w'"`]|\\.):\s*
              | [\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]+
            )
            \s*
          )
          (\#\{)\s*
        end: \s*(\})
        name: meta.brace.curly.ruko
        captures:
          1: {name: punctuation.definition.mapping.ruko}
        patterns:
          - include: '#labels'
          - include: '#punctuation'
          - include: '#object-value'
          - include: '#object-key'
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:
                ^
              | [,;({\[]
              | (?:^|[,;({\[)}\]\w'"`]|\\.):\s*
              | [\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]+
            )
            \s*
          )
          (\{)\s*
        end: \s*(\})
        name: meta.brace.curly.ruko
        captures:
          1: {name: punctuation.definition.dictionary.ruko}
        patterns:
          - include: '#labels'
          - include: '#punctuation'
          - include: '#object-value'
          - include: '#object-key'
          - include: $self
      - begin: (\#\{)\s*
        end: \s*(\})
        name: meta.brace.curly.ruko
        captures:
          1: {name: punctuation.section.class.ruko}
        patterns:
          - include: $self
      - begin: (\{)\s*
        end: \s*(\})
        name: meta.brace.curly.ruko
        captures:
          1: {name: punctuation.definition.block.ruko}
        patterns:
          - include: $self

  round-brackets:
    repository:
      punctuation:
        patterns:
          - match: ','
            name: punctuation.separator.arguments.ruko
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(as)\b\s*
            name: keyword.operator.expression.as.ruko
          - match: (?<=[\w\s][(|])\.
            name: punctuation.definition.metadata.ruko

    patterns:
      - begin: |
          (?x)
          (?<=
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \b
              (?: # destructuring keywords
                const|let|mut|dyn
                |va[rl]|use|given|state
                |case
              )
            \b
            (?:$|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \s*
          )
          (\#?\()\s*
        end: \s*(\))
        name: meta.brace.round.ruko
        captures:
          1: {name: punctuation.definition.binding-pattern.tuple.ruko}
        patterns:
          - include: '#as-keyword'
          - include: '#punctuation'
          - include: $self
      - begin: |
          (?x)
          (?<= # literal
              (?: [\w'"`)}\]] | \\.) >* !?
            | [^.]\.=?|[?!:]:=?
          )
          (\#?\()\s*
        end: \s*(\))
        name: meta.brace.round.ruko
        captures:
          1: {name: punctuation.definition.parameters.ruko}
        patterns:
          - include: '#parameter-variables'
          - include: $self
      - begin: (\#\()\s*
        end: \s*(\))
        name: meta.brace.round.ruko
        captures:
          1: {name: punctuation.definition.tuple.ruko}
        patterns:
          - include: '#s-expression'
          - include: $self
      - begin: (\()\s*
        end: \s*(\))
        name: meta.brace.round.ruko
        captures:
          1: {name: punctuation.definition.expression.ruko}
        patterns:
          - include: '#s-expression'
          - include: $self

  square-brackets:
    repository:
      punctuation:
        patterns:
          - match: ','
            name: punctuation.separator.sequence.ruko

    patterns:
      - begin: |
          (?x)
          (?<=
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \b
              (?: # destructuring keywords
                const|let|mut|dyn
                |va[rl]|use|given|state
                |case
              )
            \b
            (?:$|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \s*
          )
          (\#?\[)\s*
        end: \s*(\])
        name: meta.brace.square.ruko
        captures:
          1: {name: punctuation.definition.binding-pattern.array.ruko}
        patterns:
          - include: '#punctuation'
          - include: '#as-keyword'
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \b
              (?: # destructuring keywords
                [io]n|of|[ai]s|has|old|new|del
                |unset|ref|and|x?or|not
              )
            \b
            (?:$|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \s*
          )
          (\[)\s*
        end: \s*(\])
        name: meta.brace.square.ruko
        captures:
          1: {name: punctuation.definition.sequence.ruko}
        patterns:
          - include: '#punctuation'
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \b
              (?: # destructuring keywords
                [io]n|of|[ai]s|has|old|new|del
                |unset|ref|and|x?or|not
              )
            \b
            (?:$|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \s*
          )
          (\[)\s*
        end: \s*(\])
        name: meta.brace.square.ruko
        captures:
          1: {name: punctuation.definition.array.ruko}
        patterns:
          - include: '#punctuation'
          - include: $self
      - begin: |
          (?x)
          (?<= # literal
              (?: [\w'"`)}\]] | \\.)
            | [^.]\.=?|[?!:]:=?
          )
          (\#?\[)\s*
        end: \s*(\])
        name: meta.brace.square.ruko
        captures:
          1: {name: punctuation.definition.attribute-selector.ruko}
        patterns:
          - include: '#message'
          - include: '#punctuation'
          - include: $self
      - begin: (\#\[)\s*
        end: \s*(\])
        name: meta.brace.square.ruko
        captures:
          1: {name: punctuation.definition.sequence.ruko}
        patterns:
          - include: '#message'
          - include: '#punctuation'
          - include: $self
      - begin: (\[)\s*
        end: \s*(\])
        name: meta.brace.square.ruko
        captures:
          1: {name: punctuation.definition.array.ruko}
        patterns:
          - include: '#message'
          - include: '#punctuation'
          - include: $self

  # Sub-expressions
  s-expression:
    patterns:
      - include: '#function-calls'
      - include: '#literals'
      - include: '#constants'
      - match: |
          (?x)
          (?<=\()
          \s*
          ( # Function name
            \b
            # ignore all keywords
            (?!
              (?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b
              (?: # keywords
                [io]n|of|[ai]s|has|old|new|del
                |unset|ref|and|x?or|not
                |const|let|mut|dyn
                |va[rl]|use|given|state
                |func|proc|prop|type|class|actor
                |impl|enum|module|struct|record
                |union|iter|macro|query|elem|temp
                |object|realm|trait|style|script|quote
                |go|defer|do|with|from|where
                |if|else|then|guard|when
                |for|loop|while|goto|move
                |try|throw|catch|switch
                |match|case|pass|def
                |break|skip|redo|retry
                |return|yield|await|scope
                |import|export|intern|extern
                |debug|assert|check|decl
              )
              \b
            )
            (?:
              \b
              [\p{Pc}\p{L}]\w* # identifier
              \b
              (?:[!?]?\.=?|[?!:]:=?|[?!-]>=?) # qualified name separator
            )*
            [\p{Pc}\p{L}]\w* # last part of identifier
            \b
          )
          \s*
          (?= 
            (?:
              (?: # function name
                \b
                # ignore all keywords
                (?!
                  (?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b
                  (?: # keywords
                    [io]n|of|[ai]s|has|old|new|del
                    |unset|ref|and|x?or|not
                    |const|let|mut|dyn
                    |va[rl]|use|given|state
                    |func|proc|prop|type|class|actor
                    |impl|enum|module|struct|record
                    |union|iter|macro|query|elem|temp
                    |object|realm|trait|style|script|quote
                    |go|defer|do|with|from|where
                    |if|else|then|guard|when
                    |for|loop|while|goto|move
                    |try|throw|catch|switch
                    |match|case|pass|def
                    |break|skip|redo|retry
                    |return|yield|await|scope
                    |import|export|intern|extern
                    |debug|assert|check|decl
                  )
                  \b
                )
                \b
                [\p{Pc}\p{L}]\w* # identifier
                \b
              )
              | \s[({\[] # opening brackets
              | <[\p{Pc}\p{L}]\w* # XML tags
              | (?:\w*|[\\$#%]*)['"] | `\s*(?=\N) # string literals 
              | :[\p{Pc}\p{L}]\w* # symbol literals
              | $ # end of line
            )
          )
        name: meta.function-call.ruko
        captures:
          1:
            patterns:
              - include: '#function-names'
              - include: '#accessor-operators'
      - include: $self

  # Objective-C-style messages
  message:
    patterns:
      - include: '#constants'
      - include: '#function-calls'
      - applyEndPatternLast: true
        begin: |
          (?x)
          (?<= # literal
            (?: 
                ^ # start of line
              | [\w'"`)}\]] # literals and closing brackets
              | [?!:]:[\p{Pc}\p{L}]\w* # identifiers
              | [?!][\p{Pc}\p{L}]\w* # identifiers
              | \\. # escape sequences
            ) 
            \s*
          )
          \s*
          ([?!:]:|[?!])?
          ( # Message name
            \b
            # ignore all keywords
            (?!
              (?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b
              (?: # keywords
                [io]n|of|[ai]s|has|old|new|del
                |unset|ref|and|x?or|not
                |const|let|mut|dyn
                |va[rl]|use|given|state
                |func|proc|prop|type|class|actor
                |impl|enum|module|struct|record
                |union|iter|macro|query|elem|temp
                |object|realm|trait|style|script|quote
                |go|defer|do|with|from|where
                |if|else|then|guard|when
                |for|loop|while|goto|move
                |try|throw|catch|switch
                |match|case|pass|def
                |break|skip|redo|retry
                |return|yield|await|scope
                |import|export|intern|extern
                |debug|assert|check|decl
              )
              \b
            )
            \b
            [\p{Pc}\p{L}]\w* # identifier
            \b
          )
          (:)
        end: (?=)|$
        name: meta.message.ruko
        beginCaptures:
          1:
            patterns:
              - match: |
                  (?x)
                  (?:
                    ( # 1: optional access/unwrap
                      \?:?
                    ) |
                    ( # 2: assert/unwrap operator
                      !:?
                    ) |
                    ( # 3: access operator
                      ::
                    )
                  )
                captures:
                  1: {name: keyword.operator.optional.ruko}
                  2: {name: keyword.operator.assert.ruko}
                  3: {name: keyword.operator.accessor.ruko}
          2:
            patterns:
              - match: |
                  (?x)
                  (?: # Regular variables
                    # Leading underscore
                    (\p{Pc}+\w*\b(?!\p{Pc}+))
                  | # Train case
                    ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)
                  | # Pascal case
                    ((?:[\p{Pc}\p{L}&&\P{Ll}][\w&&\P{Lu}]*)+)
                  | # Camel or kebab case
                    ([\p{Pc}\p{L}]\w*)
                  )
                captures:
                  1:
                    patterns: *builtin-names
                    name: entity.name.tag.ruko
                  2:
                    patterns: *builtin-names
                    name: entity.name.tag.ruko support.class.component.ruko
                  3:
                    patterns: *builtin-names
                    name: entity.name.class.builtin.ruko
                  4:
                    patterns: *builtin-names
                    name: entity.name.function.member.ruko
          3: {name: punctuation.separator.arguments.ruko}
        patterns:
          - include: '#brackets'
      - match: |
          (?x)
          (?<=\[)
          \s*
          ( # Message name
            \b
            # ignore all keywords
            (?!
              (?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b
              (?: # keywords
                [io]n|of|[ai]s|has|old|new|del
                |unset|ref|and|x?or|not
                |const|let|mut|dyn
                |va[rl]|use|given|state
                |func|proc|prop|type|class|actor
                |impl|enum|module|struct|record
                |union|iter|macro|query|elem|temp
                |object|realm|trait|style|script|quote
                |go|defer|do|with|from|where
                |if|else|then|guard|when
                |for|loop|while|goto|move
                |try|throw|catch|switch
                |match|case|pass|def
                |break|skip|redo|retry
                |return|yield|await|scope
                |import|export|intern|extern
                |debug|assert|check|decl
              )
              \b
            )
            \b
            [\p{Pc}\p{L}]\w* # identifier
            \b
          )
          \s*
          (?= 
            (?: # function name
              \b
              # ignore all keywords
              (?!
                (?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b
                (?: # keywords
                  [io]n|of|[ai]s|has|old|new|del
                  |unset|ref|and|x?or|not
                  |const|let|mut|dyn
                  |va[rl]|use|given|state
                  |func|proc|prop|type|class|actor
                  |impl|enum|module|struct|record
                  |union|iter|macro|query|elem|temp
                  |object|realm|trait|style|script|quote
                  |go|defer|do|with|from|where
                  |if|else|then|guard|when
                  |for|loop|while|goto|move
                  |try|throw|catch|switch
                  |match|case|pass|def
                  |break|skip|redo|retry
                  |return|yield|await|scope
                  |import|export|intern|extern
                  |debug|assert|check|decl
                )
                \b
              )
              \b
              [\p{Pc}\p{L}]\w* # identifier
              \b
            ) 
            (?:[?!]:?|::)? # qualified name separator
          )
        name: meta.message.ruko
        captures:
          1:
            patterns:
              - match: |
                  (?x)
                  (?: # Regular variables
                    # Leading underscore
                    (\p{Pc}+\w*\b(?!\p{Pc}+))
                  | # Train case
                    ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)
                  | # Pascal case
                    ((?:[\p{Pc}\p{L}&&\P{Ll}][\w&&\P{Lu}]*)+)
                  | # Camel or kebab case
                    ([\p{Pc}\p{L}]\w*)
                  )
                captures:
                  1: {name: variable.other.global.ruko}
                  2: {name: variable.other.constant.object.ruko}
                  3: {name: variable.other.class.stat.ruko}
                  4: {name: variable.other.object.ruko}
      - match: |
          (?x)
          (?<= # literal
            (?: 
                [\w'"`)}\]] # literals and closing brackets
              | [?!:]:[\p{Pc}\p{L}]\w* # identifiers
              | [?!][\p{Pc}\p{L}]\w* # identifiers
              | \\. # escape sequences
              | !:?\s+\b # assert/unwrap operator
              | \?:?\s+\b # optional access/unwrap
              | (?:::|\.)\s+\b # access operator
              | \b\s+\b # identifiers
            ) 
            \s*
          )
          \s*
          ([?!:]:|[?!])?
          ( # Message name
            \b
            # ignore all keywords
            (?!
              (?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b
              (?: # keywords
                [io]n|of|[ai]s|has|old|new|del
                |unset|ref|and|x?or|not
                |const|let|mut|dyn
                |va[rl]|use|given|state
                |func|proc|prop|type|class|actor
                |impl|enum|module|struct|record
                |union|iter|macro|query|elem|temp
                |object|realm|trait|style|script|quote
                |go|defer|do|with|from|where
                |if|else|then|guard|when
                |for|loop|while|goto|move
                |try|throw|catch|switch
                |match|case|pass|def
                |break|skip|redo|retry
                |return|yield|await|scope
                |import|export|intern|extern
                |debug|assert|check|decl
              )
              \b
            )
            \b
            [\p{Pc}\p{L}]\w* # identifier
            \b
          )
        name: meta.message.ruko
        captures:
          1:
            patterns:
              - match: |
                  (?x)
                  (?:
                    ( # 1: optional access/unwrap
                      \?:?
                    ) |
                    ( # 2: assert/unwrap operator
                      !:?
                    ) |
                    ( # 3: access operator
                      ::
                    )
                  )
                captures:
                  1: {name: keyword.operator.optional.ruko}
                  2: {name: keyword.operator.assert.ruko}
                  3: {name: keyword.operator.accessor.ruko}
          2:
            patterns:
              - match: |
                  (?x)
                  (?: # Regular variables
                    # Leading underscore
                    (\p{Pc}+\w*\b(?!\p{Pc}+))
                  | # Train case
                    ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)
                  | # Pascal case
                    ((?:[\p{Pc}\p{L}&&\P{Ll}][\w&&\P{Lu}]*)+)
                  | # Camel or kebab case
                    ([\p{Pc}\p{L}]\w*)
                  )
                captures:
                  1: {name: variable.other.property.dynamic.ruko}
                  2: {name: variable.other.constant.property.ruko}
                  3: {name: variable.other.property.stat.ruko}
                  4: {name: variable.other.property.ruko}

  # Support

  css-property-names:
    patterns:
      - match: (?x)\b(additiveSymbols|alignContent|alignItems|alignSelf|all|animation|animationDelay|animationDirection|animationDuration|animationFillMode|animationIterationCount|animationName|animationPlayState|animationTimingFunction|backdropFilter|backfaceVisibility|background|backgroundAttachment|backgroundBlendMode|backgroundClip|backgroundColor|backgroundImage|backgroundOrigin|backgroundPosition|backgroundPosition[XY]|backgroundRepeat|backgroundSize|bleed|blockSize|border|borderBlockEnd|borderBlockEndColor|borderBlockEndStyle|borderBlockEndWidth|borderBlockStart|borderBlockStartColor|borderBlockStartStyle|borderBlockStartWidth|borderBottom|borderBottomColor|borderBottomLeftRadius|borderBottomRightRadius|borderBottomStyle|borderBottomWidth|borderCollapse|borderColor|borderEndEndRadius|borderEndStartRadius|borderImage|borderImageOutset|borderImageRepeat|borderImageSlice|borderImageSource|borderImageWidth|borderInlineEnd|borderInlineEndColor|borderInlineEndStyle|borderInlineEndWidth|borderInlineStart|borderInlineStartColor|borderInlineStartStyle|borderInlineStartWidth|borderLeft|borderLeftColor|borderLeftStyle|borderLeftWidth|borderRadius|borderRight|borderRightColor|borderRightStyle|borderRightWidth|borderSpacing|borderStartEndRadius|borderStartStartRadius|borderStyle|borderTop|borderTopColor|borderTopLeftRadius|borderTopRightRadius|borderTopStyle|borderTopWidth|borderWidth|bottom|boxDecorationBreak|boxShadow|boxSizing|breakAfter|breakBefore|breakInside|captionSide|caretColor|clear|clip|clipPath|clipRule|color|colorAdjust|colorInterpolationFilters|columnCount|columnFill|columnGap|columnRule|columnRuleColor|columnRuleStyle|columnRuleWidth|columnSpan|columnWidth|columns|contain|content|counterIncrement|counterReset|cursor|direction|display|emptyCells|enableBackground|fallback|fill|fillOpacity|fillRule|filter|flex|flexBasis|flexDirection|flexFlow|flexGrow|flexShrink|flexWrap|float|floodColor|floodOpacity|font|fontDisplay|fontFamily|fontFeatureSettings|fontKerning|fontLanguageOverride|fontOpticalSizing|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontSynthesis|fontVariant|fontVariantAlternates|fontVariantCaps|fontVariantEastAsian|fontVariantLigatures|fontVariantNumeric|fontVariantPosition|fontVariationSettings|fontWeight|gap|glyphOrientationHorizontal|glyphOrientationVertical|grid|gridArea|gridAutoColumns|gridAutoFlow|gridAutoRows|gridColumn|gridColumnEnd|gridColumnGap|gridColumnStart|gridGap|gridRow|gridRowEnd|gridRowGap|gridRowStart|gridTemplate|gridTemplateAreas|gridTemplateColumns|gridTemplateRows|hangingPunctuation|height|hyphens|imageOrientation|imageRendering|imageResolution|imeMode|initialLetter|initialLetterAlign|inlineSize|inset|insetBlock|insetBlockEnd|insetBlockStart|insetInline|insetInlineEnd|insetInlineStart|isolation|justifyContent|justifyItems|justifySelf|kerning|left|letterSpacing|lightingColor|lineBreak|lineClamp|lineHeight|listStyle|listStyleImage|listStylePosition|listStyleType|margin|marginBlockEnd|marginBlockStart|marginBottom|marginInlineEnd|marginInlineStart|marginLeft|marginRight|marginTop|markerEnd|markerMid|markerStart|marks|mask|maskBorder|maskBorderMode|maskBorderOutset|maskBorderRepeat|maskBorderSlice|maskBorderSource|maskBorderWidth|maskClip|maskComposite|maskImage|maskMode|maskOrigin|maskPosition|maskRepeat|maskSize|maskType|maxBlockSize|maxHeight|maxInlineSize|maxLines|maxWidth|maxZoom|minBlockSize|minHeight|minInlineSize|minWidth|minZoom|mixBlendMode|negative|objectFit|objectPosition|offset|offsetAnchor|offsetDistance|offsetPath|offsetPosition|offsetRotation|opacity|order|orientation|orphans|outline|outlineColor|outlineOffset|outlineStyle|outlineWidth|overflow|overflowAnchor|overflowBlock|overflowInline|overflowWrap|overflow-[xy]|overscrollBehavior|overscrollBehaviorBlock|overscrollBehaviorInline|overscrollBehavior-[xy]|pad|padding|paddingBlockEnd|paddingBlockStart|paddingBottom|paddingInlineEnd|paddingInlineStart|paddingLeft|paddingRight|paddingTop|pageBreakAfter|pageBreakBefore|pageBreakInside|paintOrder|perspective|perspectiveOrigin|placeContent|placeItems|placeSelf|pointerEvents|position|prefix|quotes|range|resize|right|rotate|rowGap|rubyAlign|rubyMerge|rubyPosition|scale|scrollBehavior|scrollMargin|scrollMarginBlock|scrollMarginBlockEnd|scrollMarginBlockStart|scrollMarginBottom|scrollMarginInline|scrollMarginInlineEnd|scrollMarginInlineStart|scrollMarginLeft|scrollMarginRight|scrollMarginTop|scrollPadding|scrollPaddingBlock|scrollPaddingBlockEnd|scrollPaddingBlockStart|scrollPaddingBottom|scrollPaddingInline|scrollPaddingInlineEnd|scrollPaddingInlineStart|scrollPaddingLeft|scrollPaddingRight|scrollPaddingTop|scrollSnapAlign|scrollSnapCoordinate|scrollSnapDestination|scrollSnapStop|scrollSnapType|scrollbarColor|scrollbarGutter|scrollbarWidth|shapeImageThreshold|shapeMargin|shapeOutside|shapeRendering|size|speakAs|src|stopColor|stopOpacity|stroke|strokeDashArray|strokeDashOffset|strokeLineCap|strokeLineJoin|strokeMiterLimit|strokeOpacity|strokeWidth|suffix|symbols|system|tabSize|tableLayout|textAlign|textAlignLast|textAnchor|textCombineUpright|textDecoration|textDecorationColor|textDecorationLine|textDecorationSkip|textDecorationSkipInk|textDecorationStyle|textEmphasis|textEmphasisColor|textEmphasisPosition|textEmphasisStyle|textIndent|textJustify|textOrientation|textOverflow|textRendering|textShadow|textSizeAdjust|textTransform|textUnderlinePosition|top|touchAction|transform|transformBox|transformOrigin|transformStyle|transition|transitionDelay|transitionDuration|transitionProperty|transitionTimingFunction|translate|unicodeBidi|unicodeRange|userSelect|userZoom|verticalAlign|visibility|whiteSpace|widows|width|willChange|wordBreak|wordSpacing|wordWrap|writingMode|zIndex|zoom|alignmentBaseline|baselineShift|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|cx|cy|dominantBaseline|enableBackground|fill|fillOpacity|fillRule|floodColor|floodOpacity|glyphOrientationHorizontal|glyphOrientationVertical|height|kerning|lightingColor|markerEnd|markerMid|markerStart|r|rx|ry|shapeRendering|stopColor|stopOpacity|stroke|strokeDashArray|strokeDashOffset|strokeLineCap|strokeLineJoin|strokeMiterLimit|strokeOpacity|strokeWidth|textAnchor|width|x|y|adjust|after|align|alignLast|alignment|alignmentAdjust|appearance|attachment|azimuth|backgroundBreak|balance|baseline|before|bidi|binding|bookmark|bookmarkLabel|bookmarkLevel|bookmarkTarget|borderLength|bottomColor|bottomLeftRadius|bottomRightRadius|bottomStyle|bottomWidth|box|boxAlign|boxDirection|boxFlex|boxFlexGroup|boxLines|boxOrdinalGroup|boxOrient|boxPack|break|character|collapse|column|columnBreakAfter|columnBreakBefore|count|counter|crop|cue|cueAfter|cueBefore|decoration|decorationBreak|delay|displayModel|displayRole|down|drop|dropInitialAfterAdjust|dropInitialAfterAlign|dropInitialBeforeAdjust|dropInitialBeforeAlign|dropInitialSize|dropInitialValue|duration|elevation|emphasis|family|fit|fitPosition|flexGroup|floatOffset|gap|gridColumns|gridRows|hangingPunctuation|header|hyphenate|hyphenateAfter|hyphenateBefore|hyphenateCharacter|hyphenateLines|hyphenateResource|icon|image|increment|indent|index|initialAfterAdjust|initialAfterAlign|initialBeforeAdjust|initialBeforeAlign|initialSize|initialValue|inlineBoxAlign|iterationCount|justify|label|leftColor|leftStyle|leftWidth|length|level|line|lineStacking|lineStackingRuby|lineStackingShift|lineStackingStrategy|lines|list|mark|markAfter|markBefore|marks|marquee|marqueeDirection|marqueePlayCount|marqueeSpeed|marqueeStyle|max|min|model|moveTo|name|nav|navDown|navIndex|navLeft|navRight|navUp|new|numeral|offset|ordinalGroup|orient|origin|overflowStyle|overhang|pack|page|pagePolicy|pause|pauseAfter|pauseBefore|phonemes|pitch|pitchRange|playCount|playDuring|playState|point|presentation|presentationLevel|profile|property|punctuation|punctuationTrim|radius|rate|renderingIntent|repeat|replace|reset|resolution|resource|respondTo|rest|restAfter|restBefore|richness|rightColor|rightStyle|rightWidth|role|rotation|rotationPoint|rows|ruby|rubyOverhang|rubySpan|rule|ruleColor|ruleStyle|ruleWidth|shadow|size|sizeAdjust|sizing|space|spaceCollapse|spacing|span|speak|speakHeader|speakNumeral|speakPunctuation|speech|speechRate|speed|stacking|stackingRuby|stackingShift|stackingStrategy|stress|stretch|stringSet|style|styleImage|stylePosition|styleType|target|targetName|targetNew|targetPosition|text|textHeight|textJustify|textOutline|textReplace|textWrap|timingFunction|topColor|topLeftRadius|topRightRadius|topStyle|topWidth|trim|unicode|up|userSelect|variant|voice|voiceBalance|voiceDuration|voiceFamily|voicePitch|voicePitchRange|voiceRate|voiceStress|voiceVolume|volume|weight|white|whiteSpaceCollapse|word|wrap)\b
        name: support.type.property-name.css.ruko
      - match: (?x)\b(?:ah|apple|atsc|epub|hp|khtml|moz|ms|o|rim|ro|tc|wap|webkit|xv|mso|prince)(?:[\p{Pc}\p{L}&&\P{Ll}][\w&&\P{Lu}]*)+\b
        name: support.type.vendored.property-name.css.ruko

  css-value-names:
    comment: TODO
    patterns:
      - match: (?x)\b(aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow)\b
        name: support.constant.color.w3c-standard-color-name.css.ruko
      - match: (?x)\b(aliceblue|antiquewhite|aquamarine|azure|beige|bisque|blanchedalmond|blueviolet|brown|burlywood|cadetblue|chartreuse|chocolate|coral|cornflowerblue|cornsilk|crimson|cyan|darkblue|darkcyan|darkgoldenrod|darkgray|darkgreen|darkgrey|darkkhaki|darkmagenta|darkolivegreen|darkorange|darkorchid|darkred|darksalmon|darkseagreen|darkslateblue|darkslategray|darkslategrey|darkturquoise|darkviolet|deeppink|deepskyblue|dimgray|dimgrey|dodgerblue|firebrick|floralwhite|forestgreen|gainsboro|ghostwhite|gold|goldenrod|greenyellow|grey|honeydew|hotpink|indianred|indigo|ivory|khaki|lavender|lavenderblush|lawngreen|lemonchiffon|lightblue|lightcoral|lightcyan|lightgoldenrodyellow|lightgray|lightgreen|lightgrey|lightpink|lightsalmon|lightseagreen|lightskyblue|lightslategray|lightslategrey|lightsteelblue|lightyellow|limegreen|linen|magenta|mediumaquamarine|mediumblue|mediumorchid|mediumpurple|mediumseagreen|mediumslateblue|mediumspringgreen|mediumturquoise|mediumvioletred|midnightblue|mintcream|mistyrose|moccasin|navajowhite|oldlace|olivedrab|orangered|orchid|palegoldenrod|palegreen|paleturquoise|palevioletred|papayawhip|peachpuff|peru|pink|plum|powderblue|rebeccapurple|rosybrown|royalblue|saddlebrown|salmon|sandybrown|seagreen|seashell|sienna|skyblue|slateblue|slategray|slategrey|snow|springgreen|steelblue|tan|thistle|tomato|transparent|turquoise|violet|wheat|whitesmoke|yellowgreen)\b
        name: support.constant.color.w3c-extended-color-name.css.ruko
      - match: (?x)\b(currentColor)\b
        name: support.constant.color.current.css.ruko
      - match: (?x)\b(ActiveBorder|ActiveCaption|AppWorkspace|Background|ButtonFace|ButtonHighlight|ButtonShadow|ButtonText|CaptionText|GrayText|Highlight|HighlightText|InactiveBorder|InactiveCaption|InactiveCaptionText|InfoBackground|InfoText|Menu|MenuText|Scrollbar|ThreeDDarkShadow|ThreeDFace|ThreeDHighlight|ThreeDLightShadow|ThreeDShadow|Window|WindowFrame|WindowText)\b
        name: support.constant.color.system.css.ruko
      - match: (?x)\b(above|absolute|active|add|additive|afterEdge|alias|all|allPetiteCaps|allScroll|allSmallCaps|alpha|alphabetic|alternate|alternateReverse|always|antialiased|auto|autoPos|available|avoid|avoidColumn|avoidPage|avoidRegion|backwards|balance|baseline|beforeEdge|below|bevel|bidiOverride|blink|block|blockAxis|blockStart|blockEnd|bold|bolder|border|borderBox|both|bottom|bottomOutside|breakAll|breakWord|bullets|butt|capitalize|caption|cell|center|central|char|circle|clip|clone|closeQuote|closestCorner|closestSide|colResize|collapse|color|colorBurn|colorDodge|column|columnReverse|commonLigatures|compact|condensed|contain|content|contentBox|contents|contextMenu|contextual|copy|cover|crispEdges|crispEdges|crosshair|cyclic|darken|dashed|decimal|default|dense|diagonalFractions|difference|digits|disabled|disc|discretionaryLigatures|distribute|distributeAllLines|distributeLetter|distributeSpace|dot|dotted|double|doubleCircle|downleft|downright|eResize|eachLine|ease|easeIn|easeInOut|easeOut|economy|ellipse|ellipsis|embed|end|evenodd|ewResize|exact|exclude|exclusion|expanded|extends|extraCondensed|extraExpanded|fallback|farthestCorner|farthestSide|fill|fillAvailable|fillBox|filled|fitContent|fixed|flat|flex|flexEnd|flexStart|flip|flowRoot|forwards|freeze|fromImage|fullWidth|geometricPrecision|georgian|grab|grabbing|grayscale|grid|groove|hand|hanging|hardLight|help|hidden|hide|historicalForms|historicalLigatures|horizontal|horizontalTb|hue|icon|ideographAlpha|ideographNumeric|ideographParenthesis|ideographSpace|ideographic|inactive|infinite|inherit|initial|inline|inlineAxis|inlineBlock|inlineEnd|inlineFlex|inlineGrid|inlineListItem|inlineStart|inlineTable|inset|inside|interCharacter|interIdeograph|interWord|intersect|invert|isolate|isolateOverride|italic|jis04|jis78|jis83|jis90|justify|justifyAll|kannada|keepAll|landscape|large|larger|left|lighten|lighter|line|lineEdge|lineThrough|linear|linearRGB|liningNums|listItem|local|loose|lowercase|lr|lrTb|ltr|luminance|luminosity|mainSize|mandatory|manipulation|manual|marginBox|matchParent|matchSource|mathematical|maxContent|medium|menu|messageBox|middle|minContent|miter|mixed|move|multiply|nResize|narrower|neResize|nearestNeighbor|neswResize|newspaper|noChange|noClip|noCloseQuote|noCommonLigatures|noContextual|noDiscretionaryLigatures|noDrop|noHistoricalLigatures|noOpenQuote|noRepeat|none|nonzero|normal|notAllowed|nowrap|nsResize|numbers|numeric|nwResize|nwseResize|oblique|oldstyleNums|open|openQuote|optimizeLegibility|optimizeQuality|optimizeSpeed|optional|ordinal|outset|outside|over|overlay|overline|padding|paddingBox|page|painted|panDown|panLeft|panRight|panUp|panX|panY|paused|petiteCaps|pixelated|plaintext|pointer|portrait|pre|preLine|preWrap|preserve3d|progress|progressive|proportionalNums|proportionalWidth|proximity|radial|recto|region|relative|remove|repeat|repeat-[xy]|resetSize|reverse|revert|ridge|right|rl|rlTb|round|row|rowResize|rowReverse|rowSeverse|rtl|ruby|rubyBase|rubyBaseContainer|rubyText|rubyTextContainer|runIn|running|sResize|saturation|scaleDown|screen|scroll|scrollPosition|seResize|semiCondensed|semiExpanded|separate|sesame|show|sideways|sidewaysLeft|sidewaysLr|sidewaysRight|sidewaysRl|simplified|slashedZero|slice|small|smallCaps|smallCaption|smaller|smooth|softLight|solid|space|spaceAround|spaceBetween|spaceEvenly|spellOut|square|sRGB|stackedFractions|start|stat|statusBar|swap|stepEnd|stepStart|sticky|stretch|strict|stroke|strokeBox|style|sub|subgrid|subpixelAntialiased|subtract|super|swResize|symbolic|table|tableCaption|tableCell|tableColumn|tableColumnGroup|tableFooterGroup|tableHeaderGroup|tableRow|tableRowGroup|tabularNums|tb|tbRl|text|textAfterEdge|textBeforeEdge|textBottom|textTop|thick|thin|titlingCaps|top|topOutside|touch|traditional|transparent|triangle|ultraCondensed|ultraExpanded|under|underline|unicase|unset|upleft|uppercase|upright|useGlyphOrientation|useScript|verso|vertical|verticalIdeographic|verticalLr|verticalRl|verticalText|viewBox|visible|visibleFill|visiblePainted|visibleStroke|wResize|wait|wavy|weight|whitespace|wider|words|wrap|wrapReverse|x|xLarge|xSmall|xxLarge|xxSmall|y|zero|zoomIn|zoomOut)\b
        name: support.constant.property-value.css.ruko
      - match: (?x)\b(arabicIndic|armenian|bengali|cambodian|circle|cjkDecimal|cjkEarthlyBranch|cjkHeavenlyStem|cjkIdeographic|decimal|decimalLeadingZero|devanagari|disc|disclosureClosed|disclosureOpen|ethiopicHalehameAm|ethiopicHalehameTiE[rt]|ethiopicNumeric|georgian|gujarati|gurmukhi|hangul|hangulConsonant|hebrew|hiragana|hiraganaIroha|japaneseFormal|japaneseInformal|kannada|katakana|katakanaIroha|khmer|koreanHangulFormal|koreanHanjaFormal|koreanHanjaInformal|lao|lowerAlpha|lowerArmenian|lowerGreek|lowerLatin|lowerRoman|malayalam|mongolian|myanmar|oriya|persian|simpChineseFormal|simpChineseInformal|square|tamil|telugu|thai|tibetan|tradChineseFormal|tradChineseInformal|upperAlpha|upperArmenian|upperLatin|upperRoman|urdu)\b
        name: support.constant.property-value.list-style-type.css.ruko
      - match: (?x)\b(arial|century|comic|courier|garamond|georgia|helvetica|impact|lucida|symbol|systemUi|system|tahoma|times|trebuchet|uiMonospace|uiRounded|uiSansSerif|uiSerif|utopia|verdana|webdings|sansSerif|serif|monospace)\b
        name: support.constant.font-name.css.ruko

  html-tag-names:
    patterns:
      - match: (?x)\b(all|print|screen|speech|aural|braille|embossed|handheld|projection|tty|tv)\b
        name: support.constant.media.css.ruko
      - match: (?x)\b(a|abbr|acronym|address|altGlyph|altGlyphDef|altGlyphItem|animate|animateColor|animateMotion|animateTransform|annotation|annotationXml|applet|area|article|aside|audio|b|base|basefont|bdi|bdo|bgsound|big|blink|blockquote|body|br|button|canvas|caption|center|circle|cite|clipPath|code|col|colgroup|colorProfile|command|content|cursor|data|datalist|dd|defs|del|desc|details|dfn|dialog|dir|discard|div|dl|dt|elem|ellipse|em|embed|feBlend|feColorMatrix|feComponentTransfer|feComposite|feConvolveMatrix|feDiffuseLighting|feDisplacementMap|feDistantLight|feDropShadow|feFlood|feFuncA|feFuncB|feFuncG|feFuncR|feGaussianBlur|feImage|feMerge|feMergeNode|feMorphology|feOffset|fePointLight|feSpecularLighting|feSpotLight|feTile|feTurbulence|fieldset|figcaption|figure|filter|font|fontFace|fontFaceFormat|fontFaceName|fontFaceSrc|fontFaceUri|footer|foreignObject|form|frame|frameset|g|glyph|glyphRef|hatch|hatchpath|hd|head|header|hgroup|hkern|hr|html|h[1-6]|i|iframe|image|img|input|ins|isindex|kbd|keygen|label|legend|li|line|linearGradient|link|listing|maction|main|maligngroup|malignmark|map|mark|marker|marquee|mask|math|menclose|menu|menuitem|merror|mesh|meshgradient|meshpatch|meshrow|meta|metadata|meter|mfenced|mfrac|mglyph|mi|missingGlyph|mlabeledtr|mlongdiv|mmultiscripts|mn|mo|mover|mpadded|mpath|mphantom|mroot|mrow|ms|mscarries|mscarry|msgroup|msline|mspace|msqrt|msrow|mstack|mstyle|msub|msubsup|msup|mtable|mtd|mtext|mtr|multicol|munder|munderover|nav|nextid|nobr|noembed|noframes|noscript|object|ol|optgroup|option|output|p|param|path|pattern|picture|plaintext|polygon|polyline|pre|progress|q|radialGradient|rb|rect|rp|rt|rtc|ruby|s|samp|script|section|select|semantics|set|shadow|slot|small|solidcolor|source|spacer|span|stop|strike|strong|style|sub|summary|sup|svg|switch|symbol|table|tbody|td|template|text|textarea|textPath|tfoot|th|thead|time|title|tr|track|tref|tspan|tt|u|ul|use|var|video|view|vkern|wbr|xmp)\b
        name: entity.name.tag.css.ruko

  entities:
    patterns:
      - include: '#function-names'
      - include: '#constant-names'
      - include: '#type-names'
      - include: '#variable-names'

  type-names:
    comment: Names for built-in types
    patterns:
      - comment: Primitive classes
        match: |
          (?x)\s*(?<![?!]?\.|[?!:]:)\b(
            # upper flat case
            Bool|Char|Rune|Str|Sym|Text|Buf
            |(Big)?(Num|Nat|U?Int|Float|Frac|Real|Imag|Complex)
            # lower flat case
            |bool|char|rune|str|sym|text|buf
            |(big)?(num|nat|u?int|float|frac|real|imag|complex)
            # upper flat case
            |[iucjfb](8|16|32|64|128|256|512|1024)
            |[IUCJFB](8|16|32|64|128|256|512|1024)
          )\b
        name: support.type.builtin.primitive.ruko
      - comment: Data query classes
        match: |
          (?x)\s*(?<![?!]?\.|[?!:]:)\b(
            Array|Tuple|Set|Map|Object|Seq|Record|Dict
            |Proc|Range|Stack|Heap|Queue|Tree|Trie|Graph
            |Future|Stream|RegExp|Func|Buffer|FSe[tq]
            # lower flat case
            |array|tuple|set|map|object|seq|record|dict
            |proc|range|stack|heap|queue|tree|trie|graph
            |future|stream|regexp|func|buffer|fse[tq]
          )\b
        name: support.type.builtin.ruko
      - comment: Constant/algebraic classes
        match: |
          (?x)\s*(?<![?!]?\.|[?!:]:)\b(
            True|False|Null|Void|NaN|Inf|Empty|Unit|Object
            |Any|Mixed|Just|Some|None|Never|(Im)?pure|Const|Undef
            # lower flat case
            |true|false|null|void|nan|inf|empty|unit|obj
            |any|mixed|just|some|none|never|(im)?pure|const|undef
          )\b
        name: support.type.primitive.ruko
      - comment: Error classes | BaseError, etc
        match: \s*\b((\p{Lu}[\w&&\P{Lu}]*)+)?(Error|Exception)\b
        name: support.class.error.ruko
      - comment: Interface classes | IEnumerable, etc
        match: \s*\bI((\p{Lu}[\w&&\P{Lu}]*)+)\b
        name: entity.name.interface.ruko
      - comment: Namespace classes | NSString, etc
        match: \s*\bNS((\p{Lu}[\w&&\P{Lu}]*)+)\b
        name: entity.name.namespace.ruko
      - comment: Trait classes | Serializable, Loggable etc
        match: \s*\b((\p{Lu}[\w&&\P{Lu}]*)+)able\b
        name: support.class.trait.ruko
      - comment: Algebraic data types
        match: \s*\b(Some|None|Just|Ok|Err|Left|Right)\b\s*
        name: support.class.algebraic.ruko
      - include: '#support-classes'

  support-classes:
    comment: Ruko probably won't have a large set of built-in classes,
      so we include common built-in types from major languages
      to improve recognition of cross-language codebases
    patterns:
      - include: source.python#builtin-exceptions
      - include: source.php#class-builtin
      - include: source.swift#builtin-types-builtin-protocol-type
      - include: source.swift#builtin-types-builtin-struct-type
      - include: source.swift#builtin-types-builtin-enum-type
      - include: source.swift#builtin-types-builtin-class-type
      - include: source.swift#builtin-types

      # ShaderLab
      - name: support.type.basic.shaderlab
        match: \b(Range|Float|Int|Color|Vector|2D|3D|Cube|Any)\b
      - include: '#numbers'
      - name: storage.type.structure.shaderlab
        match: \b(Shader|Properties|SubShader|Pass|Category)\b
      - name: support.type.propertyname.shaderlab
        match: \b(Name|Tags|Fallback|CustomEditor|Cull|ZWrite|ZTest|Offset|Blend|BlendOp|ColorMask|AlphaToMask|LOD|Lighting|Stencil|Ref|ReadMask|WriteMask|Comp|CompBack|CompFront|Fail|ZFail|UsePass|GrabPass|Dependency|Material|Diffuse|Ambient|Shininess|Specular|Emission|Fog|Mode|Density|SeparateSpecular|SetTexture|Combine|ConstantColor|Matrix|AlphaTest|ColorMaterial|BindChannels|Bind)\b
      - name: support.type.property-value.shaderlab
        match: \b(Back|Front|On|Off|[RGBA]{1,3}|AmbientAndDiffuse|Emission)\b
      - name: support.type.property-value.comparisonfunction.shaderlab
        match: \b(Less|Greater|LEqual|GEqual|Equal|NotEqual|Always|Never)\b
      - name: support.type.property-value.stenciloperation.shaderlab
        match: \b(Keep|Zero|Replace|IncrSat|DecrSat|Invert|IncrWrap|DecrWrap)\b
      - name: support.type.property-value.texturecombiners.shaderlab
        match: \b(Previous|Primary|Texture|Constant|Lerp|Double|Quad|Alpha)\b
      - name: support.type.property-value.fog.shaderlab
        match: \b(Global|Linear|Exp2|Exp)\b
      - name: support.type.property-value.bindchannels.shaderlab
        match: \b(Vertex|Normal|Tangent|TexCoord0|TexCoord1)\b
      - name: support.type.property-value.blendoperations.shaderlab
        match: \b(Add|Sub|RevSub|Min|Max|LogicalClear|LogicalSet|LogicalCopyInverted|LogicalCopy|LogicalNoop|LogicalInvert|LogicalAnd|LogicalNand|LogicalOr|LogicalNor|LogicalXor|LogicalEquiv|LogicalAndReverse|LogicalAndInverted|LogicalOrReverse|LogicalOrInverted)\b
      - name: support.constant.property-value.blendfactors.shaderlab
        match: \b(One|Zero|SrcColor|SrcAlpha|DstColor|DstAlpha|OneMinusSrcColor|OneMinusSrcAlpha|OneMinusDstColor|OneMinusDstAlpha)\b

      # Objective-C++
      - include: source.objcpp#anonymous_pattern_17
      - include: source.objcpp#anonymous_pattern_18
      - include: source.objcpp#anonymous_pattern_19
      - include: source.objcpp#anonymous_pattern_20
      - include: source.objcpp#anonymous_pattern_21
      - include: source.objcpp#anonymous_pattern_22
      - include: source.objcpp#anonymous_pattern_23
      - include: source.objcpp#anonymous_pattern_24
      - include: source.objcpp#anonymous_pattern_25

  support-functions:
    comment: |
      Names for general support functions in Ruko standard library
      organized by naming conventions for maintainability
    patterns:
      - comment: predicate functions
        match: \s*\b(i|ha)s(\p{Lu}[\w&&\P{Lu}]*)+\b\s*
        name: support.function.predicate.ruko
      - comment: conversion functions
        match: \s*\b(to|from)(\p{Lu}[\w&&\P{Lu}]*)+\b\s*
        name: support.function.type.ruko
      - comment: magic functions like __init__, __str__, etc
        match: \s*\b\p{Pc}+([\p{Pc}\p{L}]\w*)+\p{Pc}+\b\s*
        name: support.function.magic.ruko
      - match: \s*\b[gs]et(\p{Lu}[\w&&\P{Lu}]*)+\b\s*
        name: support.function.accessor.ruko
      - include: '#support-functions-core'

  support-functions-core:
    comment: Core built-in functions from major languages,
      to improve recognition of cross-language codebases
    patterns:
      - include: source.coffeescript#method_names
      - include: source.coffeescript#function_names
      - include: source.swift#builtin-functions
      - include: source.swift#builtin-global-functions
      - include: source.php#support
      - include: source.r#builtin-functions
      - include: source.objcpp#c_functions

      # Lua
      - match: (?<![^.]\.|:)\b(assert|collectgarbage|dofile|error|getfenv|getmetatable|ipairs|load|loadfile|loadstring|module|next|pairs|pcall|print|rawequal|rawget|rawlen|rawset|require|select|setfenv|setmetatable|tonumber|tostring|type|unpack|xpcall)\b(?!\s*=(?!=))
        name: support.function.lua
      - match: (?<![^.]\.|:)\b(coroutine\.(create|isyieldable|close|resume|running|status|wrap|yield)|string\.(byte|char|dump|find|format|gmatch|gsub|len|lower|match|pack|packsize|rep|reverse|sub|unpack|upper)|table\.(concat|insert|maxn|move|pack|remove|sort|unpack)|math\.(abs|acos|asin|atan2?|ceil|cosh?|deg|exp|floor|fmod|frexp|ldexp|log|log10|max|min|modf|pow|rad|random|randomseed|sinh?|sqrt|tanh?|tointeger|type)|io\.(close|flush|input|lines|open|output|popen|read|tmpfile|type|write)|os\.(clock|date|difftime|execute|exit|getenv|remove|rename|setlocale|time|tmpname)|package\.(loadlib|seeall|searchpath)|debug\.(debug|[gs]etfenv|[gs]ethook|getinfo|[gs]etlocal|[gs]etmetatable|getregistry|[gs]etupvalue|[gs]etuservalue|set[Cc]stacklimit|traceback|upvalueid|upvaluejoin)|bit32\.(arshift|band|bnot|bor|btest|bxor|extract|replace|lrotate|lshift|rrotate|rshift)|utf8\.(char|codes|codepoint|len|offset))\b(?!\s*=(?!=))
        name: support.function.library.lua

      # Ruby
      - match: \b(abort|at_exit|autoload[?]?|binding|callcc|caller|caller_locations|chomp|chop|eval|exec|exit|exit!|fork|format|gets|global_variables|gsub|lambda|load|local_variables|open|p|print|printf|proc|putc|puts|rand|readline|readlines|select|set_trace_func|sleep|spawn|sprintf|srand|sub|syscall|system|test|trace_var|trap|untrace_var|warn)(\b|(?<=[?!]))(?![?!])
        name: support.function.kernel.ruby

      # SQL
      - match: \b(avg|checksum_agg|count|count_big|grouping|grouping_id|max|min|sum|stdev|stdevp|var|varp)\b
        name: support.function.aggregate.sql
      - match: \b(cume_dist|first_value|lag|last_value|lead|percent_rank|percentile_cont|percentile_disc)\b
        name: support.function.analytic.sql
      - match: \b(cast|convert|parse|try_cast|try_convert|try_parse)\b
        name: support.function.conversion.sql
      - match: \b(cursor_status)\b
        name: support.function.cursor.sql
      - match: \b(sysdatetime|sysdatetimeoffset|sysutcdatetime|current_time(stamp)?|getdate|getutcdate|datename|datepart|day|month|year|datefromparts|datetime2fromparts|datetimefromparts|datetimeoffsetfromparts|smalldatetimefromparts|timefromparts|datediff|dateadd|eomonth|switchoffset|todatetimeoffset|isdate)\b
        name: support.function.datetime.sql
      - match: \b(coalesce|nullif)\b
        name: support.function.expression.sql
      - match: (?<!@)@@(?i)\b(cursor_rows|connections|cpu_busy|datefirst|dbts|error|fetch_status|identity|idle|io_busy|langid|language|lock_timeout|max_connections|max_precision|nestlevel|options|packet_errors|pack_received|pack_sent|procid|remserver|rowcount|servername|servicename|spid|textsize|timeticks|total_errors|total_read|total_write|trancount|version)\b
        name: support.function.globalvar.sql
      - match: \b(choose|iif)\b
        name: support.function.logical.sql
      - match: \b(abs|acos|asin|atan|atn2|ceiling|cos|cot|degrees|exp|floor|log|log10|pi|power|radians|rand|round|sign|sin|sqrt|square|tan)\b
        name: support.function.mathematical.sql
      - match: \b(app_name|applock_mode|applock_test|assemblyproperty|col_length|col_name|columnproperty|database_principal_id|databasepropertyex|db_id|db_name|file_id|file_idex|file_name|filegroup_id|filegroup_name|filegroupproperty|fileproperty|fulltextcatalogproperty|fulltextserviceproperty|index_col|indexkey_property|indexproperty|object_definition|object_id|object_name|object_schema_name|objectproperty|objectpropertyex|original_db_name|parsename|schema_id|schema_name|scope_identity|serverproperty|stats_date|type_id|type_name|typeproperty)\b
        name: support.function.metadata.sql
      - match: \b(rank|dense_rank|ntile|row_number)\b
        name: support.function.ranking.sql
      - match: \b(opendatasource|openrowset|openquery|openxml)\b
        name: support.function.rowset.sql
      - match: \b(certencoded|certprivatekey|current_user|database_principal_id|has_perms_by_name|is_member|is_rolemember|is_srvrolemember|original_login|permissions|pwdcompare|pwdencrypt|schema_id|schema_name|session_user|suser_id|suser_sid|suser_sname|system_user|suser_name|user_id|user_name)\b
        name: support.function.security.sql
      - match: \b(ascii|char|charindex|concat|difference|format|left|len|lower|ltrim|nchar|nodes|patindex|quotename|replace|replicate|reverse|right|rtrim|soundex|space|str|string_agg|string_escape|string_split|stuff|substring|translate|trim|unicode|upper)\b
        name: support.function.string.sql
      - match: \b(binary_checksum|checksum|compress|connectionproperty|context_info|current_request_id|current_transaction_id|decompress|error_line|error_message|error_number|error_procedure|error_severity|error_state|formatmessage|get_filestream_transaction_context|getansinull|host_id|host_name|isnull|isnumeric|min_active_rowversion|newid|newsequentialid|rowcount_big|session_context|session_id|xact_state)\b
        name: support.function.system.sql
      - match: \b(patindex|textptr|textvalid)\b
        name: support.function.textimage.sql

      # Python
      - name: support.function.legacy.builtin.python
        match: (?x)(?<!\.)\b(file|reduce|intern|raw_input|unicode|cmp|basestring|execfile|long|xrange)\b
      - include: source.python#builtin-functions
      - include: source.python#builtin-types
      - include: source.python#magic-function-names
