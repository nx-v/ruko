name: Ruko
scopeName: source.spwn # will change to Ruko once the language is out
fileTypes: [ruko, rk, spwn]
patterns: [include: '#core']

# Last updated: December 9, 2025
#
# This file is entirely maintained by NexoVolta (nx-v) for the Ruko programming
# language. If you want to contribute, please open an issue or a pull request
# on the official GitHub repository:
#
# https://github.com/nx-v/ruko
#
# Note that this grammar is still actively being developed alongside
# the compiler and spec itself, so frequent updates may be necessary.
#
# If you find any bugs or want to suggest any new features, please
# open an issue or a pull request on the repository above.

# Planned features / TODOs:
#
# - [ ] Add inline assembly syntax for WebAssembly with a syntax similar to
#   Rust's asm! macro and Solidity's inline assembly.
#     https://doc.rust-lang.org/nightly/std/arch/wasm32/asm/index.html
# - [ ] Add regexp patterns for Unicode character properties, scripts, blocks,
#   categories, etc. Refer to: https://www.unicode.org/reports/tr18/
# - Some patterns should have `applyEndPatternLast: true` where appropriate
#   to make patterns more modular and easier to maintain, rather than
#   having everything in one big pattern.
# - Add more tests for all patterns to ensure they work as intended.
# - Duplicate patterns using the alias/merge feature in YAML (&,*,<<)
#   to reduce redundancy and make maintenance easier.
#   - Each section in the grammar has a built-in repository for this purpose.
# - All patterns should have better comments explaining what they do.
# - Add support for s-expressions (Lisp-style syntax) as an alternative
#   syntax for function calls and expressions. This will require a massive
#   refactor of the grammar to implement properly.
# - Add full support for significant whitespace (like Python, Haskell, etc.)
#   as an alternative to curly braces for blocks. A massive refactor will
#   be needed to implement this properly.
# - Add support for reflection and meta-programming syntax, used for
#   compile-time code generation, type introspection, etc. on the level
#   of the language itself rather than relying on external tools.
#   Refer to the "Safe C++" and "Reflection" propsals for the C++26 standard
#   for inspiration.
#   https://safecpp.org/draft.html
#   https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2996r0.html
#   - [x] Add splicing syntax <[ ]>. Splicing is used to insert code at compile-time.
# - [ ] Rework inline Markdown syntax. Refer to Typst, Textile, Texy,
#   AsciiDoc and other lightweight markup languages for inspiration.
#   - [x] Headings and subheadings
#   - [x] Deleted and inserted text ~~deleted~~ ++inserted++
#   - [x] Superscript ^super^
#   - [x] Subscript ~sub~
#   - [x] Highlighted text ==highlight==
#   - [x] Redacted text ||redacted||
#   - [ ] Inline math $$math$$
#   - [ ] Spans !!.custom.classes span!!
#   - [ ] Selectors and anchors #anchor .class
#   - [ ] Code blocks
#   - [ ] Definition blocks :::
#   - [ ] Tables | Header 1 | Header 2 |
#   - [ ] Citations
#   - References:
#     https://docs.asciidoctor.org/asciidoc/latest/
#     https://typst.app/docs/reference/
#     https://texy.nette.org/en/
#     https://textile-lang.com/
# - [ ] Plan and implement all the built-in modules, classes, objects, constants
#   functions and properties for Ruko's standard library.
#   This would all be done in a separate PR and once the grammar is completely
#   finished.
# - [ ] Multi-base numeric literals (up to base 64). Digits will be \d, a-z,
#   lowercase Icelandic thorn, lowercase eth, A-Z, uppercase Icelandic thorn.
# - [ ] Add new parameter binding/destructuring syntax for:
#   - [ ] Strings (yes, strings are meant to be destructured)
#   - [ ] Regular expressions (yes, regex captures should be destructured)
#   - [ ] Arrays
#   - [ ] Sets
#   - [ ] Maps and objects
#   - [ ] Tuples
#   - [ ] Function arguments
#   - [ ] Variables
# - [x] Fix and expand regex syntax and highlighting:
#   - [x] Add support for fuzzy matching (edits, insertions, deletions, etc.)
#   - [x] Improve highlighting for regexes with flags
#   - [x] Add and expand quantifiers and range highlighting

# Changelog of notable changes since initial release:
#
# - Refactored and improved syntax highlighting for operators.
#   Operators are now highlighted more consistently. More Unicode
#   symbols will be added in future updates.
# - Added infix function call syntax using backslashes, similar to Haskell.
#   For example: a \x\ b is equivalent to x(a, b).
#   This now means that operators CANNOT start or end with a backslash,
#   and backslashes cannot be used prefix or postfix,
#   same with angle brackets, pipes, and forward slashes,
#   which are used for JSX/generics, lambdas and regexes respectively.
# - Brought back Haskell-style function call syntax with
#   space OR comma-separated arguments.
#     funcName arg1 arg2 { arg3: 10 }; or
#     funcName arg1, arg2, { arg3: 10 }
#   This CANNOT be mixed and matched with normal function call syntax.
#   Use either one or the other consistently.
#     funcName(arg1, arg2, { arg3: 10 })
#   Named arguments are supported only in the latter syntax.
#   All arguments after the first named argument MUST be named as well.
#     funcName(arg1: 10, &mut arg2, stat const arg3: { k: v } as MyType)
# - Add operator definition syntax for user-defined operators.
#   oper param <suffix>: return_type { ... }
#   oper <prefix> param: return_type { ... }
#   oper param1 <infix> param2: return_type { ... }
#   oper param1 <ternary_1> param2 <ternary_2> param3: return_type { ... }
#   Example: oper x ** y -> f64 = pow(x, y)
# - Added Python slicing syntax for arrays, strings, tuples, etc.:
#   array[start:end:step]
#   string[start:end:step]
#   tuple[start:end:step]
#   Negative indices and arbitrary expressions are supported.
# - Added C(++) directives: #include, #define, #ifdef, #ifndef, #else,
#   #elif, #endif, #pragma, #region, #endregion, #once, #error, #warning.
#   These can be placed anywhere in the code, and will be processed before compilation.
#   A change to #define directives is that they can support regex
#   replacements as well as normal text replacements. This is dangerous,
#   so use with caution.
# - Added new keywords: expr, eval, init (C++ static init) and comp (Zig comptime).
# - Overall syntax has been reworked to be terser and more consistent.
#   Inspired by Rust, Zig, Flix, Jai, Odin, D, Reason and Motoko.
# - Import/export/module syntax inspired by JavaScript/TypeScript, Rust and Python:
#   - glob file path matching: import path/**/*.ruko
#   - named imports/exports: import module{a,b,c}
#   - default imports/exports: import module)
#   - renaming imports/exports: import module{a:x,b:y}
#   - show/hide mechanism: import module{a,b-c,d}
#   - glob-style pattern matching: import module{a*,b?,c{1,2}}
# - Fixed many JSX/XML bugs with tags and attributes:
#   - Fixed attributes not highlighting properly in self-closing tags.
#     <MyComponent prop="value" />
#   - Fixed attributes with no values not highlighting properly.
#     <MyComponent disabled />
#   - Fixed nested tags not highlighting properly.
#     <Parent><Child></Child></Parent>
#   - Fixed the final '>' in an implicit closing tag '</>' not being highlighted properly.
#     <MyComponent></> now highlights the final > properly.
#   - Fixed comments within tags not highlighting properly.
#   - __New inline Markdown-like syntax:__
#     - **bold** __bold__
#     - _italic_ *italic*
#     - ~~deleted~~ ++inserted++
#     - ==highlighted==
#     - ||redacted||
#     - ^superscript^
#     - ~subscript~
#     - ``code``
#     - imported links: [text](url)
#   - A line starting with '>' starts a code block until the end of the line.  Use
#     brackets, braces or strings to span multiple lines.
#     <div>
#       > let x = 10
#       Normal text here.
#     </>
#   - Same for headings, which start with '# ## ### #### ##### ######' etc.
#     <div>
#       ### This is a heading
#       > let y = 20
#       More normal text.
#     </>
#   - Blockquotes now start with '*' rather than '>', to avoid conflicts with code blocks.
#     <div>
#       * This is a blockquote.
#         It can span multiple lines.
#     </>
#   - '+' and '-' indicate ordered and unordered list items respectively.
#     <div>
#       + Item 1
#       + Item 2
#         - Subitem 2.1
#         - Subitem 2.2
#       + Item 3
#     </>
#   Add dynamic JSX/XML literals where <(expr)/> evaluates to an `elem`.
# - Fix bug with highlighting of generics when followed by
#   ! or ~ macro/destructor calls. For example: Vec<int>!(), MyType~().
# - Brought back train-case for CSS properties and HTML attributes.
#   For example: background-color, font-size, border-radius, my-component, etc.
# - Added x->y syntax for C++-style pointer dereferencing.
#   object->method(arg1, arg2)
#   object->property
# - Custom modifiers can now be placed before any declaration or binding, including
#   in lambda functions, for example: async inplace func sort(x: []int) { ... }
#   This includes within map declarations and function parameters, though the
#   contextual keyword 'fn' is required in order to use those modifiers.
# - Reworked function parameter binding/destructuring syntax. For example:
#   func f(const (a, b), let {c, d}, mut [e, f], dyn g) { ... }
# - Function calls are highlighted more consistently, triggering beside ( and { only,
#   and in s-expressions right after an opening (. When a function call is assigned
#   to a variable, or used in an expression, the call is highlighted more consistently
#   and the function call must be bracketed.
# - Added Objective C-style method call syntax using square brackets:
#   [object method: arg1, arg2]. Note that the colon (:) is required after
#   each method name.
# - Added keywords temp, prop, actor, realm, style, script, intern, extern,
#   assert, check, given, using, state, decl, and debug.
#   These are used for various purposes such as temporary variables, properties,
#   actors (concurrency), realms (namespaces), styles (CSS), scripts (JS),
#   internal/external linkage, assertions, context parameters, state variables,
#   declarations, and debugging.
# - Fixed empty generics: T<> is now highlighted properly in calls and annotations.
#   Fixed generics before curly braces. T<C> { x } does not trigger another type
#   annotation and highlights a regular block.
# - Added syntax for macro `x!()` and destructor `x~()` calls. These are placed
#   after the generics if any. For example: Vec<int>!(), MyType~().
# - Fixed style k-v pairs in style blocks which highlight until a semicolon, comma
#   or closing brace.
# - All control structures do not need to be bracketed. If the body of a
#   control structure is a single statement, the braces can be omitted,
#   and is replaced by a colon (:). This includes if, for, while, switch,
#   match, try, catch, etc.
# - Fixed syntax highlighting of code blocks beside lambda pipes.
# - Added numeric literals for all bases from 2 to 16, including special digits
#   for base 12 (including Unicode Turned 2 and Turned 3 for digits 10 and 11).
#   Base 12 (0z, \z in strings and character classes) uses digits \d,
#   A, X, T, or turned 2 for digit 10, and B, E or turned 3 for digit 11.
# - Numbers and escape sequences have been reworked, and will no longer accept
#   invalid digits for their respective bases beyond 0x10FFFF, or decimal 1114111.
# - Most keywords should have a max of 6 characters. Longer keywords have been
#   shortened or removed. For example, 'function' is 'func', 'property' is 'prop',
#   'template' is 'temp', 'iterator' is 'iter', etc.
# - Range keywords to, till and by have been removed in favor of Swift-like
#   range operators '>..', '...', '..<' and '>.<', and the step operator '..''.
# - Generics now capture properly before and after function and type names.
#   For example, T.<x>, T?.<x>, T!.<x>, T::<x>, T?:<x>, T!:<x>.
#   They can even be curried: x<T><U>(y), x<T><U><V>(y).
# - Generic type parameters now work for prefix operators as well. i.e. T<&x>, etc.
# - Fixed a bug where escape sequences for literals would accept integers bigger than
#   decimal 1114111 which now are highlighted as an error.
# - Bases 4 and 6 have been removed, though a multi-base (up to base 64)
#   numeric literal is still in the works.
# - Interpolation and formatting syntax have been reworked and fixed, and can now
#   span multiple lines and beyond 20 nested layers thanks to applyEndPatternLast.
#   Because of this, spacing around most of the patterns here have also been removed;
#   a separate 'space' scope is added to join everything together.
# - Fixed some bugs with regular expressions:
#   - Added and expanded quantifiers and range highlighting
#   - Add support for fuzzy matching (edits, insertions, deletions, etc.)
#   - Improved highlighting for regexes with flags
# - Added prefixes to strings, with those prefixes being the symbols used to
#   enable those features.
#   - Prefix \ makes a string raw (i.e. no escape sequences),
#   - Prefix % makes a string formatted (i.e. with interpolation and format specifiers),
#   - Prefix $ allows interpolation without formatting (i.e. simple variable/expression
#     substitution).
#   - Prefix # makes a string a #template string, which supports all features
#     and is used specifically to mark arguments inside template strings.
#   These prefixes can be combined in any order, including multiple times.
#   These will be added to regular expressions later on.
# - Added Python negation syntax: is not, if not, not in, not of.
#   - Removed unless/until keywords. Replaced by if not, while not.
# - Switched around regular expressions and unquoted strings:
#   / triggers a regex when it begins an expression. ` is now used to begin
#   unquoted strings.
# - Two (or more) regular expressions in a row on the same line without a comma
#   triggers a replacement string instead of a normal regular expression literal.
# - Changed up syntax highlighting of switch and match statements to be more
#   consistent with JavaScript.
# - Function calls now trigger beside '(' and '{'.
# - Removed Perl/Ruby's unless and until keywords. Use 'if!' and 'while!' instead.
#   for! is not supported due to the way for-loops are structured.
# - Fixed module syntax to be more consistent with JavaScript.
# - Dashes will no longer be allowed in identifiers. Use underscores instead.
# - Fixed XML highlighting and attributes, inspired by Svelte, Angular (TS), HAML
#   - @directive
#   - #id and .class
#   - :event and |pipe (both from Svelte)
#   - %directive
#   - &reference and *spread
#   - ?boolean and @property (from Lit)
# - Added script blocks for injection of raw JS, C++, Rust, Zig, etc.
#   If no language is specified, C++ is assumed, because of Ruko's compiler target.
# - Fixed keys in literal objects. They will now highlight until a colon, comma
#   or closing brace.
# - Fixed modifier keywords beside lambda functions. Modifiers can now be placed
#   before lambda functions in addition to normal function declarations.
# - Fixed default values in function arguments, thus no longer requiring trailing
#   commas. 'from' and 'where' statements, the string `\| and the operator | have to
#   be bracketed.
# - Slightly changed attribute selectors to allow for regexp matches.

repository:
  core:
    patterns:
      - include: '#punctuation'
      - include: '#directives'
      - include: '#ignore-long-lines'
      - include: '#clauses'
      - include: '#declarations'
      - include: '#keywords'
      - include: '#comments'
      - include: '#argument-list'
      - include: '#function-clause'
      - include: '#function-calls'
      - include: '#symbols'
      - include: '#decorators'
      - include: '#type-signature'
      - include: '#splice-brackets'
      - include: '#xml'
      - include: '#generics'
      - include: '#literals'
      - include: '#accessor-operators'
      - include: '#brackets'
      - include: '#operators'
      - include: '#variables'
      - include: '#illegal'
      - include: '#space'

  # Ignore / illegal patterns

  ignore-long-lines:
    comment: avoid parsing files with long lines of code
    match: ^\N{4097,}$

  space:
    match: \s+
    name: meta.var.expr.ruko

  illegal:
    patterns:
      - match: \p{N}+
        name: invalid.illegal.number.ruko
      - match: \w+
        name: invalid.illegal.variable.ruko
      - match: '[({\[)}\]]+'
        name: invalid.illegal.missing-bracket.ruko
      - match: '[\p{P}\p{S}&&[^,;''"`({\[)}\]\p{Pc}]]+'
        name: invalid.illegal.operator.ruko
      - match: \S+
        name: invalid.illegal.uncaught.ruko

  # Directives

  directives:
    comment: 'These are just straight-up copied from C/C++ but
      with some changes to #define to support regex replacements.'
    patterns:
      - applyEndPatternLast: true
        begin: ^\s*(\#)(!|if|else|elif|end|ifdef|ifndef)\b
        end: $
        name: meta.directive.ruko
        captures:
          1: { name: punctuation.definition.directive.ruko }
          2: { name: keyword.control.directive.ruko }
        patterns: [include: $self]
      - applyEndPatternLast: true
        begin: ^\s*(\#)(define|undef)\b
        end: $
        name: meta.directive.ruko
        captures:
          1: { name: punctuation.definition.directive.ruko }
          2: { name: keyword.control.directive.ruko }
        patterns:
          - include: '#regexp-patterns'
          - begin: (:)\s*
            end: \s*([,;])|$
            name: string.regexp.replace.ruko
            captures:
              1: { name: punctuation.definition.regexp.ruko }
            patterns:
              - include: '#back-references'
              - include: '#escapes-embedded'
              - begin: \s*({)
                end: (\})\s*
                name: meta.interpolation.regexp.ruko
                captures:
                  1: { name: punctuation.definition.variable.ruko }
                patterns:
                  - include: '#back-references'
                  - include: '#escapes-embedded'
                  - include: $self
          - match: .+
            name: meta.directive.definition.ruko
      - applyEndPatternLast: true
        begin: ^\s*(\#)(include|exclude|import|export|extern|intern)\b
        end: $
        name: meta.directive.ruko
        captures:
          1: { name: punctuation.definition.directive.ruko }
          2: { name: keyword.control.directive.ruko }
        patterns: [include: '#module-content']
      - applyEndPatternLast: true
        begin: ^\s*(\#)(pragma|region|endregion|once)\b
        end: $
        name: meta.directive.ruko
        captures:
          1: { name: punctuation.definition.directive.ruko }
          2: { name: keyword.control.directive.ruko }
        patterns: [include: $self]
      - comment: null directive
        match: ^\s*(\#)\s*$
        name: meta.directive.ruko
        captures:
          1: { name: punctuation.definition.directive.ruko }
          2: { name: text.whitespace.ruko }
        patterns: [include: $self]

  # Types

  types:
    patterns:
      - include: '#comments'
      - include: '#type-brackets'
      - include: '#embedded-expressions'
      - include: '#embedded-formatting'
      - include: '#embedded-arguments'
      - include: '#angle-brackets'
      - include: '#type-modifiers'
      - include: '#type-keywords'
      - include: '#type-names'
      - include: '#literals'
      - include: '#type-variables'
      - include: '#type-operators'
      - include: '#space'

  type-variables:
    match: |-
      (?x) \s*\b

      (?!
        (?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b
        (?: # keywords
          # wordlike operators
          [io]n|off?|[ai]s|has|new|old|del|(?:de)?ref|to
          |(?:un)?[gs]et|n?and|x?n?or|c?n?imply|not|by

          # declaration keywords
          |va[rl]|dyn|mut|let|const
          |func|pro[pc]|type|class|actor|trait|enum|in?ter
          |module|schema|struct|record|object|union|macro
          |query|quote|style|script|entity|temp|oper|realm

          # control flow keywords
          |if|else|[tw]hen|guard|with|unless
          |for|while|loop|goto|break|skip|redo|until
          |try|switch|[cm]atch|case|def|throw|raise|error
          |return|yield|await|move|goto|pass|defer
          |[gd]o|from|where|(?:im|ex)(?:port|tern)

          # miscellaneous keywords
          |debug|assert|check|decl
          |use|echo|eval|expr|scope
          |begin|end|prev|next
        )
        \b
      )

      (?:
        (?<=
          (?: ['"`)\]}\w] | \\.) \s* # literal, bracket or space
          (?:[?!]?\.|[?!:]:|[?!-]>)=? # accessor or qualified name separator
        )
        \b # methods
        (?: # Properties
            (\p{Pc}+\w*(?!\p{Pc}+)\b) # Leading underscore
          | ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*) # Screaming snake case
          | ((?:[\p{Pc}\p{L}&&\P{Ll}][\w&&\P{Lu}]*)+) # Pascal case
          | ([\p{Pc}\p{L}]\w*) # Camel or snake case
        )
        |
        (?<!
          (?: [,;'"`)}\]\w] | \\. ) # literal, bracket or space
          (?: [\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]+ ) # operators
        )
        \b
        (?: # Objects
            (\p{Pc}+\w*(?!\p{Pc}+)\b) # Leading underscore
          | ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*) # Screaming snake case
          | ((?:[\p{Pc}\p{L}&&\P{Ll}][\w&&\P{Lu}]*)+) # Pascal case
          | ([\p{Pc}\p{L}]\w*) # Camel or snake case
        )
        (?! [?!]?\.\.+ ) # not a range operator
        (?=
            (?:[?!]?\.|[?!:]:|[?!-]>)=? # accessor or qualified name separator
          | \#?\[ # or array access
        )
        |
        (?: # Regular variables
            (\p{Pc}+\w*(?!\p{Pc}+)\b) # Leading underscore
          | ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*) # Screaming snake case
          | ((?:[\p{Pc}\p{L}&&\P{Ll}][\w&&\P{Lu}]*)+) # Pascal case
          | ([\p{Pc}\p{L}]\w*) # Camel or snake case
        )
      )\b

      \s*
    captures:
      1: { name: support.type.instance.ruko }
      2: { name: entity.name.interface.ruko }
      3: { name: support.type.interface.ruko }
      4: { name: entity.name.instance.ruko }
      5: { name: support.type.module.ruko }
      6: { name: entity.name.namespace.ruko }
      7: { name: support.type.namespace.ruko }
      8: { name: entity.name.module.ruko }
      9: { name: support.type.type.ruko }
      10: { name: entity.name.class.ruko }
      11: { name: support.type.class.ruko }
      12: { name: entity.name.type.ruko }

  type-signature:
    applyEndPatternLast: true
    name: meta.type.ruko
    begin: (?<=(?:[)}\]\w'"`]|\\.)>*\|?|^\|?)(:)(?=$|<*(?:['"`\w\s]|\#?[(\[{]))
    end: (?=)|$
    beginCaptures:
      1: { name: punctuation.definition.annotation.ruko }
    patterns: [include: '#types']

  type-brackets:
    patterns:
      - include: '#type-curly-brackets'
      - include: '#type-square-brackets'
      - include: '#type-round-brackets'

  type-curly-brackets:
    repository:
      punctuation:
        patterns:
          - match: ','
            name: punctuation.separator.mapping.ruko
          - match: (?<=(?:['"`)}\]\w]|\\.)[\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]*):(?=(?:['"`\w\s]|\#?[(\[{])|$)
            name: punctuation.separator.key-value.ruko

    patterns:
      - begin: |-
          (?x)
          (?<=
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \b
              (?: # destructuring keywords
                va[rl]|dyn|mut|let|const
                |case
              )
            \b
            (?:$|[,;'"({\[)}\]\s]) # beside a delimiter or space
            >* # after generics
            \s*
          )
          (\#?\{)\s*
        end: \s*(})
        name: meta.brace.curly.ruko
        captures:
          1:
            name: punctuation.definition.binding-pattern.object.ruko
        patterns:
          - include: '#object-labels'
          - include: '#punctuation'
          - include: '#as-keyword'
          - include: '#types'
          - include: $self
      - begin: |-
          (?x)
          (?<=
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \b
              (?: # wordlike operators
                [io]n|off?|[ai]s|has|new|old|del|(?:de)?ref|to
                |(?:un)?[gs]et|n?and|x?n?or|c?n?imply|not|by
              )
            \b
            (?:$|[,;'"({\[)}\]\s]) # beside a delimiter or space
            >* # after generics
            \s*
          )
          (\#{)\s*
        end: \s*(})
        name: meta.brace.curly.ruko
        captures:
          1: { name: punctuation.definition.mapping.ruko }
        patterns:
          - include: '#object-labels'
          - include: '#punctuation'
          - include: '#types'
          - include: $self
      - begin: |-
          (?x)
          (?<=
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \b
              (?: # wordlike operators
                [io]n|off?|[ai]s|has|new|old|del|(?:de)?ref|to
                |(?:un)?[gs]et|n?and|x?n?or|c?n?imply|not|by
              )
            \b
            (?:$|[,;'"({\[)}\]\s]) # beside a delimiter or space
            >* # after generics
            \s*
          )
          ({)\s*
        end: \s*(})
        name: meta.brace.curly.ruko
        captures:
          1: { name: punctuation.definition.dictionary.ruko }
        patterns:
          - include: '#object-labels'
          - include: '#punctuation'
          - include: '#types'
          - include: $self
      - begin: |-
          (?x)
          (?<=
            (?:
                ^
              | [,;({\[]
              | (?:^|[,;({\[)}\]\w'"`]|\\.):\s*
              | [\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]+
            )
            \s*
          )
          (?<! (?: [\w'"`)}\]] | \\.) >* \s* ) # not after generics
          (\#{)\s*
        end: \s*(})
        name: meta.brace.curly.ruko
        captures:
          1: { name: punctuation.definition.mapping.ruko }
        patterns:
          - include: '#object-labels'
          - include: '#punctuation'
          - include: '#types'
          - include: $self
      - begin: |-
          (?x)
          (?<=
            (?:
                ^
              | [,;({\[]
              | (?:^|[,;({\[)}\]\w'"`]|\\.):\s*
              | [\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]+
            )
            \s*
          )
          (?<! (?: [\w'"`)}\]] | \\.) >* \s* ) # not after generics
          ({)\s*
        end: \s*(})
        name: meta.brace.curly.ruko
        captures:
          1: { name: punctuation.definition.dictionary.ruko }
        patterns:
          - include: '#object-labels'
          - include: '#punctuation'
          - include: '#types'
          - include: $self

  type-round-brackets:
    repository:
      punctuation:
        patterns:
          - match: ','
            name: punctuation.separator.arguments.ruko
          - match: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(as)\b\s*
            name: keyword.operator.expression.as.ruko
          - match: (?<=[\w\s][(|])\.
            name: punctuation.definition.metadata.ruko

    patterns:
      - begin: |-
          (?x)
          (?<= # literal
              (?: [\w'"`)}\]] | \\.) >* \s*
            | [^\s.]\.=?|[?!:]:=?
          )
          (\#?\()\s*
        end: \s*(\))
        name: meta.brace.round.ruko
        captures:
          1: { name: punctuation.definition.parameters.ruko }
        patterns:
          - include: '#types'
          - include: $self
      - begin: |-
          (?x)
          (?<=
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \b
              (?: # destructuring keywords
                va[rl]|dyn|mut|let|const
                |case
              )
            \b
            (?:$|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \s*
          )
          (\#?\()\s*
        end: \s*(\))
        name: meta.brace.round.ruko
        captures:
          1: { name: punctuation.definition.binding-pattern.tuple.ruko }
        patterns:
          - include: '#punctuation'
          - include: '#types'
          - include: $self
      - begin: (\#\()\s*
        end: \s*(\))
        name: meta.brace.round.ruko
        captures:
          1: { name: punctuation.definition.tuple.ruko }
        patterns:
          - include: '#types'
          - include: $self
      - begin: (\()\s*
        end: \s*(\))
        name: meta.brace.round.ruko
        captures:
          1: { name: punctuation.definition.expression.ruko }
        patterns:
          - include: '#types'
          - include: $self

  type-square-brackets:
    repository:
      punctuation:
        patterns:
          - match: ','
            name: punctuation.separator.sequence.ruko

    patterns:
      - begin: |-
          (?x)
          (?<= # literal
              (?: [\w'"`)}\]] | \\.) \s*
            | [^\s.]\.=?|[?!:]:=?
          )
          (\#?\[)\s*
        end: \s*(\])
        name: meta.brace.square.ruko
        captures:
          1: { name: punctuation.definition.attribute-selector.ruko }
        patterns:
          - include: '#types'
          - include: $self
      - begin: |-
          (?x)
          (?<=
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \b
              (?: # destructuring keywords
                va[rl]|dyn|mut|let|const
                |case
              )
            \b
            (?:$|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \s*
          )
          (\#?\[)\s*
        end: \s*(\])
        name: meta.brace.square.ruko
        captures:
          1: { name: punctuation.definition.binding-pattern.array.ruko }
        patterns:
          - include: '#punctuation'
          - include: '#types'
          - include: $self
      - begin: (\#\[)\s*
        end: \s*(\])
        name: meta.brace.square.ruko
        captures:
          1: { name: punctuation.definition.sequence.ruko }
        patterns:
          - include: '#punctuation'
          - include: '#types'
          - include: $self
      - begin: (\[)\s*
        end: \s*(\])
        name: meta.brace.square.ruko
        captures:
          1: { name: punctuation.definition.array.ruko }
        patterns:
          - include: '#punctuation'
          - include: '#types'
          - include: $self

  type-keywords:
    patterns:
      - match: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(from)\b\s*
        name: storage.type.extends.ruko
      - match: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(for)\b\s*
        name: storage.type.implements.ruko
      - match: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(infer|as)\b\s*
        name: keyword.operator.expression.$1.ruko
      - match: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(is\s+not|is|has\s+not|has|has\s+not|has)\b\s*
        name: keyword.operator.expression.is.ruko
      - match: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b((inst|value|pair|type|name|size|key)of)\b\s*
        name: keyword.operator.expression.$1.ruko
      - match: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(instof)\b\s*
        name: keyword.operator.expression.instanceof.ruko
      - match: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(ext)\b\s*
        name: storage.type.extends.ruko
      - match: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(impl)\b\s*
        name: storage.type.implements.ruko

  type-operators:
    patterns:
      - &qualified-name-separators
        comment: Qualified name separators
        match: (?<=[)}\]\w])(?:(\?[.:>]=?)|(![.:>]=?)|((?:::|\.|->)=?))(?=[({\[\w])
        captures:
          1: { name: keyword.operator.optional.ruko }
          2: { name: keyword.operator.unwrap.ruko }
          3: { name: keyword.operator.accessor.ruko }
      - match: \s*(--?>|~~?>|==?>)
        name: keyword.operator.type.function.ruko
      - match: \s*(<--?|<~~?|<==?)
        name: keyword.operator.type.channel.ruko
      - comment: Prefix type operators
        match: |-
          (?x)
          \s*
          (?:
             (\*) # pointer
            |(\&) # reference
            |(\%) # format
            |(\@) # decorator
            |(\^) # borrow
            |(\!) # negation
            |(\~) # destructor
            |(\?) # optional
            |(\\) # lifetime
            |(\-) # negation
            |(\+) # arithmetic
            |(\.{3}) # spread
          )
          (?=[\w'"`]|\#?[(\[{<])
        captures: &prefix-type-operator-captures
          1: { name: keyword.operator.pointer.ruko }
          2: { name: keyword.operator.reference.ruko }
          3: { name: keyword.operator.format.ruko }
          4: { name: keyword.operator.decorator.ruko }
          5: { name: keyword.operator.borrow.ruko }
          6: { name: keyword.operator.logical.ruko }
          7: { name: keyword.operator.destructor.ruko }
          8: { name: keyword.operator.optional.ruko }
          9: { name: keyword.operator.lifetime.ruko }
          10: { name: keyword.operator.negation.ruko }
          11: { name: keyword.operator.arithmetic.ruko }
          12: { name: keyword.operator.spread.ruko }
      - comment: Infix type operators
        match: |-
          (?x)
          (?<=^|['"`)}\]\w\s]|\\.)
            (?:
               (\+)       # sum
              |(\-)       # difference
              |(\|)       # union
              |(\&)       # intersection
              |(\^)       # exclusion
              |([<>][:=]) # strict super-/subtype
              |(=[:!])    # equality/inequality
              |(:[<>])    # variance (i.e. covariant/contravariant)
              |(=~|!~)    # pattern match/non-pattern match
              |(::?)      # extends/implements
              |(\?)|(!)   # conditionals
              |(\+>|<\+)  # composition
            )
          (?=['"`\w\s]|\#?[(\[{])
        captures:
          1: { name: keyword.operator.sum.ruko }
          2: { name: keyword.operator.difference.ruko }
          3: { name: keyword.operator.union.ruko }
          4: { name: keyword.operator.intersection.ruko }
          5: { name: keyword.operator.exclusion.ruko }
          6: { name: keyword.operator.relational.ruko }
          7: { name: keyword.operator.equality.ruko }
          8: { name: keyword.operator.prototype.ruko }
          9: { name: keyword.operator.pattern.ruko }
          10: { name: keyword.operator.extends.ruko }
          11: { name: keyword.operator.conditional.ruko }
          12: { name: keyword.operator.ternary.ruko }
          13: { name: keyword.operator.composition.ruko }
      - comment: Suffix type operators
        match: |-
          (?x)
          (?<=[\w'"`)\]}>]|\\.)
          (?:
             (\!) # result type
            |(\?) # option type
          )
          \B
        captures: &suffix-type-operator-captures
          1: { name: keyword.operator.unwrap.ruko }
          2: { name: keyword.operator.existential.ruko }

  parameter-type-operators:
    patterns:
      - comment: Prefix type operators
        match: |-
          (?x)
          (?:
             (\*) # pointer
            |(\&) # reference
            |(\%) # format
            |(\@) # decorator
            |(\^) # borrow
            |(\!) # negation
            |(\~) # destructor
            |(\?) # optional
            |(\\) # lifetime
            |(\-) # negation
            |(\+) # arithmetic
            |(\.{3}) # spread
          )
        captures: *prefix-type-operator-captures
      - comment: Suffix type operators
        match: |-
          (?x)
          (?:
             (\!) # result type
            |(\?) # option type
          )
        captures: *suffix-type-operator-captures

  # Literals and Constants

  literals:
    patterns:
      - include: '#regexps'
      - include: '#strings'
      - include: '#numbers'
      - include: '#constants'
      - include: '#strings-unquoted'
      - include: '#symbols'

  constants:
    patterns:
      - match: |-
          (?x)
          (?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b
          (?:
            (true|false) # boolean
            |(null|nan) # null and not-a-number
            |(undef) # undefined
            |(infty) # infinity
            |(it|this|super|self) # special arguments
            |(args) # arguments
            |(ctor) # constructor
            |(dtor) # destructor
            |(proto) # prototype
            |(_[+-]?\d+) # index variable
            |(\p{Pc}+) # underscore variable
          )
          \b
        captures:
          1: { name: constant.language.boolean.$1.ruko }
          2: { name: constant.language.$2.ruko }
          3: { name: constant.language.undefined.ruko }
          4: { name: constant.language.infinity.ruko }
          5: { name: variable.language.$5.ruko }
          6: { name: variable.language.arguments.ruko }
          7: { name: variable.language.constructor.ruko }
          8: { name: variable.language.destructor.ruko }
          9: { name: variable.language.prototype.ruko }
          10: { name: variable.language.underscore.ruko }
          110: { name: variable.language.index.ruko }
      - match: |-
          (?x)
          (?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b
          (
            console|document|window|global|process|require|module|exports
            |navigator|location|history|localStorage|sessionStorage
          )
          \b
        captures:
          1: { name: support.type.object.$1.ruko }

  # Numbers

  unit-suffix:
    match: (?<=['"`)}\]\w])([\p{Pc}\p{L}]\w*)\b
    name: keyword.other.unit.ruko

  byte-shift-suffix:
    match: |-
      (?ix)(\\?p) # power-of-two
      ([+-])? # sign
      ([\d_]+) # exponent
    captures:
      1: { name: keyword.operator.expression.exponent.ruko }
      2: { name: keyword.operator.exponent.sign.ruko }
      3: { name: constant.numeric.decimal.exponent.ruko }

  numbers:
    applyEndPatternLast: true
    begin: (?=\d)
    end: \b\s*
    name: meta.number.ruko
    patterns:
      - applyEndPatternLast: true
        comment: binary (0b prefix)
        name: constant.numeric.binary.ruko
        begin: |-
          (?ix)\b(0b) # prefix
            ([01](?:[01_]*[01])?) # binary digits
        end: (?=)|$
        captures:
          1: { name: storage.type.numeric.ruko }
          2: { name: constant.numeric.binary.digits.ruko }
        patterns:
          - match: (\.)([01](?:[01_]*[01])?)
            name: constant.numeric.binary.fraction.ruko
            captures:
              1: { name: punctuation.separator.decimal.ruko }
          - match: |-
              (?ix)(\\?e) # exponent delimiter
              ([+-])? # sign
              ([01](?:[01_]*[01])?) # exponent
            captures:
              1: { name: keyword.operator.expression.exponent.ruko }
              2: { name: keyword.operator.exponent.sign.ruko }
              3: { name: constant.numeric.binary.exponent.ruko }
          - match: |-
              (?ix)(/) # rational delimiter
              ([01](?:[01_]*[01])?) # denominator
            captures:
              1: { name: punctuation.separator.rational.ruko }
              2: { name: constant.numeric.binary.denominator.ruko }
          - include: '#byte-shift-suffix'
          - include: '#unit-suffix'
      - applyEndPatternLast: true
        comment: quaternary (0q prefix)
        name: constant.numeric.quaternary.ruko
        begin: |-
          (?ix)\b(0q) # prefix
            ([0-3](?:[0-3_]*[0-3])?) # quaternary digits
        end: (?=)|$
        captures:
          1: { name: storage.type.numeric.ruko }
          2: { name: constant.numeric.quaternary.digits.ruko }
        patterns:
          - match: (\.)([0-4](?:[0-4_]*[0-4])?)
            name: constant.numeric.quaternary.fraction.ruko
            captures:
              1: { name: punctuation.separator.decimal.ruko }
          - match: |-
              (?ix)(\\?e) # exponent delimiter
              ([+-])? # sign
              ([0-3](?:[0-3_]*[0-3])?) # exponent
            captures:
              1: { name: keyword.operator.expression.exponent.ruko }
              2: { name: keyword.operator.exponent.sign.ruko }
              3: { name: constant.numeric.quaternary.exponent.ruko }
          - match: |-
              (?ix)(/) # rational delimiter
              ([0-3](?:[0-3_]*[0-3])?) # denominator
            captures:
              1: { name: punctuation.separator.rational.ruko }
              2: { name: constant.numeric.quaternary.denominator.ruko }
          - include: '#byte-shift-suffix'
          - include: '#unit-suffix'
      - applyEndPatternLast: true
        comment: octal (0o prefix)
        name: constant.numeric.octal.ruko
        begin: |-
          (?ix)\b(0o) # prefix
            ([0-7](?:[0-7_]*[0-7])?) # octal digits
        end: (?=)|$
        captures:
          1: { name: storage.type.numeric.ruko }
          2: { name: constant.numeric.octal.digits.ruko }
        patterns:
          - match: (\.)([0-7](?:[0-7_]*[0-7])?)
            name: constant.numeric.octal.fraction.ruko
            captures:
              1: { name: punctuation.separator.decimal.ruko }
          - match: |-
              (?ix)(\\?e) # exponent delimiter
              ([+-])? # sign
              ([0-7](?:[0-7_]*[0-7])?) # exponent
            captures:
              1: { name: keyword.operator.expression.exponent.ruko }
              2: { name: keyword.operator.exponent.sign.ruko }
              3: { name: constant.numeric.octal.exponent.ruko }
          - match: |-
              (?ix)(/) # rational delimiter
              ([0-7](?:[0-7_]*[0-7])?) # denominator
            captures:
              1: { name: punctuation.separator.rational.ruko }
              2: { name: constant.numeric.octal.denominator.ruko }
          - include: '#byte-shift-suffix'
          - include: '#unit-suffix'
      - applyEndPatternLast: true
        comment: hexadecimal (0x prefix)
        name: constant.numeric.hexadecimal.ruko
        begin: |-
          (?ix)\b(0x) # prefix
            (\h(?:[\h_]*[\h])?) # hexadecimal digits
        end: (?=)|$
        captures:
          1: { name: storage.type.numeric.ruko }
          2: { name: constant.numeric.hexadecimal.digits.ruko }
        patterns:
          - match: (\.)([\h](?:[\h_]*[\h])?)
            name: constant.numeric.hexadecimal.fraction.ruko
            captures:
              1: { name: punctuation.separator.decimal.ruko }
          - match: |-
              (?ix)(\\?e) # exponent delimiter
              ([+-])? # sign
              ([\h](?:[\h_]*[\h])?) # exponent
            captures:
              1: { name: keyword.operator.expression.exponent.ruko }
              2: { name: keyword.operator.exponent.sign.ruko }
              3: { name: constant.numeric.hexadecimal.exponent.ruko }
          - match: |-
              (?ix)(/) # rational delimiter
              ([\h](?:[\h_]*[\h])?) # denominator
            captures:
              1: { name: punctuation.separator.rational.ruko }
              2: { name: constant.numeric.hexadecimal.denominator.ruko }
          - include: '#byte-shift-suffix'
          - include: '#unit-suffix'
      - applyEndPatternLast: true
        comment: duodecimal (0z prefix)
        name: constant.numeric.duodecimal.ruko
        begin: |-
          (?ix)\b(0z) # prefix
            ([\d↊↋abetx](?:[\d↊↋abetx_]*[\d↊↋abetx])?) # duodecimal digits
        end: (?=)|$
        captures:
          1: { name: storage.type.numeric.ruko }
          2: { name: constant.numeric.duodecimal.digits.ruko }
        patterns:
          - match: (\.)([\d↊↋abetx](?:[\d↊↋abetx_]*[\d↊↋abetx])?)
            name: constant.numeric.duodecimal.fraction.ruko
            captures:
              1: { name: punctuation.separator.decimal.ruko }
          - match: |-
              (?ix)(\\?e) # exponent delimiter
              ([+-])? # sign
              ([\d↊↋abetx](?:[\d↊↋abetx_]*[\d↊↋abetx])?) # exponent
            captures:
              1: { name: keyword.operator.expression.exponent.ruko }
              2: { name: keyword.operator.exponent.sign.ruko }
              3: { name: constant.numeric.duodecimal.exponent.ruko }
          - match: |-
              (?ix)(/) # rational delimiter
              ([\d↊↋abetx](?:[\d↊↋abetx_]*[\d↊↋abetx])?) # denominator
            captures:
              1: { name: punctuation.separator.rational.ruko }
              2: { name: constant.numeric.duodecimal.denominator.ruko }
          - include: '#byte-shift-suffix'
          - include: '#unit-suffix'
      - applyEndPatternLast: true
        comment: decimal (no prefix)
        name: constant.numeric.decimal.ruko
        begin: |-
          (?ix)\b(?:) # no prefix
            (\d(?:[\d_]*\d)?) # integer part
        end: (?=)|$
        captures:
          1: { name: constant.numeric.decimal.integer.ruko }
        patterns:
          - match: (\.)([\d](?:[\d_]*[\d])?)
            name: constant.numeric.decimal.fraction.ruko
            captures:
              1: { name: punctuation.separator.decimal.ruko }
          - match: |-
              (?ix)(\\?e) # exponent delimiter
              ([+-])? # sign
              ([\d](?:[\d_]*[\d])?) # exponent
            captures:
              1: { name: keyword.operator.expression.exponent.ruko }
              2: { name: keyword.operator.exponent.sign.ruko }
              3: { name: constant.numeric.decimal.exponent.ruko }
          - match: |-
              (?ix)(/) # rational delimiter
              ([\d](?:[\d_]*[\d])?) # denominator
            captures:
              1: { name: punctuation.separator.rational.ruko }
              2: { name: constant.numeric.decimal.denominator.ruko }
          - include: '#byte-shift-suffix'
          - include: '#unit-suffix'

  # Symbols

  decorators:
    applyEndPatternLast: true
    begin: (?<=^|\\.|['"`({\[)}\]\s]|(?:[)}\]\w\s'"`]|\\.)\s*[:=])(\@)(?=[\p{Pc}\p{L}])
    end: (?=)|$
    name: entity.name.decorator.ruko
    captures:
      1: { name: punctuation.definition.decorator.ruko }
      2: { name: entity.name.decorator.ruko }
    patterns:
      - include: '#function-calls'
      - include: '#sigil-function-calls'
      - match: '[?!:]:|[?!]?\.|[?!-]>'
        name: punctuation.separator.namespace.ruko
      - include: '#brackets'
      - include: '#strings'
      - include: '#variables'

  symbols:
    patterns:
      - comment: quoted symbol
        applyEndPatternLast: true
        begin: (?<=^|\\.|['"`({\[)}\]\s]|(?:[)}\]\w\s'"`]|\\.)\s*[:=])(:)(?=[`'"])
        end: (?=)|$
        name: constant.language.symbol-type.ruko
        captures:
          1: { name: punctuation.definition.symbol.ruko }
        patterns: [include: '#strings']
      - match: (?<=^|\\.|['"`({\[)}\]\s]|(?:[)}\]\w\s'"`]|\\.)\s*[:=])(:)(\b[\p{Pc}\p{L}]\w*\b)
        name: constant.other.symbol.ruko
        captures:
          1: { name: punctuation.definition.symbol.ruko }
          2: { name: constant.other.symbol.ruko }
        patterns: [include: '#string-escapes']

  # Strings

  strings-unquoted:
    comment: Unquoted string
    applyEndPatternLast: true
    begin: (`)
    end: (?=\W)|$
    name: string.template.ruko
    captures:
      1: { name: punctuation.definition.string.ruko }
    patterns:
      - match: \b\p{Pd}+\b
        name: constant.character.escape.ruko
      - include: '#embedded'
      - include: '#string-escapes'

  strings:
    patterns:
      - comment: multi single-quoted verbatim, interpolated, format, and template string
        begin: \s*(\\+\$+%+\#+|\\+\$+\#+%+|\\+%+\$+\#+|\\+%+\#+\$+|\\+\#+\$+%+|\\+\#+%+\$+|\$+\\+%+\#+|\$+\\+\#+%+|\$+%+\\+\#+|\$+%+\#+\\+|\$+\#+\\+%+|\$+\#+%+\\+|%+\\+\$+\#+|%+\\+\#+\$+|%+\$+\\+\#+|%+\$+\#+\\+|%+\#+\\+\$+|%+\#+\$+\\+|\#+\\+\$+%+|\#+\\+%+\$+|\#+\$+\\+%+|\#+\$+%+\\+|\#+%+\\+\$+|\#+%+\$+\\+)('''+)\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: { name: storage.type.string.ruko }
          2: { name: punctuation.definition.string.ruko }
        patterns:
          - match: '''''|\$\$|%%|\#\#'
            name: constant.character.escape.ruko
          - include: '#embedded-expressions'
          - include: '#embedded-formatting'
          - include: '#embedded-arguments'
      - comment: multi double-quoted verbatim, interpolated, format, and template string
        begin: \s*(\\+\$+%+\#+|\\+\$+\#+%+|\\+%+\$+\#+|\\+%+\#+\$+|\\+\#+\$+%+|\\+\#+%+\$+|\$+\\+%+\#+|\$+\\+\#+%+|\$+%+\\+\#+|\$+%+\#+\\+|\$+\#+\\+%+|\$+\#+%+\\+|%+\\+\$+\#+|%+\\+\#+\$+|%+\$+\\+\#+|%+\$+\#+\\+|%+\#+\\+\$+|%+\#+\$+\\+|\#+\\+\$+%+|\#+\\+%+\$+|\#+\$+\\+%+|\#+\$+%+\\+|\#+%+\\+\$+|\#+%+\$+\\+)("""+)\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: { name: storage.type.string.ruko }
          2: { name: punctuation.definition.string.ruko }
        patterns:
          - match: '""|\$\$|%%|\#\#'
            name: constant.character.escape.ruko
          - include: '#embedded-expressions'
          - include: '#embedded-formatting'
          - include: '#embedded-arguments'
      - comment: single-quoted verbatim, interpolated, format, and template string
        begin: \s*(\\+\$+%+\#+|\\+\$+\#+%+|\\+%+\$+\#+|\\+%+\#+\$+|\\+\#+\$+%+|\\+\#+%+\$+|\$+\\+%+\#+|\$+\\+\#+%+|\$+%+\\+\#+|\$+%+\#+\\+|\$+\#+\\+%+|\$+\#+%+\\+|%+\\+\$+\#+|%+\\+\#+\$+|%+\$+\\+\#+|%+\$+\#+\\+|%+\#+\\+\$+|%+\#+\$+\\+|\#+\\+\$+%+|\#+\\+%+\$+|\#+\$+\\+%+|\#+\$+%+\\+|\#+%+\\+\$+|\#+%+\$+\\+)(')\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: { name: storage.type.string.ruko }
          2: { name: punctuation.definition.string.ruko }
        patterns:
          - match: '''''|\$\$|%%|\#\#'
            name: constant.character.escape.ruko
          - include: '#embedded-expressions'
          - include: '#embedded-formatting'
          - include: '#embedded-arguments'
      - comment: double-quoted verbatim, interpolated, format, and template string
        begin: \s*(\\+\$+%+\#+|\\+\$+\#+%+|\\+%+\$+\#+|\\+%+\#+\$+|\\+\#+\$+%+|\\+\#+%+\$+|\$+\\+%+\#+|\$+\\+\#+%+|\$+%+\\+\#+|\$+%+\#+\\+|\$+\#+\\+%+|\$+\#+%+\\+|%+\\+\$+\#+|%+\\+\#+\$+|%+\$+\\+\#+|%+\$+\#+\\+|%+\#+\\+\$+|%+\#+\$+\\+|\#+\\+\$+%+|\#+\\+%+\$+|\#+\$+\\+%+|\#+\$+%+\\+|\#+%+\\+\$+|\#+%+\$+\\+)(")\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: { name: storage.type.string.ruko }
          2: { name: punctuation.definition.string.ruko }
        patterns:
          - match: '""|\$\$|%%|\#\#'
            name: constant.character.escape.ruko
          - include: '#embedded-expressions'
          - include: '#embedded-formatting'
          - include: '#embedded-arguments'
      - comment: multi single-quoted interpolated, format, and template string
        begin: \s*(\$+%+\#+|\$+\#+%+|%+\$+\#+|%+\#+\$+|\#+\$+%+|\#+%+\$+)('''+)\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: { name: storage.type.string.ruko }
          2: { name: punctuation.definition.string.ruko }
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expressions'
          - include: '#embedded-formatting'
          - include: '#embedded-arguments'
      - comment: multi double-quoted interpolated, format, and template string
        begin: \s*(\$+%+\#+|\$+\#+%+|%+\$+\#+|%+\#+\$+|\#+\$+%+|\#+%+\$+)("""+)\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: { name: storage.type.string.ruko }
          2: { name: punctuation.definition.string.ruko }
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expressions'
          - include: '#embedded-formatting'
          - include: '#embedded-arguments'
      - comment: single-quoted interpolated, format, and template string
        begin: \s*(\$+%+\#+|\$+\#+%+|%+\$+\#+|%+\#+\$+|\#+\$+%+|\#+%+\$+)(')\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: { name: storage.type.string.ruko }
          2: { name: punctuation.definition.string.ruko }
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expressions'
          - include: '#embedded-formatting'
          - include: '#embedded-arguments'
      - comment: double-quoted interpolated, format, and template string
        begin: \s*(\$+%+\#+|\$+\#+%+|%+\$+\#+|%+\#+\$+|\#+\$+%+|\#+%+\$+)(")\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: { name: storage.type.string.ruko }
          2: { name: punctuation.definition.string.ruko }
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expressions'
          - include: '#embedded-formatting'
          - include: '#embedded-arguments'
      - comment: multi single-quoted verbatim, interpolated, and format string
        begin: \s*(\\+\$+%+|\\+%+\$+|\$+\\+%+|\$+%+\\+|%+\\+\$+|%+\$+\\+)('''+)\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: { name: storage.type.string.ruko }
          2: { name: punctuation.definition.string.ruko }
        patterns:
          - match: '''''|\$\$|%%'
            name: constant.character.escape.ruko
          - include: '#embedded-expressions'
          - include: '#embedded-formatting'
      - comment: multi double-quoted verbatim, interpolated, and format string
        begin: \s*(\\+\$+%+|\\+%+\$+|\$+\\+%+|\$+%+\\+|%+\\+\$+|%+\$+\\+)("""+)\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: { name: storage.type.string.ruko }
          2: { name: punctuation.definition.string.ruko }
        patterns:
          - match: '""|\$\$|%%'
            name: constant.character.escape.ruko
          - include: '#embedded-expressions'
          - include: '#embedded-formatting'
      - comment: single-quoted verbatim, interpolated, and format string
        begin: \s*(\\+\$+%+|\\+%+\$+|\$+\\+%+|\$+%+\\+|%+\\+\$+|%+\$+\\+)(')\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: { name: storage.type.string.ruko }
          2: { name: punctuation.definition.string.ruko }
        patterns:
          - match: '''''|\$\$|%%'
            name: constant.character.escape.ruko
          - include: '#embedded-expressions'
          - include: '#embedded-formatting'
      - comment: double-quoted verbatim, interpolated, and format string
        begin: \s*(\\+\$+%+|\\+%+\$+|\$+\\+%+|\$+%+\\+|%+\\+\$+|%+\$+\\+)(")\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: { name: storage.type.string.ruko }
          2: { name: punctuation.definition.string.ruko }
        patterns:
          - match: '""|\$\$|%%'
            name: constant.character.escape.ruko
          - include: '#embedded-expressions'
          - include: '#embedded-formatting'
      - comment: multi single-quoted verbatim, interpolated, and template string
        begin: \s*(\\+\$+\#+|\\+\#+\$+|\$+\\+\#+|\$+\#+\\+|\#+\\+\$+|\#+\$+\\+)('''+)\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: { name: storage.type.string.ruko }
          2: { name: punctuation.definition.string.ruko }
        patterns:
          - match: '''''|\$\$|\#\#'
            name: constant.character.escape.ruko
          - include: '#embedded-expressions'
          - include: '#embedded-arguments'
      - comment: multi double-quoted verbatim, interpolated, and template string
        begin: \s*(\\+\$+\#+|\\+\#+\$+|\$+\\+\#+|\$+\#+\\+|\#+\\+\$+|\#+\$+\\+)("""+)\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: { name: storage.type.string.ruko }
          2: { name: punctuation.definition.string.ruko }
        patterns:
          - match: '""|\$\$|\#\#'
            name: constant.character.escape.ruko
          - include: '#embedded-expressions'
          - include: '#embedded-arguments'
      - comment: single-quoted verbatim, interpolated, and template string
        begin: \s*(\\+\$+\#+|\\+\#+\$+|\$+\\+\#+|\$+\#+\\+|\#+\\+\$+|\#+\$+\\+)(')\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: { name: storage.type.string.ruko }
          2: { name: punctuation.definition.string.ruko }
        patterns:
          - match: '''''|\$\$|\#\#'
            name: constant.character.escape.ruko
          - include: '#embedded-expressions'
          - include: '#embedded-arguments'
      - comment: double-quoted verbatim, interpolated, and template string
        begin: \s*(\\+\$+\#+|\\+\#+\$+|\$+\\+\#+|\$+\#+\\+|\#+\\+\$+|\#+\$+\\+)(")\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: { name: storage.type.string.ruko }
          2: { name: punctuation.definition.string.ruko }
        patterns:
          - match: '""|\$\$|\#\#'
            name: constant.character.escape.ruko
          - include: '#embedded-expressions'
          - include: '#embedded-arguments'
      - comment: multi single-quoted verbatim, format, and template string
        begin: \s*(\\+%+\#+|\\+\#+%+|%+\\+\#+|%+\#+\\+|\#+\\+%+|\#+%+\\+)('''+)\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: { name: storage.type.string.ruko }
          2: { name: punctuation.definition.string.ruko }
        patterns:
          - match: '''''|%%|\#\#'
            name: constant.character.escape.ruko
          - include: '#embedded-formatting'
          - include: '#embedded-arguments'
      - comment: multi double-quoted verbatim, format, and template string
        begin: \s*(\\+%+\#+|\\+\#+%+|%+\\+\#+|%+\#+\\+|\#+\\+%+|\#+%+\\+)("""+)\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: { name: storage.type.string.ruko }
          2: { name: punctuation.definition.string.ruko }
        patterns:
          - match: '""|%%|\#\#'
            name: constant.character.escape.ruko
          - include: '#embedded-formatting'
          - include: '#embedded-arguments'
      - comment: single-quoted verbatim, format, and template string
        begin: \s*(\\+%+\#+|\\+\#+%+|%+\\+\#+|%+\#+\\+|\#+\\+%+|\#+%+\\+)(')\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: { name: storage.type.string.ruko }
          2: { name: punctuation.definition.string.ruko }
        patterns:
          - match: '''''|%%|\#\#'
            name: constant.character.escape.ruko
          - include: '#embedded-formatting'
          - include: '#embedded-arguments'
      - comment: double-quoted verbatim, format, and template string
        begin: \s*(\\+%+\#+|\\+\#+%+|%+\\+\#+|%+\#+\\+|\#+\\+%+|\#+%+\\+)(")\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: { name: storage.type.string.ruko }
          2: { name: punctuation.definition.string.ruko }
        patterns:
          - match: '""|%%|\#\#'
            name: constant.character.escape.ruko
          - include: '#embedded-formatting'
          - include: '#embedded-arguments'
      - comment: multi single-quoted interpolated and format string
        begin: \s*(\$+%+|%+\$+)('''+)\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: { name: storage.type.string.ruko }
          2: { name: punctuation.definition.string.ruko }
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expressions'
          - include: '#embedded-formatting'
      - comment: multi double-quoted interpolated and format string
        begin: \s*(\$+%+|%+\$+)("""+)\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: { name: storage.type.string.ruko }
          2: { name: punctuation.definition.string.ruko }
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expressions'
          - include: '#embedded-formatting'
      - comment: single-quoted interpolated and format string
        begin: \s*(\$+%+|%+\$+)(')\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: { name: storage.type.string.ruko }
          2: { name: punctuation.definition.string.ruko }
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expressions'
          - include: '#embedded-formatting'
      - comment: double-quoted interpolated and format string
        begin: \s*(\$+%+|%+\$+)(")\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: { name: storage.type.string.ruko }
          2: { name: punctuation.definition.string.ruko }
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expressions'
          - include: '#embedded-formatting'
      - comment: multi single-quoted interpolated and template string
        begin: \s*(\$+\#+|\#+\$+)('''+)\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: { name: storage.type.string.ruko }
          2: { name: punctuation.definition.string.ruko }
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expressions'
          - include: '#embedded-arguments'
      - comment: multi double-quoted interpolated and template string
        begin: \s*(\$+\#+|\#+\$+)("""+)\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: { name: storage.type.string.ruko }
          2: { name: punctuation.definition.string.ruko }
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expressions'
          - include: '#embedded-arguments'
      - comment: single-quoted interpolated and template string
        begin: \s*(\$+\#+|\#+\$+)(')\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: { name: storage.type.string.ruko }
          2: { name: punctuation.definition.string.ruko }
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expressions'
          - include: '#embedded-arguments'
      - comment: double-quoted interpolated and template string
        begin: \s*(\$+\#+|\#+\$+)(")\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: { name: storage.type.string.ruko }
          2: { name: punctuation.definition.string.ruko }
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expressions'
          - include: '#embedded-arguments'
      - comment: multi single-quoted format and template string
        begin: \s*(%+\#+|\#+%+)('''+)\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: { name: storage.type.string.ruko }
          2: { name: punctuation.definition.string.ruko }
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-formatting'
          - include: '#embedded-arguments'
      - comment: multi double-quoted format and template string
        begin: \s*(%+\#+|\#+%+)("""+)\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: { name: storage.type.string.ruko }
          2: { name: punctuation.definition.string.ruko }
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-formatting'
          - include: '#embedded-arguments'
      - comment: single-quoted format and template string
        begin: \s*(%+\#+|\#+%+)(')\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: { name: storage.type.string.ruko }
          2: { name: punctuation.definition.string.ruko }
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-formatting'
          - include: '#embedded-arguments'
      - comment: double-quoted format and template string
        begin: \s*(%+\#+|\#+%+)(")\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: { name: storage.type.string.ruko }
          2: { name: punctuation.definition.string.ruko }
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-formatting'
          - include: '#embedded-arguments'
      - comment: multi single-quoted verbatim and interpolated string
        begin: \s*(\\+\$+|\$+\\+)('''+)\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: { name: storage.type.string.ruko }
          2: { name: punctuation.definition.string.ruko }
        patterns:
          - match: '''''|\$\$'
            name: constant.character.escape.ruko
          - include: '#embedded-expressions'
      - comment: multi double-quoted verbatim and interpolated string
        begin: \s*(\\+\$+|\$+\\+)("""+)\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: { name: storage.type.string.ruko }
          2: { name: punctuation.definition.string.ruko }
        patterns:
          - match: '""|\$\$'
            name: constant.character.escape.ruko
          - include: '#embedded-expressions'
      - comment: single-quoted verbatim and interpolated string
        begin: \s*(\\+\$+|\$+\\+)(')\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: { name: storage.type.string.ruko }
          2: { name: punctuation.definition.string.ruko }
        patterns:
          - match: '''''|\$\$'
            name: constant.character.escape.ruko
          - include: '#embedded-expressions'
      - comment: double-quoted verbatim and interpolated string
        begin: \s*(\\+\$+|\$+\\+)(")\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: { name: storage.type.string.ruko }
          2: { name: punctuation.definition.string.ruko }
        patterns:
          - match: '""|\$\$'
            name: constant.character.escape.ruko
          - include: '#embedded-expressions'
      - comment: multi single-quoted verbatim and format string
        begin: \s*(\\+%+|%+\\+)('''+)\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: { name: storage.type.string.ruko }
          2: { name: punctuation.definition.string.ruko }
        patterns:
          - match: "''|%%"
            name: constant.character.escape.ruko
          - include: '#embedded-formatting'
      - comment: multi double-quoted verbatim and format string
        begin: \s*(\\+%+|%+\\+)("""+)\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: { name: storage.type.string.ruko }
          2: { name: punctuation.definition.string.ruko }
        patterns:
          - match: '""|%%'
            name: constant.character.escape.ruko
          - include: '#embedded-formatting'
      - comment: single-quoted verbatim and format string
        begin: \s*(\\+%+|%+\\+)(')\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: { name: storage.type.string.ruko }
          2: { name: punctuation.definition.string.ruko }
        patterns:
          - match: "''|%%"
            name: constant.character.escape.ruko
          - include: '#embedded-formatting'
      - comment: double-quoted verbatim and format string
        begin: \s*(\\+%+|%+\\+)(")\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: { name: storage.type.string.ruko }
          2: { name: punctuation.definition.string.ruko }
        patterns:
          - match: '""|%%'
            name: constant.character.escape.ruko
          - include: '#embedded-formatting'
      - comment: multi single-quoted verbatim and template string
        begin: \s*(\\+\#+|\#+\\+)('''+)\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: { name: storage.type.string.ruko }
          2: { name: punctuation.definition.string.ruko }
        patterns:
          - match: '''''|\#\#'
            name: constant.character.escape.ruko
          - include: '#embedded-arguments'
      - comment: multi double-quoted verbatim and template string
        begin: \s*(\\+\#+|\#+\\+)("""+)\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: { name: storage.type.string.ruko }
          2: { name: punctuation.definition.string.ruko }
        patterns:
          - match: '""|\#\#'
            name: constant.character.escape.ruko
          - include: '#embedded-arguments'
      - comment: single-quoted verbatim and template string
        begin: \s*(\\+\#+|\#+\\+)(')\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: { name: storage.type.string.ruko }
          2: { name: punctuation.definition.string.ruko }
        patterns:
          - match: '''''|\#\#'
            name: constant.character.escape.ruko
          - include: '#embedded-arguments'
      - comment: double-quoted verbatim and template string
        begin: \s*(\\+\#+|\#+\\+)(")\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: { name: storage.type.string.ruko }
          2: { name: punctuation.definition.string.ruko }
        patterns:
          - match: '""|\#\#'
            name: constant.character.escape.ruko
          - include: '#embedded-arguments'
      - comment: multi single-quoted interpolated string
        begin: \s*(\$+)('''+)\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: { name: storage.type.string.ruko }
          2: { name: punctuation.definition.string.ruko }
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expressions'
      - comment: multi double-quoted interpolated string
        begin: \s*(\$+)("""+)\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: { name: storage.type.string.ruko }
          2: { name: punctuation.definition.string.ruko }
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expressions'
      - comment: single-quoted interpolated string
        begin: \s*(\$+)(')\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: { name: storage.type.string.ruko }
          2: { name: punctuation.definition.string.ruko }
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expressions'
      - comment: double-quoted interpolated string
        begin: \s*(\$+)(")\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: { name: storage.type.string.ruko }
          2: { name: punctuation.definition.string.ruko }
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expressions'
      - comment: multi single-quoted format string
        begin: \s*(%+)('''+)\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: { name: storage.type.string.ruko }
          2: { name: punctuation.definition.string.ruko }
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-formatting'
      - comment: multi double-quoted format string
        begin: \s*(%+)("""+)\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: { name: storage.type.string.ruko }
          2: { name: punctuation.definition.string.ruko }
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-formatting'
      - comment: single-quoted format string
        begin: \s*(%+)(')\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: { name: storage.type.string.ruko }
          2: { name: punctuation.definition.string.ruko }
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-formatting'
      - comment: double-quoted format string
        begin: \s*(%+)(")\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: { name: storage.type.string.ruko }
          2: { name: punctuation.definition.string.ruko }
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-formatting'
      - comment: multi single-quoted template string
        begin: \s*(\#+)('''+)\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: { name: storage.type.string.ruko }
          2: { name: punctuation.definition.string.ruko }
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-arguments'
      - comment: multi double-quoted template string
        begin: \s*(\#+)("""+)\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: { name: storage.type.string.ruko }
          2: { name: punctuation.definition.string.ruko }
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-arguments'
      - comment: single-quoted template string
        begin: \s*(\#+)(')\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: { name: storage.type.string.ruko }
          2: { name: punctuation.definition.string.ruko }
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-arguments'
      - comment: double-quoted template string
        begin: \s*(\#+)(")\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: { name: storage.type.string.ruko }
          2: { name: punctuation.definition.string.ruko }
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-arguments'
      - comment: multi single-quoted verbatim string
        begin: \s*(\\+)('''+)\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: { name: storage.type.string.ruko }
          2: { name: punctuation.definition.string.ruko }
        patterns:
          - match: "''"
            name: constant.character.escape.ruko
      - comment: multi double-quoted verbatim string
        begin: \s*(\\+)("""+)\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: { name: storage.type.string.ruko }
          2: { name: punctuation.definition.string.ruko }
        patterns:
          - match: '""'
            name: constant.character.escape.ruko
      - comment: single-quoted verbatim string
        begin: \s*(\\+)(')\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: { name: storage.type.string.ruko }
          2: { name: punctuation.definition.string.ruko }
        patterns:
          - match: "''"
            name: constant.character.escape.ruko
      - comment: double-quoted verbatim string
        begin: \s*(\\+)(")\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: { name: storage.type.string.ruko }
          2: { name: punctuation.definition.string.ruko }
        patterns:
          - match: '""'
            name: constant.character.escape.ruko
      - comment: multi single-quoted plain string
        begin: \s*()('''+)\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: { name: storage.type.string.ruko }
          2: { name: punctuation.definition.string.ruko }
        patterns:
          - include: '#string-escapes'
      - comment: multi double-quoted plain string
        begin: \s*()("""+)\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: { name: storage.type.string.ruko }
          2: { name: punctuation.definition.string.ruko }
        patterns:
          - include: '#string-escapes'
      - comment: single-quoted plain string
        begin: \s*()(')\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: { name: storage.type.string.ruko }
          2: { name: punctuation.definition.string.ruko }
        patterns:
          - include: '#string-escapes'
      - comment: double-quoted plain string
        begin: \s*()(")\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: { name: storage.type.string.ruko }
          2: { name: punctuation.definition.string.ruko }
        patterns:
          - include: '#string-escapes'

  string-escapes:
    patterns:
      - begin: (\\)(?=\s*$)
        end: ^\s*(?=\S)
        captures:
          1: { name: constant.character.escape.newline.ruko }
      - include: '#unicode-escapes'
      - match: \\([cm][@A-Za-z])
        name: constant.character.control.ruko
      - match: \\[abefprnstv\\'"`(){}\[\]]
        name: constant.character.escape.ruko
      - include: '#named-escapes'
      - comment: These sequences are interpreted literally.
        match: \\.

  named-escapes:
    patterns:
      - applyEndPatternLast: true
        comment: More [] () {} can be chained for nested named escapes.
        name: keyword.function.ruko
        begin: \\j(?::([\p{Pc}\p{L}]\w*\b([:.][\p{Pc}\p{L}]\w*)*))?\b(?=[(\[{])
        beginCaptures:
          1: { patterns: [include: '#function-namespace'] }
        end: (?=)|$
        patterns: [include: '#named-escape-brackets']
      - match: (\\j:)([\p{Pc}\p{L}]\w*\b([:.][\p{Pc}\p{L}]\w*)*)\b([;,]|(?=\W))
        name: constant.character.escape.ruko
        captures:
          1: { name: punctuation.terminator.entity.ruko }
          2: { patterns: [include: '#character-namespace'] }
          3: { name: punctuation.terminator.entity.ruko }

  named-escape-brackets:
    patterns:
      - begin: (\()\s*
        end: \s*(\))
        captures:
          1: { name: punctuation.definition.group.ruko }
        patterns: [include: '#named-escape-content']
      - begin: (\[)\s*
        end: \s*(\])
        captures:
          1: { name: punctuation.definition.sequence.ruko }
        patterns: [include: '#named-escape-content']
      - begin: ({)\s*
        end: \s*(})
        captures:
          1: { name: punctuation.definition.block.ruko }
        patterns: [include: '#named-escape-content']

  named-escape-content:
    name: string.unquoted.plain.in.ruko
    patterns:
      - applyEndPatternLast: true
        name: constant.other.function.ruko
        begin: \b([\p{Pc}\p{L}]\w*\b([:.][\p{Pc}\p{L}]\w*)*)\b(?=[(\[{])
        beginCaptures:
          1: { patterns: [include: '#function-namespace'] }
        end: (?=)|$
        patterns: [include: '#named-escape-brackets']
      - match: \b([\p{Pc}\p{L}]\w*\b([:.][\p{Pc}\p{L}]\w*)*)\b
        name: constant.character.escape.ruko
        captures:
          1: { patterns: [include: '#character-namespace'] }
      - match: \b[:.](?=[\p{Pc}\p{L}]\w*|[({\[]|$)
        name: punctuation.separator.namespace.ruko
      - include: '#literals'
      - include: '#escapes-embedded'
      - include: '#operators'
      - include: '#punctuation'

  function-namespace:
    patterns:
      - match: \b([\p{Pc}\p{L}]\w*)\b(?=[.:])
        name: support entity.name.tag.namespace.ruko
      - match: \b([\p{Pc}\p{L}]\w*)\b
        name: support entity.name.tag.function.ruko

  character-namespace:
    patterns:
      - match: \b([\p{Pc}\p{L}]\w*)\b(?=[.:])
        name: constant.other.character-class.ruko
      - match: \b([\p{Pc}\p{L}]\w*)\b
        name: constant.character.escape.unicode.ruko

  unicode-escapes:
    patterns:
      - comment: standard \x escapes
        match: \\x[0-7]\h
        name: constant.character.escape.ascii.ruko
      - comment: ASCII control character escapes
        match: \\c[@A-Za-z]
        name: constant.character.escape.control.ruko
      - comment: Null character escape
        match: \\0|\\x00|\\u0000|\\U0{8}
        name: constant.character.escape.null.ruko
      - comment: Private Use Area U+E000-F8FF
        match: \\u[eE]\h{3}|\\u[fF][0-8]\h{2}
        name: constant.character.escape.private-use.ruko
      - comment: Reserved non-characters U+FDD0-FDEF
        match: \\u[fF][dD][dDeE]\h
        name: constant.character.escape.noncharacter.ruko
      - comment: Surrogate code points U+D800-DFFF
        match: \\u[dD][89abAB][c-fC-F]\h{2}(?=\\u[dD][c-fC-F]\h{2})|\\u[dD][c-fC-F]\h{2}(?=\\u[dD][89abAB][c-fC-F]\h{2})
        name: invalid.illegal.escape.surrogate.ruko
      - comment: Low surrogate pairs U+DC00-DFFF
        match: \\u[dD][c-fC-F]\h{2}
        name: constant.character.escape.surrogate-low.ruko
      - comment: High surrogate pairs U+D800-DBFF
        match: \\u[dD][89abAB]\h{2}
        name: constant.character.escape.surrogate-high.ruko
      - comment: UTF-8 continuation byte escape
        match: \\x[89abAB]\h
        name: constant.character.escape.continuation.ruko
      - comment: UTF-8 2-byte sequence lead byte escape
        match: \\x[cdCD]\h
        name: constant.character.escape.lead.two.ruko
      - comment: UTF-8 3-byte sequence lead byte escape
        match: \\x[eE]\h
        name: constant.character.escape.lead.three.ruko
      - comment: UTF-8 4-byte sequence lead byte escape
        match: \\x[fF][0-4]
        name: constant.character.escape.lead.four.ruko
      - comment: Unused/illegal UTF-8 byte escapes
        match: \\x\h{2}
        name: invalid.illegal.escape.utf8.ruko
      - comment: Hexadecimal escape sequences
        match: \\u\h{4}
        name: constant.character.escape.unicode.ruko
      - comment: UTF-32 escape sequences
        match: \\U0*(10\h{6}|\h{1,5})
        name: constant.character.escape.astral.ruko
      - comment: Binary escape sequences
        match: \\b0*(10000[0-1]{16}|1[01]{0,19}|0)
        name: constant.character.escape.binary.ruko
      - comment: Octal escape sequences
        match: \\o0*(41[0-7]{5}|[1-3][0-7]{6}|[1-7][0-7]{0,5}|0)
        name: constant.character.escape.octal.ruko
      - comment: Decimal escape sequences
        match: \\0*(111411[10]|111410\d|11140\d{2}|111[0-3]\d{3}|110\d{4}|10\d{5}|[1-9]\d{0,5}|0)
        name: constant.character.escape.numeric.ruko
      - comment: Quaternary escape sequences
        match: \\q0*(1003{8}|100[0-2]{10}|10[0-3]{12}|[1-3][0-3]{0,18}|0)
        name: constant.character.escape.quaternary.ruko
      - comment: Duodecimal escape sequences (4588A7)
        match: \\z0*(?i:4588[↊atx][0-6]|4588\d[\d↊↋abetx]|458[0-7][\d↊↋abetx]{2}|45[0-7][\d↊↋abetx]{3}|4[0-4][\d↊↋abetx]{4}|[1-3][\d↊↋abetx]{5}|[1-9][\d↊↋abetx]{0,5}|0)
        name: constant.character.escape.duodecimal.ruko

  # Embedded expressions

  embedded:
    patterns:
      - include: '#embedded-expressions'
      - include: '#embedded-formatting'
      - include: '#embedded-arguments'

  embedded-verbatim:
    patterns:
      - match: \#\#|\$\$|\%\%
        name: constant.character.escape.ruko
      - include: '#embedded-expressions'
      - include: '#embedded-formatting'
      - include: '#embedded-arguments'

  embedded-expressions:
    patterns:
      - comment: Interpolated expression
        begin: (\${)\s*
        end: \s*(})
        name: meta.embedded.expression.ruko
        captures:
          1: { name: punctuation.definition.variable.ruko }
        patterns: [include: $self]
      - comment: Interpolated expression
        applyEndPatternLast: true
        name: meta.embedded.expression.ruko
        begin: |-
          (?x)
          (\$) # beginning of identifier
          # ignore all keywords
          (?!
            (?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b
            (?: # keywords
              # wordlike operators
              [io]n|off?|[ai]s|has|new|old|del|(?:de)?ref|to
              |(?:un)?[gs]et|n?and|x?n?or|c?n?imply|not|by

              # declaration keywords
              |va[rl]|dyn|mut|let|const
              |func|pro[pc]|type|class|actor|trait|enum|in?ter
              |module|schema|struct|record|object|union|macro
              |query|quote|style|script|entity|temp|oper|realm

              # control flow keywords
              |if|else|[tw]hen|guard|with|unless
              |for|while|loop|goto|break|skip|redo|until
              |try|switch|[cm]atch|case|def|throw|raise|error
              |return|yield|await|move|goto|pass|defer
              |[gd]o|from|where|(?:im|ex)(?:port|tern)

              # miscellaneous keywords
              |debug|assert|check|decl
              |use|echo|eval|expr|scope
              |begin|end|prev|next
            )
            \b
          )
          (?=[\p{Pc}\p{L}]) # next to a word
        end: (?=)|$
        captures:
          1: { name: punctuation.definition.variable.ruko }
        patterns:
          - include: '#constants'
          - include: '#generics'
          - include: '#brackets'
          - include: '#embedded-function-calls'
          - match: (?<=>|\w)(!)(?=\#?[({])
            captures:
              1: { name: keyword.operator.macro.ruko }
          - match: (?<=>|\w)(~)(?=\#?[({])
            captures:
              1: { name: keyword.operator.destructor.ruko }
          - include: '#variables'
          - include: '#numbers'
          - *qualified-name-separators

  embedded-arguments:
    patterns:
      - name: meta.embedded.placeholder.ruko
        match: |-
          (?x)
          (\#) # sigil
          ([+-]?) (\d+) # start of range
          (?:
            (?:
              ([>.]\.[.<]|\.\.|[=.]\.[.=]|\.\.=?|=\.=) # range operator
              ([+-]?) (\d+) # to
              (?:
                (\.\.) # step operator
                ([+-]?) (\d+) # by
              )?
            )?
          )?
        captures:
          1: { name: punctuation.definition.anchor.ruko }
          2: { name: keyword.operator.arithmetic.sign.ruko }
          3: { name: constant.numeric.range.start.ruko }
          4: { name: keyword.operator.range.ruko }
          5: { name: keyword.operator.arithmetic.sign.ruko }
          6: { name: constant.numeric.range.end.ruko }
          7: { name: keyword.operator.range.ruko }
          8: { name: keyword.operator.arithmetic.sign.ruko }
          9: { name: constant.numeric.range.step.ruko }
      - name: meta.embedded.placeholder.ruko
        match: |-
          (?x)
          (\#) # sigil
          (?:
            \s*
            ((?:[*&%@^!~?\\\-+]|\.{3})*) # any sigils
            ( # identifier
              (?: # function name
                \b
                # ignore all keywords
                (?!
                  (?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b
                  (?: # keywords
                    # wordlike operators
                    [io]n|off?|[ai]s|has|new|old|del|(?:de)?ref|to
                    |(?:un)?[gs]et|n?and|x?n?or|c?n?imply|not|by

                    # declaration keywords
                    |va[rl]|dyn|mut|let|const
                    |func|pro[pc]|type|class|actor|trait|enum|in?ter
                    |module|schema|struct|record|object|union|macro
                    |query|quote|style|script|entity|temp|oper|realm

                    # control flow keywords
                    |if|else|[tw]hen|guard|with|unless
                    |for|while|loop|goto|break|skip|redo|until
                    |try|switch|[cm]atch|case|def|throw|raise|error
                    |return|yield|await|move|goto|pass|defer
                    |[gd]o|from|where|(?:im|ex)(?:port|tern)

                    # miscellaneous keywords
                    |debug|assert|check|decl
                    |use|echo|eval|expr|scope
                    |begin|end|prev|next
                  )
                  \b
                )
                \b[\p{Pc}\p{L}]\w*\b # identifier
              )
            )
            ([!?]*) # optional sigils
            \s*
          )
        captures:
          1: { name: punctuation.definition.anchor.ruko }
          2:
            name: keyword.operator.prefix.ruko
            patterns: [include: '#parameter-type-operators']
          3:
            name: variable.parameter.ruko
            patterns: [include: '#constants']
          4:
            name: keyword.operator.suffix.ruko
            patterns: [include: '#parameter-type-operators']
      - name: meta.embedded.placeholder.ruko
        begin: (\#{)\s*
        end: \s*(})
        captures:
          1: { name: punctuation.definition.anchor.ruko }
        patterns:
          - include: '#call-arguments'
          - include: $self

  # Format and flag specifiers

  embedded-formatting:
    comment: Oniguruma supports only 20 levels of recursion
    applyEndPatternLast: true
    name: meta.embedded.formatting.ruko
    begin: (?<!%)(%)(?=[\p{Pc}\p{L}])
    end: (?=)|$
    captures:
      1: { name: punctuation.definition.directive.ruko }
    patterns: [include: '#format-syntax']

  format-syntax:
    comment: Format specifier language, inspired by MS-DOS, Bash and Python's f-strings.
    patterns:
      - comment: with optional value
        applyEndPatternLast: true
        begin: (?:(?<=%)|(\|))([\p{Pc}\p{L}]\w*)\b(:)
        end: (?=)|$
        name: storage.type.format.ruko
        captures:
          1: { name: punctuation.separator.mapping.ruko }
          2: { name: storage.type.format.ruko }
          3: { name: punctuation.separator.key-value.ruko }
        patterns:
          - include: '#constants'
          - include: '#generics'
          - include: '#brackets'
          - include: '#embedded-function-calls'
          - match: (?<=>|\w)(!)(?=\#?[({])
            captures:
              1: { name: keyword.operator.macro.ruko }
          - match: (?<=>|\w)(~)(?=\#?[({])
            captures:
              1: { name: keyword.operator.destructor.ruko }
          - include: '#variables'
          - include: '#numbers'
          - include: '#regexps'
          - include: '#symbols'
          - *qualified-name-separators
      - comment: type specifier
        match: (?:(?<=%)|(\|))([\p{Pc}\p{L}]\w*)\b
        name: storage.type.format.ruko
        captures:
          1: { name: punctuation.separator.mapping.ruko }
          2: { name: storage.type.format.ruko }
      - comment: // for multiple flags at once with single-character aliases
        match: (?:(?<=%)|(//))([\p{Pc}\p{L}]\w*)\b
        name: storage.type.format.ruko
        captures:
          1: { name: punctuation.definition.flag.ruko }
          2: { name: storage.type.format.ruko }
      - comment: / for a single flag, with optional arguments
        match: (?:(?<=%)|(/))([\p{Pc}\p{L}]\w*)\b
        name: storage.type.format.ruko
        captures:
          1: { name: punctuation.definition.flag.ruko }
          2: { name: storage.type.format.ruko }
      - include: '#format-switch-clause'

  format-switch-clause:
    patterns:
      - comment: // for multiple flags at once with single-character aliases
        applyEndPatternLast: true
        begin: (?:(?<=%)|(//))([\p{Pc}\p{L}]\w*)\b
        end: (?=)|$
        captures:
          1: { name: punctuation.definition.flag.ruko }
          2: { name: storage.type.format.ruko }
        patterns:
          - comment: Format switch without value
            match: ([\p{Pc}\p{L}]\w*)
            captures:
              1: { name: keyword.other.flag.ruko }
      - comment: / for a single flag, with optional arguments
        applyEndPatternLast: true
        begin: (?:(?<=%)|(/))([\p{Pc}\p{L}]\w*)\b
        end: (?=)|$
        captures:
          1: { name: punctuation.definition.flag.ruko }
          2: { name: storage.type.format.ruko }
        patterns:
          - comment: Format switch without value
            match: ([\p{Pc}\p{L}]\w*)
            captures:
              1: { name: keyword.modifier.ruko }

  # Regular expressions

  regexps:
    applyEndPatternLast: true
    begin: |-
      (?x)(?<=
        (?:
            ^ # beginning of line
          | [,;] # separator
          | \#? [({\[] # opening bracket
          | [\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]+ \s # postfix or infix operator
          | (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            [\p{Pc}\p{L}]\w*  # keyword or identifier
        ) \s*
      ) \s*
      (?=/['"`\w\\(\[{]|/$)
    end: (?=)|$
    name: meta.regexp.ruko
    patterns:
      - applyEndPatternLast: true
        comment: Single-line pattern section
        begin: (/)(?![/*])\s*
        end: \s*(/)(\p{L}*)
        contentName: string.regexp.pattern.ruko
        captures:
          1: { name: punctuation.definition.regexp.ruko }
          2: { name: keyword.other.flag.ruko }
        patterns:
          - include: '#regexp-patterns'
          - comment: Single-line replacement section
            begin: (:)\s*
            end: \s*(\|)|\s*(?=/)
            name: string.regexp.replace.ruko
            captures:
              1: { name: punctuation.definition.regexp.ruko }
            patterns:
              - include: '#back-references'
              - include: '#escapes-embedded'

  fuzzy-expression:
    patterns:
      - include: '#punctuation'
      - include: '#comments'
      - include: '#function-calls'
      - include: '#literals'
      - include: '#embedded'
      - include: '#operators'
      - include: '#clauses'
      - include: '#declarations'
      - include: '#keywords'
      - include: '#fuzzy-brackets'
      - match: \b[\p{Pc}\p{L}]\w*\b
        name: keyword.other.unit.ruko
      - include: '#space'

  fuzzy-brackets:
    patterns:
      - begin: ({)\s*
        end: \s*(})
        captures:
          1: { name: punctuation.definition.mapping.ruko }
        patterns:
          - match: ','
            name: punctuation.separator.mapping.ruko
          - include: '#object-labels'
          - include: '#fuzzy-expression'
          - include: $self
      - begin: (\[)\s*
        end: \s*(\])
        captures:
          1: { name: punctuation.definition.array.ruko }
        patterns:
          - match: ','
            name: punctuation.separator.sequence.ruko
          - include: '#fuzzy-expression'
          - include: $self
      - begin: (\()\s*
        end: \s*(\))
        captures:
          1: { name: punctuation.definition.expression.ruko }
        patterns:
          - match: ','
            name: punctuation.separator.arguments.ruko
          - include: '#fuzzy-expression'
          - include: $self

  back-references:
    patterns:
      - match: \$(\d+[+-]?|[+-]\d*)
        name: keyword.other.back-reference.ruko
      - begin: (\$<)\s*
        end: \s*(>)
        name: keyword.other.back-reference.ruko
        captures:
          1: { name: keyword.other.back-reference.ruko }
        patterns: &regex-back-references
          - match: \b[\p{Pc}\p{L}]\w*\b
            name: constant.other.back-reference.name.ruko
          - match: ([+-])?(\d+)
            captures:
              1: { name: keyword.operator.arithmetic.sign.ruko }
              2: { name: constant.other.back-reference.number.ruko }
      - begin: (\$(['"]))\s*
        end: \s*(\2)
        name: keyword.other.back-reference.ruko
        captures:
          1: { name: keyword.other.back-reference.ruko }
        patterns: *regex-back-references

  regexp-patterns:
    comment: |
      See https://gist.github.com/CMCDragonkai/6c933f4a7d713ef712145c5eb94a1816
      and https://www.regular-expressions.info/
    patterns:
      - include: '#comments'
      - include: '#embedded'
      - include: '#strings'
      - include: '#unicode-escapes'
      - match: \|
        name: keyword.operator.or.ruko
      - match: \&
        name: keyword.operator.composition.ruko
      - match: \.
        name: constant.character.all.ruko
      - match: (?i)\\[by](?:{(?:[^\\{}]|\\.)+})?
        name: keyword.control.anchor.ruko
      - match: (\\[aAm<]|\^+)(?:{(?:[^\\{}]|\\.)+})?
        name: keyword.control.begin.ruko
      - match: (\\[zZM>]|\$+)(?:{(?:[^\\{}]|\\.)+})?
        name: keyword.control.end.ruko
      - match: \\K
        name: keyword.control.keep-out.ruko
      - match: \\G
        name: keyword.control.search.ruko
      - match: \\R
        name: constant.character.control.ruko
      - match: \\[XO]
        name: constant.character.unicode.ruko
      - match: \\\d+
        name: keyword.other.back-reference.ruko
      - match: \{\s*(?:\d*\s*,){,2}\s*\d*\s*}\s*(?:(\?)|(\+)|(\*))?
        captures:
          0: { name: keyword.operator.quantifier.ruko }
          1: { name: keyword.operator.modifier.lazy.ruko }
          2: { name: keyword.operator.modifier.eager.ruko }
          3: { name: keyword.operator.modifier.greedy.ruko }
      - match: (?:(\?)|(\+)|(\*))\s*(?:(\?)|(\+)|(\*))?
        captures:
          1: { name: keyword.operator.quantifier.lazy.ruko }
          2: { name: keyword.operator.quantifier.eager.ruko }
          3: { name: keyword.operator.quantifier.greedy.ruko }
          4: { name: keyword.operator.modifier.lazy.ruko }
          5: { name: keyword.operator.modifier.eager.ruko }
          6: { name: keyword.operator.modifier.greedy.ruko }
      - begin: (\\k<)
        end: \s*(>)
        name: constant.other.back-reference.ruko
        captures:
          1: { name: keyword.other.back-reference.ruko }
        patterns: *regex-back-references
      - begin: (\\g<)
        end: \s*(>)
        name: constant.other.subroutine.ruko
        captures:
          1: { name: keyword.other.subroutine.ruko }
        patterns: *regex-back-references
      - begin: (\\k(?:'+|"+))
        end: \s*(\2)
        name: constant.other.back-reference.ruko
        captures:
          1: { name: keyword.other.back-reference.ruko }
        patterns: *regex-back-references
      - begin: (\\g(?:'+|"+))
        end: \s*(\2)
        name: constant.other.subroutine.ruko
        captures:
          1: { name: keyword.other.subroutine.ruko }
        patterns: *regex-back-references
      - begin: ({)
        end: \s*(})
        name: meta.fuzzy.ruko
        captures:
          1: { name: punctuation.definition.fuzzy.ruko }
        patterns:
          - applyEndPatternLast: true
            begin: (?<=^|\\.|[,;'"`({\[)}\]\w\s])(:)
            beginCaptures:
              1: { name: punctuation.separator.key-value.ruko }
            end: (?=[,;}]|)|$
            patterns: [include: '#regexp-patterns']
          - include: '#fuzzy-expression'
      - match: \\[abefrntv]
        name: constant.character.escape.ruko
      - comment: |
          Character classes (uppercase negated):
          - \d: digit
          - \s: whitespace
          - \w: word character
          - \h: hexadecimal digit
          - \u: uppercase
          - \l: lowercase
          - \i: identifier start
          - \c: identifier continue
        match: \\[wsdhulic]
        name: constant.other.character-class.ruko
      - match: \\[WSDHULIC]
        name: constant.other.character-class.negated.ruko
      - &regexp-quote-lower
        begin: (\\q{)
        end: \s*(})
        name: string.quoted.regexp.ruko
        captures:
          1: { name: punctuation.definition.quote.begin.ruko }
          2: { name: punctuation.definition.quote.end.ruko }
        patterns:
          - match: \|
            name: keyword.operator.or.ruko
      - &regexp-quote-upper
        begin: (\\Q)
        end: \s*(\\E)
        name: string.quoted.regexp.ruko
        captures:
          1: { name: punctuation.definition.quote.begin.ruko }
          2: { name: punctuation.definition.quote.end.ruko }
        patterns:
          - match: \|
            name: keyword.operator.or.ruko
      - include: '#regexp-groups'
      - include: '#regexp-character-set'
      - include: '#regexp-character-class'
      - match: \\. # fallback for any other escaped character
        name: constant.character.escape.other.ruko
      - include: '#space'

  regexp-groups:
    patterns:
      - comment: Backtracking control verb
        begin: (\(\*([\p{Pc}\p{L}]\w*)?(:)?)
        end: \s*(\))
        name: meta.group.backtrack.ruko
        captures:
          1: { name: punctuation.section.expression.ruko }
          2: { name: keyword.control.ruko }
          3: { name: punctuation.separator.colon.ruko }
        patterns: [include: '#regexp-patterns']
      - comment: Block comment
        begin: (\()(\?#)
        contentName: comment.block.regexp.ruko
        end: \s*(\))
        name: comment.block.regexp.ruko
        captures:
          1: { name: punctuation.definition.comment.ruko }
        patterns:
          - match: \\.
            name: comment.block.regexp.ruko
      - comment: Lookahead assertion
        begin: (\(\?=)
        end: \s*(\))
        name: meta.group.look-ahead.ruko
        captures:
          1: { name: punctuation.definition.group.look-ahead.ruko }
        patterns: [include: '#regexp-patterns']
      - comment: Lookbehind assertion
        begin: (\(\?<=)
        end: \s*(\))
        name: meta.group.look-behind.ruko
        captures:
          1: { name: punctuation.definition.group.look-behind.ruko }
        patterns: [include: '#regexp-patterns']
      - comment: Negative lookahead assertion
        begin: (\(\?!)
        end: \s*(\))
        name: meta.group.negative-look-ahead.ruko
        captures:
          1: { name: punctuation.definition.group.negative-look-ahead.ruko }
        patterns: [include: '#regexp-patterns']
      - comment: Negative lookbehind assertion
        begin: (\(\?<!)
        end: \s*(\))
        name: meta.group.negative-look-behind.ruko
        captures:
          1: { name: punctuation.definition.group.negative-look-behind.ruko }
        patterns: [include: '#regexp-patterns']
      - comment: Match directive Oniguruma supports only 20 levels of recursion
        begin: (?x)(\(\?)(?=%)
        captures:
          1: { name: punctuation.definition.group.directive.ruko }
        end: \s*(\))
        name: meta.group.directive.ruko
        patterns:
          - include: '#format-syntax'
          - include: '#regexp-patterns'
      - comment: Longest match
        begin: (\(\?/=?)
        end: \s*(\))
        name: meta.group.longest.ruko
        captures:
          1: { name: punctuation.definition.group.longest.ruko }
        patterns: [include: '#regexp-patterns']
      - comment: Back-reference groups
        begin: \((\?&(?:([+-]?\d+)|([\p{Pc}\p{L}]\w*)))(:)?
        end: \s*\)
        name: meta.group.back-reference.ruko
        captures:
          0: { name: punctuation.definition.group.back-reference.ruko }
          1: { name: punctuation.definition.group.back-reference.ruko }
          2: { name: constant.numeric.index.ruko }
          3: { patterns: [include: '#variables'] }
          4: { name: punctuation.separator.colon.ruko }
        patterns: [include: '#regexp-patterns']
      - comment: Back-reference groups
        begin: \((\?&)
        end: \s*\)
        name: meta.group.back-reference.ruko
        captures:
          0: { name: punctuation.definition.group.back-reference.ruko }
          1: { name: punctuation.definition.group.back-reference.ruko }
        patterns:
          - begin: (?<=\(\?&)('''+|"""+|['"])
            end: \s*(\1)
            name: constant.other.group.ruko
            captures:
              1: { name: punctuation.definition.group.back-reference.ruko }
            patterns: *regex-back-references
          - include: '#regexp-patterns'
      - comment: Flag modifier group
        begin: (\(\?\^?(?:([+-]?\d+?)|((?:[+-]\p{Lu}+)+|\p{Lu}+(?:[+-]\p{Lu}+)*)|((?:[+-]\p{Ll}+)+|\p{Ll}+(?:[+-]\p{Ll}+)*)))\s*(:)?
        end: \s*(\))
        name: meta.group.flag.ruko
        captures:
          0: { name: punctuation.definition.group.flag.ruko }
          1: { name: punctuation.definition.group.flag.ruko }
          2: { name: constant.numeric.index.ruko }
          3: { name: keyword.control.recursion.ruko }
          4: { name: keyword.other.flag.ruko }
          5: { name: punctuation.separator.colon.ruko }
        patterns: [include: '#regexp-patterns']
      - comment: Call-outs
        begin: (\(\?)(?={)
        end: \s*(\))
        name: meta.group.call-out.ruko
        captures:
          1: { name: punctuation.definition.group.call-out.ruko }
        patterns:
          - begin: (?<=\(\?)({)
            end: \s*(})\s*([<*>])?(?:(\[)(.*?)(\]))?
            name: punctuation.definition.group.call-out.ruko
            captures:
              1: { name: punctuation.definition.group.call-out.ruko }
              2: { name: keyword.operator.range.ruko }
              3: { name: punctuation.definition.tag.ruko }
              4: { patterns: [include: '#function-names'] }
              5: { name: punctuation.definition.tag.ruko }
            patterns: [include: $self]
          - include: '#regexp-patterns'
      - comment: Atomic groups
        begin: (\(\?>)
        end: \s*(\))
        name: meta.group.atomic.ruko
        captures:
          1: { name: punctuation.definition.group.atomic.ruko }
        patterns: [include: '#regexp-patterns']
      - comment: Non-capturing groups
        begin: (\(\?:)
        end: \s*(\))
        name: meta.group.non-capturing.ruko
        captures:
          1: { name: punctuation.definition.group.non-capturing.ruko }
        patterns: [include: '#regexp-patterns']
      - comment: Branch groups
        begin: (\(\?)(?=[(|])
        end: \s*(\))
        name: meta.group.branch.ruko
        captures:
          1: { name: punctuation.definition.group.branch.ruko }
        patterns: [include: '#regexp-patterns']
      - comment: Absent groups
        begin: (\(\?~(\|))
        end: \s*(\))
        name: meta.group.absent.ruko
        captures:
          1: { name: punctuation.definition.group.absent.ruko }
          2: { name: punctuation.definition.group.absent.stopper.ruko }
        patterns:
          - match: \|
            name: punctuation.definition.group.absent.stopper.ruko
          - include: '#regexp-patterns'
      - comment: Named groups (angle brackets)
        begin: \(\?(?=<(?![!=]))
        end: \s*(\))
        name: meta.group.named.ruko
        captures:
          0: { name: punctuation.definition.group.named.ruko }
        patterns:
          - begin: (?<=\(\?)(<)
            end: \s*(>)
            name: constant.other.group.ruko
            captures:
              1: { name: punctuation.definition.group.named.ruko }
            patterns: *regex-back-references
          - include: '#regexp-patterns'
      - comment: Named groups (single or double-quotes)
        begin: \(\?(?=['"])
        end: \s*(\))
        name: meta.group.named.ruko
        captures:
          0: { name: punctuation.definition.group.named.ruko }
        patterns:
          - begin: (?<=\(\?)('''+|"""+|['"])
            end: \s*(\1)
            name: constant.other.group.ruko
            captures:
              1: { name: punctuation.definition.group.named.ruko }
            patterns: *regex-back-references
          - include: '#regexp-patterns'
      - comment: Unnamed groups
        begin: (\()
        end: (\s*\))
        name: meta.group.ruko
        captures:
          1: { name: punctuation.definition.group.ruko }
        patterns: [include: '#regexp-patterns']

  regexp-character-class:
    patterns:
      - include: '#embedded'
      - begin: (\\)(?=\s*$)
        end: ^\s*(?=\S)
        captures:
          1: { name: constant.character.escape.newline.ruko }
      - include: '#named-escapes'
      - include: '#unicode-escapes'
      - begin: (?i)\\p{
        end: \s*}
        name: constant.other.character-class.unicode.ruko
        patterns: [include: '#attribute-selectors']
      - *regexp-quote-lower
      - *regexp-quote-upper
      - match: (?i)\\([cm][a-z])
        name: constant.character.control.ruko
      - match: (?i)\\p[a-z]{1,2}
        name: constant.other.character-class.unicode.ruko
      - match: (?i)\\[ci]({\w+})?
        name: constant.other.character-class.xml.ruko
      - match: (?i)\\n{(?:[^\\{}]|\\.)+}
        name: constant.character.escape.unicode.name.ruko
      - match: \\[abefprntv]
        name: constant.character.escape.ruko
      - match: \\[a-z]
        name: constant.other.character-class.ruko
      - match: \\[A-Z]
        name: constant.other.character-class.negated.ruko
      - match: \\\p{S}
        name: constant.character.escape.symbol.ruko
      - match: \\\p{P}
        name: constant.character.escape.punctuation.ruko
      - match: \\[a-zA-Z\p{C}]
        name: invalid.illegal.escape.ruko
      - match: \\\s
        name: constant.character.escape.space.ruko
      - match: \\\p{L}
        name: constant.character.escape.letter.ruko
      - match: \\\p{N}
        name: constant.character.escape.number.ruko
      - match: \\.
        name: constant.character.escape.other.ruko

  regexp-character-operators:
    patterns:
      - match: |-
          (?x)
          ( # from
              \\0*(?:111411[10]|111410\d|11140\d{2}|111[0-3]\d{3}|110\d{4}|10\d{5}|[1-9]\d{0,5}|0) # decimal escape
            | \\o0*(?:41[0-7]{5}|[1-3][0-7]{6}|[1-7][0-7]{0,5}|0) # octal escape
            | \\b0*(?:10000[0-1]{16}|1[01]{0,19}|0) # binary escape
            | \\q0*(?:1003{8}|100[0-2]{10}|10[0-3]{12}|[1-3][0-3]{0,18}|0) # quaternary escape
            | \\z0*(?i:4588[↊atx][0-6]|4588\d[\d↊↋abetx]|458[0-7][\d↊↋abetx]{2}|45[0-7][\d↊↋abetx]{3}|4[0-4][\d↊↋abetx]{4}|[1-3][\d↊↋abetx]{5}|[1-9][\d↊↋abetx]{0,5}|0) # duodecimal escape
            | \\x\h\h # hex escape (2-digit)
            | \\u\h{4} # hex escape (4-digit)
            | \\U0*(?:10\h{6}|\h{1,5}) # hex escape (variable-length)
            | \\[cm][a-z] # meta-character
            | \\j{(?:[^\\{}]|\\.)+} # Unicode named character
            | \\(?:[abefprntv]|[^a-zA-Z]) # any escape character
            | [^\-\\\[\]] # any unescaped character
          )
            \s*(>?->?)\s* # range
          ( # to
              \\0*(?:111411[10]|111410\d|11140\d{2}|111[0-3]\d{3}|110\d{4}|10\d{5}|[1-9]\d{0,5}|0) # decimal escape
            | \\o0*(?:41[0-7]{5}|[1-3][0-7]{6}|[1-7][0-7]{0,5}|0) # octal escape
            | \\b0*(?:10000[0-1]{16}|1[01]{0,19}|0) # binary escape
            | \\q0*(?:1003{8}|100[0-2]{10}|10[0-3]{12}|[1-3][0-3]{0,18}|0) # quaternary escape
            | \\z0*(?i:4588[↊atx][0-6]|4588\d[\d↊↋abetx]|458[0-7][\d↊↋abetx]{2}|45[0-7][\d↊↋abetx]{3}|4[0-4][\d↊↋abetx]{4}|[1-3][\d↊↋abetx]{5}|[1-9][\d↊↋abetx]{0,5}|0) # duodecimal escape
            | \\x\h\h # hex escape (2-digit)
            | \\u\h{4} # hex escape (4-digit)
            | \\U0*(?:10\h{6}|\h{1,5}) # hex escape (variable-length)
            | \\[cm][a-z] # meta-character
            | \\j{(?:[^\\{}]|\\.)+} # Unicode named character
            | \\(?:[abefprntv]|[^a-zA-Z]) # any escape character
            | [^\-\\\[\]] # any unescaped character
          ) (?:
              \s*(:)\s*
            ( # by
                -?0*(?:111411[10]|111410\d|11140\d{2}|111[0-3]\d{3}|110\d{4}|10\d{5}|[1-9]\d{0,5}|0) # decimal
              | -?0o0*(?:41[0-7]{5}|[1-3][0-7]{6}|[1-7][0-7]{0,5}|0) # octal
              | -?0b0*(?:10000[0-1]{16}|1[01]{0,19}|0) # binary
              | -?0x0*(?:10\h{6}|\h{1,5}) # hexadecimal
              | -?0q0*(?:1003{8}|100[0-2]{10}|10[0-3]{12}|[1-3][0-3]{0,18}|0) # quaternary
              | -?0z0*(?i:4588[↊atx][0-6]|4588\d[\d↊↋abetx]|458[0-7][\d↊↋abetx]{2}|45[0-7][\d↊↋abetx]{3}|4[0-4][\d↊↋abetx]{4}|[1-3][\d↊↋abetx]{5}|[1-9][\d↊↋abetx]{0,5}|0) # duodecimal
            )
          )?
        captures:
          1:
            name: constant.other.character-class.range.from.ruko
            patterns:
              - include: '#regexp-character-class'
              - include: '#regexp-character-operators'
          2: { name: keyword.operator.range.ruko }
          3:
            name: constant.other.character-class.range.to.ruko
            patterns:
              - include: '#regexp-character-class'
              - include: '#regexp-character-operators'
          4: { name: keyword.operator.range.ruko }
          5:
            name: constant.other.character-class.range.by.ruko
            patterns:
              - include: '#numbers'
              - include: '#regexp-character-class'
              - include: '#regexp-character-operators'
      - match: (\|\|)|(&&)|(\^\^)|(--)
        name: keyword.operator.set.ruko
        captures:
          1: { name: keyword.operator.union.ruko }
          2: { name: keyword.operator.intersection.ruko }
          3: { name: keyword.operator.exclusion.ruko }
          4: { name: keyword.operator.difference.ruko }

  regexp-character-set:
    patterns:
      - begin: (\[:)
        end: \s*(:\])
        name: constant.other.character-set.posix.ruko
        captures:
          1: { name: punctuation.definition.character-class.posix.ruko }
        patterns:
          - include: '#attribute-selectors'
      - begin: (\[\^)
        end: \s*(\])
        name: constant.other.character-set.negated.ruko
        captures:
          1: { name: punctuation.definition.character-class.negated.ruko }
        patterns:
          - include: '#comments'
          - include: '#regexp-character-operators'
          - include: '#regexp-character-class'
          - include: '#regexp-character-set'
      - begin: (\[)
        end: \s*(\])
        name: constant.other.character-set.ruko
        captures:
          1: { name: punctuation.definition.character-class.ruko }
        patterns:
          - include: '#comments'
          - include: '#regexp-character-operators'
          - include: '#regexp-character-class'
          - include: '#regexp-character-set'

  unicode-property-keys:
    comment: 'Corresponds to Unicode Standard Annex #44
      https://unicode.org/Public/UCD/latest/ucd/PropertyAliases.txt'
    patterns:
      - comment: Numeric Unicode property aliases and canonical names
        match: |-
          (?xi)\b(
              cjkAccountingNumeric     | kAccountingNumeric
            | cjkOtherNumeric          | kOtherNumeric
            | cjkPrimaryNumeric        | kPrimaryNumeric
            | nv                       | Numeric_Value
          )\b
        name: support.type.property-name.unicode.numeric.ruko
      - comment: String Unicode property aliases and canonical names
        match: |-
          (?xi)\b(
              bmg                      | Bidi_Mirroring_Glyph
            | bpb                      | Bidi_Paired_Bracket
            | cf                       | Case_Folding
            | cjkCompatibilityVariant  | kCompatibilityVariant
            | dm                       | Decomposition_Mapping
            | EqUIdeo                  | Equivalent_Unified_Ideograph
            | FC_NFKC                  | FC_NFKC_Closure
            | lc                       | Lowercase_Mapping
            | NFKC_CF                  | NFKC_Casefold
            | NFKC_SCF                 | NFKC_Simple_Casefold
            | scf                      | Simple_Case_Folding          | sfc
            | slc                      | Simple_Lowercase_Mapping
            | stc                      | Simple_Titlecase_Mapping
            | suc                      | Simple_Uppercase_Mapping
            | tc                       | Titlecase_Mapping
            | uc                       | Uppercase_Mapping
          )
        name: support.type.property-name.unicode.string.ruko
      - comment: Catalog Unicode property aliases and canonical names
        match: |-
          (?xi)\b(
                age                      | Age
              | blk                      | Block
              | sc                       | Script
              | scx                      | Script_Extensions # note: not in UAX #44
          )\b
        name: support.type.property-name.unicode.catalog.ruko
      - comment: Enumerated Unicode property aliases and canonical names
        match: |-
          (?xi)\b(
              bc                       | Bidi_Class
            | bpt                      | Bidi_Paired_Bracket_Type
            | ccc                      | Canonical_Combining_Class
            | dt                       | Decomposition_Type
            | ea                       | East_Asian_Width
            | gc                       | General_Category
            | GCB                      | Grapheme_Cluster_Break
            | hst                      | Hangul_Syllable_Type
            | InCB                     | Indic_Conjunct_Break
            | InPC                     | Indic_Positional_Category
            | InSC                     | Indic_Syllabic_Category
            | jg                       | Joining_Group
            | jt                       | Joining_Type
            | lb                       | Line_Break
            | NFC_QC                   | NFC_Quick_Check
            | NFD_QC                   | NFD_Quick_Check
            | NFKC_QC                  | NFKC_Quick_Check
            | NFKD_QC                  | NFKD_Quick_Check
            | nt                       | Numeric_Type
            | SB                       | Sentence_Break
            | vo                       | Vertical_Orientation
            | WB                       | Word_Break
          )\b
        name: support.type.property-name.unicode.enumerated.ruko
      - comment: Binary Unicode propery aliases and canonical names
        match: |-
          (?xi)\b(
              AHex                     | ASCII_Hex_Digit
            | Alpha                    | Alphabetic
            | Bidi_C                   | Bidi_Control
            | Bidi_M                   | Bidi_Mirrored
            | Cased                    | Cased
            | CE                       | Composition_Exclusion
            | CI                       | Case_Ignorable
            | Comp_Ex                  | Full_Composition_Exclusion
            | CWCF                     | Changes_When_Casefolded
            | CWCM                     | Changes_When_Casemapped
            | CWKCF                    | Changes_When_NFKC_Casefolded
            | CWL                      | Changes_When_Lowercased
            | CWT                      | Changes_When_Titlecased
            | CWU                      | Changes_When_Uppercased
            | Dash                     | Dash
            | Dep                      | Deprecated
            | DI                       | Default_Ignorable_Code_Point
            | Dia                      | Diacritic
            | EBase                    | Emoji_Modifier_Base
            | EComp                    | Emoji_Component
            | EMod                     | Emoji_Modifier
            | Emoji                    | Emoji
            | EPres                    | Emoji_Presentation
            | Ext                      | Extender
            | ExtPict                  | Extended_Pictographic
            | Gr_Base                  | Grapheme_Base
            | Gr_Ext                   | Grapheme_Extend
            | Gr_Link                  | Grapheme_Link
            | Hex                      | Hex_Digit
            | Hyphen                   | Hyphen
            | ID_Compat_Math_Continue  | ID_Compat_Math_Continue
            | ID_Compat_Math_Start     | ID_Compat_Math_Start
            | IDC                      | ID_Continue
            | Ideo                     | Ideographic
            | IDS                      | ID_Start
            | IDSB                     | IDS_Binary_Operator
            | IDST                     | IDS_Trinary_Operator
            | IDSU                     | IDS_Unary_Operator
            | Join_C                   | Join_Control
            | kEH_NoMirror             | kEH_NoMirror
            | kEH_NoRotate             | kEH_NoRotate
            | LOE                      | Logical_Order_Exception
            | Lower                    | Lowercase
            | Math                     | Math
            | MCM                      | Modifier_Combining_Mark
            | NChar                    | Noncharacter_Code_Point
            | OAlpha                   | Other_Alphabetic
            | ODI                      | Other_Default_Ignorable_Code_Point
            | OGr_Ext                  | Other_Grapheme_Extend
            | OIDC                     | Other_ID_Continue
            | OIDS                     | Other_ID_Start
            | OLower                   | Other_Lowercase
            | OMath                    | Other_Math
            | OUpper                   | Other_Uppercase
            | Pat_Syn                  | Pattern_Syntax
            | Pat_WS                   | Pattern_White_Space
            | PCM                      | Prepended_Concatenation_Mark
            | QMark                    | Quotation_Mark
            | Radical                  | Radical
            | RI                       | Regional_Indicator
            | SD                       | Soft_Dotted
            | STerm                    | Sentence_Terminal
            | Term                     | Terminal_Punctuation
            | UIdeo                    | Unified_Ideograph
            | Upper                    | Uppercase
            | VS                       | Variation_Selector
            | WSpace                   | White_Space                 | space
            | XIDC                     | XID_Continue
            | XIDS                     | XID_Start
            | XO_NFC                   | Expands_On_NFC
            | XO_NFD                   | Expands_On_NFD
            | XO_NFKC                  | Expands_On_NFKC
            | XO_NFKD                  | Expands_On_NFKD
          )\b
        name: support.type.property-name.unicode.binary.ruko

  unicode-property-values:
    comment: 'WIP: Unicode Standard Annex #44
      https://unicode.org/Public/UCD/latest/ucd/PropertyValueAliases.txt'
    patterns:
      - comment: Unicode Script property values
        match: |-
          (?xi)\b(
              Adlam                            | Adlam
            | Aegean_Numbers                   | Aegean_Numbers
            | Ahom                             | Ahom
            | Alchemical                       | Alchemical_Symbols
            | Alphabetic_PF                    | Alphabetic_Presentation_Forms
            | Anatolian_Hieroglyphs            | Anatolian_Hieroglyphs
            | Ancient_Greek_Music              | Ancient_Greek_Musical_Notation
            | Ancient_Greek_Numbers            | Ancient_Greek_Numbers
            | Ancient_Symbols                  | Ancient_Symbols
            | Arabic                           | Arabic
            | Arabic_Ext_A                     | Arabic_Extended_A
            | Arabic_Ext_B                     | Arabic_Extended_B
            | Arabic_Ext_C                     | Arabic_Extended_C
            | Arabic_Math                      | Arabic_Mathematical_Alphabetic_Symbols
            | Arabic_PF_A                      | Arabic_Presentation_Forms_A | Arabic_Presentation_Forms-A
            | Arabic_PF_B                      | Arabic_Presentation_Forms_B
            | Arabic_Sup                       | Arabic_Supplement
            | Armenian                         | Armenian
            | Arrows                           | Arrows
            | ASCII                            | Basic_Latin
            | Avestan                          | Avestan
            | Balinese                         | Balinese
            | Bamum                            | Bamum
            | Bamum_Sup                        | Bamum_Supplement
            | Bassa_Vah                        | Bassa_Vah
            | Batak                            | Batak
            | Bengali                          | Bengali
            | Beria_Erfe                       | Beria_Erfe
            | Bhaiksuki                        | Bhaiksuki
            | Block_Elements                   | Block_Elements
            | Bopomofo                         | Bopomofo
            | Bopomofo_Ext                     | Bopomofo_Extended
            | Box_Drawing                      | Box_Drawing
            | Brahmi                           | Brahmi
            | Braille                          | Braille_Patterns
            | Buginese                         | Buginese
            | Buhid                            | Buhid
            | Byzantine_Music                  | Byzantine_Musical_Symbols
            | Carian                           | Carian
            | Caucasian_Albanian               | Caucasian_Albanian
            | Chakma                           | Chakma
            | Cham                             | Cham
            | Cherokee                         | Cherokee
            | Cherokee_Sup                     | Cherokee_Supplement
            | Chess_Symbols                    | Chess_Symbols
            | Chorasmian                       | Chorasmian
            | CJK                              | CJK_Unified_Ideographs
            | CJK_Compat                       | CJK_Compatibility
            | CJK_Compat_Forms                 | CJK_Compatibility_Forms
            | CJK_Compat_Ideographs            | CJK_Compatibility_Ideographs
            | CJK_Compat_Ideographs_Sup        | CJK_Compatibility_Ideographs_Supplement
            | CJK_Ext_A                        | CJK_Unified_Ideographs_Extension_A
            | CJK_Ext_B                        | CJK_Unified_Ideographs_Extension_B
            | CJK_Ext_C                        | CJK_Unified_Ideographs_Extension_C
            | CJK_Ext_D                        | CJK_Unified_Ideographs_Extension_D
            | CJK_Ext_E                        | CJK_Unified_Ideographs_Extension_E
            | CJK_Ext_F                        | CJK_Unified_Ideographs_Extension_F
            | CJK_Ext_G                        | CJK_Unified_Ideographs_Extension_G
            | CJK_Ext_H                        | CJK_Unified_Ideographs_Extension_H
            | CJK_Ext_I                        | CJK_Unified_Ideographs_Extension_I
            | CJK_Ext_J                        | CJK_Unified_Ideographs_Extension_J
            | CJK_Radicals_Sup                 | CJK_Radicals_Supplement
            | CJK_Strokes                      | CJK_Strokes
            | CJK_Symbols                      | CJK_Symbols_And_Punctuation
            | Compat_Jamo                      | Hangul_Compatibility_Jamo
            | Control_Pictures                 | Control_Pictures
            | Coptic                           | Coptic
            | Coptic_Epact_Numbers             | Coptic_Epact_Numbers
            | Counting_Rod                     | Counting_Rod_Numerals
            | Cuneiform                        | Cuneiform
            | Cuneiform_Numbers                | Cuneiform_Numbers_And_Punctuation
            | Currency_Symbols                 | Currency_Symbols
            | Cypriot_Syllabary                | Cypriot_Syllabary
            | Cypro_Minoan                     | Cypro_Minoan
            | Cyrillic                         | Cyrillic
            | Cyrillic_Ext_A                   | Cyrillic_Extended_A
            | Cyrillic_Ext_B                   | Cyrillic_Extended_B
            | Cyrillic_Ext_C                   | Cyrillic_Extended_C
            | Cyrillic_Ext_D                   | Cyrillic_Extended_D
            | Cyrillic_Sup                     | Cyrillic_Supplement | Cyrillic_Supplementary
            | Deseret                          | Deseret
            | Devanagari                       | Devanagari
            | Devanagari_Ext                   | Devanagari_Extended
            | Devanagari_Ext_A                 | Devanagari_Extended_A
            | Diacriticals                     | Combining_Diacritical_Marks
            | Diacriticals_Ext                 | Combining_Diacritical_Marks_Extended
            | Diacriticals_For_Symbols         | Combining_Diacritical_Marks_For_Symbols | Combining_Marks_For_Symbols
            | Diacriticals_Sup                 | Combining_Diacritical_Marks_Supplement
            | Dingbats                         | Dingbats
            | Dives_Akuru                      | Dives_Akuru
            | Dogra                            | Dogra
            | Domino                           | Domino_Tiles
            | Duployan                         | Duployan
            | Early_Dynastic_Cuneiform         | Early_Dynastic_Cuneiform
            | Egyptian_Hieroglyph_Format_Controls| Egyptian_Hieroglyph_Format_Controls
            | Egyptian_Hieroglyphs             | Egyptian_Hieroglyphs
            | Egyptian_Hieroglyphs_Ext_A       | Egyptian_Hieroglyphs_Extended_A
            | Elbasan                          | Elbasan
            | Elymaic                          | Elymaic
            | Emoticons                        | Emoticons
            | Enclosed_Alphanum                | Enclosed_Alphanumerics
            | Enclosed_Alphanum_Sup            | Enclosed_Alphanumeric_Supplement
            | Enclosed_CJK                     | Enclosed_CJK_Letters_And_Months
            | Enclosed_Ideographic_Sup         | Enclosed_Ideographic_Supplement
            | Ethiopic                         | Ethiopic
            | Ethiopic_Ext                     | Ethiopic_Extended
            | Ethiopic_Ext_A                   | Ethiopic_Extended_A
            | Ethiopic_Ext_B                   | Ethiopic_Extended_B
            | Ethiopic_Sup                     | Ethiopic_Supplement
            | Garay                            | Garay
            | Geometric_Shapes                 | Geometric_Shapes
            | Geometric_Shapes_Ext             | Geometric_Shapes_Extended
            | Georgian                         | Georgian
            | Georgian_Ext                     | Georgian_Extended
            | Georgian_Sup                     | Georgian_Supplement
            | Glagolitic                       | Glagolitic
            | Glagolitic_Sup                   | Glagolitic_Supplement
            | Gothic                           | Gothic
            | Grantha                          | Grantha
            | Greek                            | Greek_And_Coptic
            | Greek_Ext                        | Greek_Extended
            | Gujarati                         | Gujarati
            | Gunjala_Gondi                    | Gunjala_Gondi
            | Gurmukhi                         | Gurmukhi
            | Gurung_Khema                     | Gurung_Khema
            | Half_And_Full_Forms              | Halfwidth_And_Fullwidth_Forms
            | Half_Marks                       | Combining_Half_Marks
            | Hangul                           | Hangul_Syllables
            | Hanifi_Rohingya                  | Hanifi_Rohingya
            | Hanunoo                          | Hanunoo
            | Hatran                           | Hatran
            | Hebrew                           | Hebrew
            | High_PU_Surrogates               | High_Private_Use_Surrogates
            | High_Surrogates                  | High_Surrogates
            | Hiragana                         | Hiragana
            | IDC                              | Ideographic_Description_Characters
            | Ideographic_Symbols              | Ideographic_Symbols_And_Punctuation
            | Imperial_Aramaic                 | Imperial_Aramaic
            | Indic_Number_Forms               | Common_Indic_Number_Forms
            | Indic_Siyaq_Numbers              | Indic_Siyaq_Numbers
            | Inscriptional_Pahlavi            | Inscriptional_Pahlavi
            | Inscriptional_Parthian           | Inscriptional_Parthian
            | IPA_Ext                          | IPA_Extensions
            | Jamo                             | Hangul_Jamo
            | Jamo_Ext_A                       | Hangul_Jamo_Extended_A
            | Jamo_Ext_B                       | Hangul_Jamo_Extended_B
            | Javanese                         | Javanese
            | Kaithi                           | Kaithi
            | Kaktovik_Numerals                | Kaktovik_Numerals
            | Kana_Ext_A                       | Kana_Extended_A
            | Kana_Ext_B                       | Kana_Extended_B
            | Kana_Sup                         | Kana_Supplement
            | Kanbun                           | Kanbun
            | Kangxi                           | Kangxi_Radicals
            | Kannada                          | Kannada
            | Katakana                         | Katakana
            | Katakana_Ext                     | Katakana_Phonetic_Extensions
            | Kawi                             | Kawi
            | Kayah_Li                         | Kayah_Li
            | Kharoshthi                       | Kharoshthi
            | Khitan_Small_Script              | Khitan_Small_Script
            | Khmer                            | Khmer
            | Khmer_Symbols                    | Khmer_Symbols
            | Khojki                           | Khojki
            | Khudawadi                        | Khudawadi
            | Kirat_Rai                        | Kirat_Rai
            | Lao                              | Lao
            | Latin_1_Sup                      | Latin_1_Supplement | Latin_1
            | Latin_Ext_A                      | Latin_Extended_A
            | Latin_Ext_Additional             | Latin_Extended_Additional
            | Latin_Ext_B                      | Latin_Extended_B
            | Latin_Ext_C                      | Latin_Extended_C
            | Latin_Ext_D                      | Latin_Extended_D
            | Latin_Ext_E                      | Latin_Extended_E
            | Latin_Ext_F                      | Latin_Extended_F
            | Latin_Ext_G                      | Latin_Extended_G
            | Lepcha                           | Lepcha
            | Letterlike_Symbols               | Letterlike_Symbols
            | Limbu                            | Limbu
            | Linear_A                         | Linear_A
            | Linear_B_Ideograms               | Linear_B_Ideograms
            | Linear_B_Syllabary               | Linear_B_Syllabary
            | Lisu                             | Lisu
            | Lisu_Sup                         | Lisu_Supplement
            | Low_Surrogates                   | Low_Surrogates
            | Lycian                           | Lycian
            | Lydian                           | Lydian
            | Mahajani                         | Mahajani
            | Mahjong                          | Mahjong_Tiles
            | Makasar                          | Makasar
            | Malayalam                        | Malayalam
            | Mandaic                          | Mandaic
            | Manichaean                       | Manichaean
            | Marchen                          | Marchen
            | Masaram_Gondi                    | Masaram_Gondi
            | Math_Alphanum                    | Mathematical_Alphanumeric_Symbols
            | Math_Operators                   | Mathematical_Operators
            | Mayan_Numerals                   | Mayan_Numerals
            | Medefaidrin                      | Medefaidrin
            | Meetei_Mayek                     | Meetei_Mayek
            | Meetei_Mayek_Ext                 | Meetei_Mayek_Extensions
            | Mende_Kikakui                    | Mende_Kikakui
            | Meroitic_Cursive                 | Meroitic_Cursive
            | Meroitic_Hieroglyphs             | Meroitic_Hieroglyphs
            | Miao                             | Miao
            | Misc_Arrows                      | Miscellaneous_Symbols_And_Arrows
            | Misc_Math_Symbols_A              | Miscellaneous_Mathematical_Symbols_A
            | Misc_Math_Symbols_B              | Miscellaneous_Mathematical_Symbols_B
            | Misc_Pictographs                 | Miscellaneous_Symbols_And_Pictographs
            | Misc_Symbols                     | Miscellaneous_Symbols
            | Misc_Symbols_Sup                 | Miscellaneous_Symbols_Supplement
            | Misc_Technical                   | Miscellaneous_Technical
            | Modi                             | Modi
            | Modifier_Letters                 | Spacing_Modifier_Letters
            | Modifier_Tone_Letters            | Modifier_Tone_Letters
            | Mongolian                        | Mongolian
            | Mongolian_Sup                    | Mongolian_Supplement
            | Mro                              | Mro
            | Multani                          | Multani
            | Music                            | Musical_Symbols
            | Myanmar                          | Myanmar
            | Myanmar_Ext_A                    | Myanmar_Extended_A
            | Myanmar_Ext_B                    | Myanmar_Extended_B
            | Myanmar_Ext_C                    | Myanmar_Extended_C
            | Nabataean                        | Nabataean
            | Nag_Mundari                      | Nag_Mundari
            | Nandinagari                      | Nandinagari
            | NB                               | No_Block
            | New_Tai_Lue                      | New_Tai_Lue
            | Newa                             | Newa
            | NKo                              | NKo
            | Number_Forms                     | Number_Forms
            | Nushu                            | Nushu
            | Nyiakeng_Puachue_Hmong           | Nyiakeng_Puachue_Hmong
            | OCR                              | Optical_Character_Recognition
            | Ogham                            | Ogham
            | Ol_Chiki                         | Ol_Chiki
            | Ol_Onal                          | Ol_Onal
            | Old_Hungarian                    | Old_Hungarian
            | Old_Italic                       | Old_Italic
            | Old_North_Arabian                | Old_North_Arabian
            | Old_Permic                       | Old_Permic
            | Old_Persian                      | Old_Persian
            | Old_Sogdian                      | Old_Sogdian
            | Old_South_Arabian                | Old_South_Arabian
            | Old_Turkic                       | Old_Turkic
            | Old_Uyghur                       | Old_Uyghur
            | Oriya                            | Oriya
            | Ornamental_Dingbats              | Ornamental_Dingbats
            | Osage                            | Osage
            | Osmanya                          | Osmanya
            | Ottoman_Siyaq_Numbers            | Ottoman_Siyaq_Numbers
            | Pahawh_Hmong                     | Pahawh_Hmong
            | Palmyrene                        | Palmyrene
            | Pau_Cin_Hau                      | Pau_Cin_Hau
            | Phags_Pa                         | Phags_Pa
            | Phaistos                         | Phaistos_Disc
            | Phoenician                       | Phoenician
            | Phonetic_Ext                     | Phonetic_Extensions
            | Phonetic_Ext_Sup                 | Phonetic_Extensions_Supplement
            | Playing_Cards                    | Playing_Cards
            | Psalter_Pahlavi                  | Psalter_Pahlavi
            | PUA                              | Private_Use_Area | Private_Use
            | Punctuation                      | General_Punctuation
            | Rejang                           | Rejang
            | Rumi                             | Rumi_Numeral_Symbols
            | Runic                            | Runic
            | Samaritan                        | Samaritan
            | Saurashtra                       | Saurashtra
            | Sharada                          | Sharada
            | Sharada_Sup                      | Sharada_Supplement
            | Shavian                          | Shavian
            | Shorthand_Format_Controls        | Shorthand_Format_Controls
            | Siddham                          | Siddham
            | Sidetic                          | Sidetic
            | Sinhala                          | Sinhala
            | Sinhala_Archaic_Numbers          | Sinhala_Archaic_Numbers
            | Small_Forms                      | Small_Form_Variants
            | Small_Kana_Ext                   | Small_Kana_Extension
            | Sogdian                          | Sogdian
            | Sora_Sompeng                     | Sora_Sompeng
            | Soyombo                          | Soyombo
            | Specials                         | Specials
            | Sundanese                        | Sundanese
            | Sundanese_Sup                    | Sundanese_Supplement
            | Sunuwar                          | Sunuwar
            | Sup_Arrows_A                     | Supplemental_Arrows_A
            | Sup_Arrows_B                     | Supplemental_Arrows_B
            | Sup_Arrows_C                     | Supplemental_Arrows_C
            | Sup_Math_Operators               | Supplemental_Mathematical_Operators
            | Sup_PUA_A                        | Supplementary_Private_Use_Area_A
            | Sup_PUA_B                        | Supplementary_Private_Use_Area_B
            | Sup_Punctuation                  | Supplemental_Punctuation
            | Sup_Symbols_And_Pictographs      | Supplemental_Symbols_And_Pictographs
            | Super_And_Sub                    | Superscripts_And_Subscripts
            | Sutton_SignWriting               | Sutton_SignWriting
            | Syloti_Nagri                     | Syloti_Nagri
            | Symbols_And_Pictographs_Ext_A    | Symbols_And_Pictographs_Extended_A
            | Symbols_For_Legacy_Computing     | Symbols_For_Legacy_Computing
            | Symbols_For_Legacy_Computing_Sup | Symbols_For_Legacy_Computing_Supplement
            | Syriac                           | Syriac
            | Syriac_Sup                       | Syriac_Supplement
            | Tagalog                          | Tagalog
            | Tagbanwa                         | Tagbanwa
            | Tags                             | Tags
            | Tai_Le                           | Tai_Le
            | Tai_Tham                         | Tai_Tham
            | Tai_Viet                         | Tai_Viet
            | Tai_Xuan_Jing                    | Tai_Xuan_Jing_Symbols
            | Tai_Yo                           | Tai_Yo
            | Takri                            | Takri
            | Tamil                            | Tamil
            | Tamil_Sup                        | Tamil_Supplement
            | Tangsa                           | Tangsa
            | Tangut                           | Tangut
            | Tangut_Components                | Tangut_Components
            | Tangut_Components_Sup            | Tangut_Components_Supplement
            | Tangut_Sup                       | Tangut_Supplement
            | Telugu                           | Telugu
            | Thaana                           | Thaana
            | Thai                             | Thai
            | Tibetan                          | Tibetan
            | Tifinagh                         | Tifinagh
            | Tirhuta                          | Tirhuta
            | Todhri                           | Todhri
            | Tolong_Siki                      | Tolong_Siki
            | Toto                             | Toto
            | Transport_And_Map                | Transport_And_Map_Symbols
            | Tulu_Tigalari                    | Tulu_Tigalari
            | UCAS                             | Unified_Canadian_Aboriginal_Syllabics | Canadian_Syllabics
            | UCAS_Ext                         | Unified_Canadian_Aboriginal_Syllabics_Extended
            | UCAS_Ext_A                       | Unified_Canadian_Aboriginal_Syllabics_Extended_A
            | Ugaritic                         | Ugaritic
            | Vai                              | Vai
            | Vedic_Ext                        | Vedic_Extensions
            | Vertical_Forms                   | Vertical_Forms
            | Vithkuqi                         | Vithkuqi
            | VS                               | Variation_Selectors
            | VS_Sup                           | Variation_Selectors_Supplement
            | Wancho                           | Wancho
            | Warang_Citi                      | Warang_Citi
            | Yezidi                           | Yezidi
            | Yi_Radicals                      | Yi_Radicals
            | Yi_Syllables                     | Yi_Syllables
            | Yijing                           | Yijing_Hexagram_Symbols
            | Zanabazar_Square                 | Zanabazar_Square
            | Znamenny_Music                   | Znamenny_Musical_Notation
          )\b
        name: support.constant.property-value.unicode.block.ruko

  attribute-selectors:
    name: meta.attribute-selector.ruko
    patterns:
      - include: '#comments'
      - include: '#numbers'
      - comment: Unicode character category selectors
        match: \b(L[ultmo]?|M[nce]?|N[dlo]?|P[cdseifo]?|S[mcko]?|Z[pls]?|C[cfnos]?)\b
        name: support.type.character-class.unicode.ruko
      - applyEndPatternLast: true
        begin: |-
          (?x)
          ([\p{Pc}\p{L}]\w*) # property name
          \s*(?: # operators
              (=|[!=]==?) # equality
            | (~[=!]) # matches
            | ([<>]=?) # relational
            | ([$^%*]=) # pattern
          )\s*
        end: (?=)|$
        captures:
          1:
            name: entity.other.attribute-name.key.ruko
            patterns: [include: '#unicode-property-keys']
          2: { name: keyword.operator.comparison.ruko }
          3: { name: keyword.operator.match.ruko }
          4: { name: keyword.operator.relation.ruko }
          5: { name: keyword.operator.pattern.ruko }
        name: string.unquoted.attribute-name.ruko
        patterns:
          - include: '#comments'
          - include: '#strings'
          - comment: Regular expression patterns
            begin: (/)(?![/*])
            end: (/)(\p{L}*)
            name: string.regexp.attribute-value.ruko
            captures:
              1: { name: punctuation.definition.regexp.begin.ruko }
              2: { name: punctuation.definition.regexp.end.ruko }
              3: { name: keyword.other.flag.ruko }
          - include: '#constants'
          - include: '#numbers'
          - include: '#unicode-property-values'
          - include: '#css-property-values'
          - &attribute-identifier
            match: \b[\p{Pd}\w]+\b
            name: constant.other.attribute-value.identifier.ruko
      - match: \b([\p{Pc}\p{L}]\w*)\b
        name: entity.other.attribute-name.key.ruko
      - match: '&&|\|\||\^\^|!'
        name: keyword.operator.logical.ruko
      - match: \b(n?and|x?n?or|c?n?imply|not)\b
        name: keyword.operator.expression.logical.ruko
      - match: ','
        name: punctuation.separator.sequence.ruko
      - match: \b(\b(is|has)\b\s*\b(not)?)\b
        name: keyword.operator.expression.is.ruko
      - match: \b(not)?\s*\b([io]n|of)\b
        name: keyword.operator.expression.$2.ruko
      - match: \b([\p{Pc}\p{L}]\w*)\b(?=&&|\|\||\^\^|!|[\s,:;'"`)}\]]|\\.)
        name: storage.modifier.ignore-when.ruko
      - include: '#string-escapes'
      - comment: Attribute names
        match: \b([\p{Pc}\p{L}]\w*)\b
        captures:
          1: { name: entity.other.attribute-name.ruko }
          2: { name: keyword.operator.pattern.ruko }
      - include: '#space'

  # Splicing

  splice-brackets:
    patterns:
      - begin: \s*(<{)
        end: (}>)
        name: meta.splicing.ruko
        captures:
          1: { name: punctuation.definition.splice.ruko }
          2: { name: punctuation.definition.splice.ruko }
        patterns: [include: $self]
      - begin: \s*(<\[)
        end: (\]>)
        name: meta.splicing.ruko
        captures:
          1: { name: punctuation.definition.splice.ruko }
          2: { name: punctuation.definition.splice.ruko }
        patterns: [include: $self]

  # XML (JSX) and Markdown

  xml:
    applyEndPatternLast: true
    comment: Only captured when next to opening brackets, commas,
      semicolons, keywords, and operators.
      XML also supports functional components.
    begin: |-
      (?x)(?<=
        (?:
            ^ # beginning of line
          | [,;] # separator
          | \#? [({\[] # opening bracket
          | [\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]+ \s # postfix or infix operator
          | (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            [\p{Pc}\p{L}]\w*  # keyword or identifier
        ) \s*
      ) \s*
      (?=<[\p{Pc}\p{L}($])
    end: (?=)|$
    patterns: [include: '#tag-component-name']

  tag-component-name:
    patterns:
      - comment: Expression tags like <( ... )>.
        contentName: text.html.ruko
        begin: (<)(?=\()
        end: |
          (?x) \s*
          (?:
              (/>) # Tags implicitly closed.
            | ((?<=</).*?)(>)
          ) \s*
        beginCaptures:
          1: { name: punctuation.definition.tag.ruko }
        endCaptures:
          1: { name: punctuation.definition.tag.ruko }
          2: { name: invalid.illegal.termination.ruko }
          3: { name: punctuation.definition.tag.ruko }
        patterns:
          - begin: (?<=<\()\s*
            end: \s*(\))
            name: meta.expression.tag.ruko
            captures:
              1: { name: punctuation.definition.expression.ruko }
            patterns: [include: $self]
          - include: '#tag-attributes'
          - include: '#tag-termination'
          - match: (?<=</)(>)
            name: punctuation.definition.tag.ruko
      - comment: Tags that end > are trapped in tag-termination.
          <$></> is a fragment tag.
        contentName: text.html.ruko
        begin: |-
          (?x)
          (<\$?) # start tag begin
          (
            (?:
              \b[\p{Pc}\p{L}]\w*\b # identifier
              (?:[?!:]:|[?!]?\.|[?!-]>) # qualified name separator
            )*
            [\p{Pc}\p{L}]\w* # last part of identifier
            \b
          )?
          (?=[,;'"`({\[)}\]/>\s])
        end: |
          (?x) \s*
          (?:
              (?<=</)(\2)?(>) # end tag
            | (/>) # self-closing tag
            | ((?<=</).*?)(>)
          ) \s*
        beginCaptures:
          1: { name: punctuation.definition.tag.ruko }
          2:
            name: entity.name.tag.ruko
            patterns: [include: '#html-tags']
        endCaptures:
          0: { name: meta.tag.ruko }
          1:
            name: entity.name.tag.ruko
            patterns: [include: '#html-tags']
          2: { name: punctuation.definition.tag.ruko }
          3: { name: punctuation.definition.tag.ruko }
          4: { name: invalid.illegal.termination.ruko }
          5: { name: punctuation.definition.tag.ruko }
        patterns:
          - include: '#tag-attributes'
          - include: '#tag-termination'
          - match: (?<=</)(>)
            name: punctuation.definition.tag.ruko

  xml-comments:
    begin: (<!--)
    end: (-->)
    captures:
      1: { name: punctuation.definition.comment.ruko }
    name: comment.block.html.ruko
    patterns: [include: '#xml-comments']

  tag-termination:
    comment: uses non consuming search for </ in </tag>
    contentName: meta.xml.children.ruko
    begin: (>)
    end: (</(?=\b|>))
    captures:
      1: { name: punctuation.definition.tag.ruko }
    patterns:
      - include: '#evaluated-code'
      - include: '#xml-entities'
      - include: '#tag-component-name'
      - include: '#markdown'
      - include: '#xml-comments'

  tag-attributes:
    patterns:
      - match: \s*([@#&*|%.:~^?]|::)(?=[\w$'"`])
        name: punctuation.definition.entity.ruko
      - include: '#spread-attribute'
      - include: '#style-attribute'
      - include: '#attribute-assignment'
      - include: '#style-selectors'
      - include: '#literals'
      - include: '#hex-colors'
      - include: '#embedded-expressions'
      - include: '#embedded-formatting'
      - include: '#embedded-arguments'
      - include: '#function-calls'
      - include: '#variables'
      - include: '#brackets'
      - include: '#comments'
      - include: '#punctuation'
      - include: '#space'

  style-attribute:
    begin: \s*(style)\s*(=)\s*({)\s*
    beginCaptures:
      1: { name: storage.type.style.ruko }
      2: { name: punctuation.separator.key-value.ruko }
      3: { name: punctuation.definition.block.ruko }
    end: \s*(})\s*
    endCaptures:
      1: { name: punctuation.definition.block.ruko }
    name: meta.attribute.style.ruko
    patterns: [include: '#style-properties']

  attribute-assignment:
    applyEndPatternLast: true
    begin: \s*(=)
    beginCaptures:
      1: { name: punctuation.separator.key-value.ruko }
    end: (?=)|$
    name: meta.attribute.assignment.ruko
    patterns: [include: '#attribute-values']

  attribute-values:
    patterns:
      - include: '#brackets'
      - include: '#embedded-expressions'
      - include: '#literals'
      - include: '#css-property-values'
      - include: '#hex-colors'
      - include: '#unicode-property-values'
      - *attribute-identifier

  attribute-names:
    match: \s*([\p{Pc}\p{L}][\p{Pd}\w]*)\b(?!\s*=)\s*
    name: meta.attribute.boolean.ruko
    captures:
      1: &attribute-name
        name: entity.other.attribute-name.ruko
        patterns:
          - match: \s*(?<=\@)[\p{Pc}\p{L}]\w*\b\s*
            name: keyword.control.at-rule.ruko
          - match: \s*(?<=\#)[\p{Pc}\p{L}]\w*\b\s*
            name: entity.other.attribute-name.id.ruko
          - match: \s*(?<=\.)[\p{Pc}\p{L}]\w*\b\s*
            name: entity.other.attribute-name.class.ruko
          - match: \s*(?<=::)[\p{Pc}\p{L}]\w*\b\s*
            name: entity.other.attribute-name.pseudo-component.ruko
          - match: \s*(?<=\~)[\p{Pc}\p{L}]\w*\b\s*
            name: entity.other.attribute-name.key.ruko
          - match: \s*(?<=\&)[\p{Pc}\p{L}]\w*\b\s*
            name: entity.other.attribute-name.ruko entity.name.type.anchor.ruko
          - match: \s*(?<=\*)[\p{Pc}\p{L}]\w*\b\s*
            name: entity.other.attribute-name.ruko entity.name.type.alias.ruko
          - match: \s*(?<=\%)[\p{Pc}\p{L}]\w*\b\s*
            name: entity.other.attribute-name.ruko entity.name.function.ruko
          - match: \s*(?<=\|)[\p{Pc}\p{L}]\w*\b\s*
            name: entity.other.attribute-name.ruko entity.name.method.ruko
          - match: \s*(?<=\:)[\p{Pc}\p{L}]\w*\b\s*
            name: entity.other.attribute-name.ruko entity.name.procedure.ruko
          - match: \s*(?<=\^)[\p{Pc}\p{L}]\w*\b\s*
            name: entity.other.attribute-name.ruko entity.name.property.ruko
          - match: \s*(?<=\?)[\p{Pc}\p{L}]\w*\b\s*
            name: entity.other.attribute-name.ruko entity.name.predicate.ruko
          - include: '#css-property-keys'

  spread-attribute:
    comment: Spread ...attribute
    match: \s*(?<!\.)(\.{3})(?=[\p{Pc}\p{L}($])
    captures:
      1: { name: punctuation.definition.spread.ruko }

  xml-entities:
    patterns:
      - match: |-
          (?xi)
          (&)(?:
              (\#\\0*(?:111411[10]|111410\d|11140\d{2}|111[0-3]\d{3}|110\d{4}|10\d{5}|[1-9]\d{0,5}|0)) # decimal
            | (\#b0*(?:10000[10]{16}|1[01]{0,19}|0)) # binary
            | (\#q0*(?:1003{8}|100[0-2]{10}|10[0-3]{12}|[1-3][0-3]{0,18}|0)) # quaternary
            | (\#o0*(?:41[0-7]{5}|[1-3][0-7]{6}|[1-7][0-7]{0,5}|0)) # octal
            | (\#x0*(?:10\h{6}|\h{1,5})) # hexadecimal
            | ([\p{Pc}\p{L}]\w*) # named
            | ((?:\\.|[^({\[)}\]\s;])+?) # numeric or invalid
          )(;)
        name: constant.other.entity.ruko
        captures: &xml-entities
          1: { name: punctuation.definition.entity.ruko }
          2: { name: constant.character.escape.decimal.ruko }
          3: { name: constant.character.escape.binary.ruko }
          4: { name: constant.character.escape.quaternary.ruko }
          6: { name: constant.character.escape.octal.ruko }
          7: { name: constant.character.escape.hexadecimal.ruko }
          8: { name: constant.character.entity.named.ruko }
          9: { name: invalid.illegal.entity.ruko }
          10: { name: punctuation.definition.entity.ruko }
      - match: '&(?=\w*;)'
        name: invalid.illegal.ambiguous-ampersand.ruko
      - comment: Entity with & and invalid name
        match: '&\s*+;'
        name: invalid.illegal.bad-ampersand.ruko

  inline-markdown:
    patterns:
      - include: '#ampersand'
      - include: '#bracket'
      - include: '#bold'
      - include: '#italic'
      - include: '#underline'
      - include: '#strikethrough'
      - include: '#superscript'
      - include: '#subscript'
      - include: '#redacted'
      - include: '#highlight'
      - include: '#escapes-embedded'
      - include: '#raw'
      - include: '#escape'
      - include: '#image-inline'
      - include: '#image-ref'
      - include: '#link-email'
      - include: '#link-inet'
      - include: '#link-inline'
      - include: '#link-ref'
      - include: '#link-ref-literal'
      - include: '#link-ref-shortcut'

  ampersand:
    comment: Markdown will convert this for us. We match it so that the HTML grammar will not mark it up as invalid.
    match: '&(?!([a-zA-Z\d]+|#[\d]+|#x\h+);)'
    name: meta.other.valid-ampersand.markdown

  bold:
    begin: (\*\*|\b__)(?=\S)
    captures:
      1: { name: punctuation.definition.bold.markdown }
    end: (?<=\S)(\1)
    name: markup.bold.markdown
    patterns:
      - include: '#ampersand'
      - include: '#bracket'
      - include: '#italic'
      - include: '#underline'
      - include: '#strikethrough'
      - include: '#superscript'
      - include: '#subscript'
      - include: '#redacted'
      - include: '#highlight'
      - include: '#escapes-embedded'
      - include: '#raw'
      - include: '#escape'
      - include: '#image-inline'
      - include: '#image-ref'
      - include: '#link-email'
      - include: '#link-inet'
      - include: '#link-inline'
      - include: '#link-ref'
      - include: '#link-ref-literal'
      - include: '#link-ref-shortcut'

  italic:
    begin: (\*|\b_)(?=\S)
    captures:
      1: { name: punctuation.definition.italic.markdown }
    end: (?<=\S)(\1)((?!\1)|(?=\1\1))
    name: markup.italic.markdown
    patterns:
      - include: '#ampersand'
      - include: '#bracket'
      - include: '#bold'
      - include: '#underline'
      - include: '#strikethrough'
      - include: '#superscript'
      - include: '#subscript'
      - include: '#redacted'
      - include: '#highlight'
      - include: '#escapes-embedded'
      - include: '#raw'
      - include: '#escape'
      - include: '#image-inline'
      - include: '#image-ref'
      - include: '#link-email'
      - include: '#link-inet'
      - include: '#link-inline'
      - include: '#link-ref'
      - include: '#link-ref-literal'
      - include: '#link-ref-shortcut'

  strikethrough:
    begin: (~~)(?=\S)
    captures:
      1: { name: punctuation.definition.strikethrough.markdown }
    end: (?<=\S)(~~)
    name: markup.strikethrough.markdown
    patterns:
      - include: '#ampersand'
      - include: '#bracket'
      - include: '#bold'
      - include: '#italic'
      - include: '#underline'
      - include: '#superscript'
      - include: '#subscript'
      - include: '#redacted'
      - include: '#highlight'
      - include: '#escapes-embedded'
      - include: '#raw'
      - include: '#escape'
      - include: '#image-inline'
      - include: '#image-ref'
      - include: '#link-email'
      - include: '#link-inet'
      - include: '#link-inline'
      - include: '#link-ref'
      - include: '#link-ref-literal'
      - include: '#link-ref-shortcut'

  underline:
    begin: (\+\+)(?=\S)
    captures:
      1: { name: punctuation.definition.underline.markdown }
    end: (?<=\S)(\+\+)
    name: markup.underline.markdown
    patterns:
      - include: '#ampersand'
      - include: '#bracket'
      - include: '#bold'
      - include: '#italic'
      - include: '#strikethrough'
      - include: '#superscript'
      - include: '#subscript'
      - include: '#redacted'
      - include: '#highlight'
      - include: '#escapes-embedded'
      - include: '#raw'
      - include: '#escape'
      - include: '#image-inline'
      - include: '#image-ref'
      - include: '#link-email'
      - include: '#link-inet'
      - include: '#link-inline'
      - include: '#link-ref'
      - include: '#link-ref-literal'
      - include: '#link-ref-shortcut'

  redacted:
    begin: (\|\|)(?=\S)
    captures:
      1: { name: punctuation.definition.redacted.markdown }
    end: (?<=\S)(\|\|)
    name: markup.redacted.markdown
    patterns:
      - include: '#ampersand'
      - include: '#bracket'
      - include: '#bold'
      - include: '#italic'
      - include: '#underline'
      - include: '#strikethrough'
      - include: '#superscript'
      - include: '#subscript'
      - include: '#highlight'
      - include: '#escapes-embedded'
      - include: '#raw'
      - include: '#escape'
      - include: '#image-inline'
      - include: '#image-ref'
      - include: '#link-email'
      - include: '#link-inet'
      - include: '#link-inline'
      - include: '#link-ref'
      - include: '#link-ref-literal'
      - include: '#link-ref-shortcut'

  highlight:
    begin: (==)(?=\S)
    captures:
      1: { name: punctuation.definition.highlight.markdown }
    end: (?<=\S)(==)
    name: markup.highlight.markdown
    patterns:
      - include: '#ampersand'
      - include: '#bracket'
      - include: '#bold'
      - include: '#italic'
      - include: '#underline'
      - include: '#strikethrough'
      - include: '#superscript'
      - include: '#subscript'
      - include: '#redacted'
      - include: '#escapes-embedded'
      - include: '#raw'
      - include: '#escape'
      - include: '#image-inline'
      - include: '#image-ref'
      - include: '#link-email'
      - include: '#link-inet'
      - include: '#link-inline'
      - include: '#link-ref'
      - include: '#link-ref-literal'
      - include: '#link-ref-shortcut'

  superscript:
    begin: (\^)(?=\S)
    captures:
      1: { name: punctuation.definition.superscript.markdown }
    end: (?<=\S)(\^)
    name: markup.superscript.markdown
    patterns:
      - include: '#ampersand'
      - include: '#bracket'
      - include: '#bold'
      - include: '#italic'
      - include: '#underline'
      - include: '#strikethrough'
      - include: '#subscript'
      - include: '#redacted'
      - include: '#highlight'
      - include: '#escapes-embedded'
      - include: '#raw'
      - include: '#escape'
      - include: '#image-inline'
      - include: '#image-ref'
      - include: '#link-email'
      - include: '#link-inet'
      - include: '#link-inline'
      - include: '#link-ref'
      - include: '#link-ref-literal'
      - include: '#link-ref-shortcut'

  subscript:
    begin: (~)(?=\S)
    captures:
      1: { name: punctuation.definition.subscript.markdown }
    end: (?<=\S)(~)
    name: markup.subscript.markdown
    patterns:
      - include: '#ampersand'
      - include: '#bracket'
      - include: '#bold'
      - include: '#italic'
      - include: '#underline'
      - include: '#strikethrough'
      - include: '#superscript'
      - include: '#redacted'
      - include: '#highlight'
      - include: '#escapes-embedded'
      - include: '#raw'
      - include: '#escape'
      - include: '#image-inline'
      - include: '#image-ref'
      - include: '#link-email'
      - include: '#link-inet'
      - include: '#link-inline'
      - include: '#link-ref'
      - include: '#link-ref-literal'
      - include: '#link-ref-shortcut'

  bracket:
    comment: Markdown will convert this for us. We match it so that the HTML grammar will not mark it up as invalid.
    match: <(?![a-zA-Z/?\$!])
    name: meta.other.valid-bracket.markdown

  escape:
    comment: Escape characters in Markdown
    match: \\[-`*_#+.!({\[)}\]\\>~|=]
    name: constant.character.escape.markdown

  image-inline:
    comment: Inline image ![alt text](url "optional title")
    match: |-
      (?x)
      (\!\[)((?<square>[^\[\]\\]|\\.|\[\g<square>*+\])*+)(\])
      # Match the link text.
      (\() # Opening paren for url
        (<?)(\S+?)(>?) # The url
        [ \t]* # Optional whitespace
        (?:
            ((\().+?(\))) # Match title in parens...
          | ((").+?(")) # or in double quotes...
          | ((').+?(')) # or in single quotes.
        )? # Title is optional
        \s* # Optional whitespace
      (\))
    name: meta.image.inline.markdown
    captures:
      1: { name: punctuation.definition.string.begin.markdown }
      2: { name: string.other.link.description.markdown }
      4: { name: punctuation.definition.string.end.markdown }
      5: { name: punctuation.definition.metadata.markdown }
      6: { name: punctuation.definition.link.markdown }
      7: { name: markup.underline.link.image.markdown }
      8: { name: punctuation.definition.link.markdown }
      9: { name: string.other.link.description.title.markdown }
      10: { name: punctuation.definition.string.markdown }
      11: { name: punctuation.definition.string.markdown }
      12: { name: string.other.link.description.title.markdown }
      13: { name: punctuation.definition.string.markdown }
      14: { name: punctuation.definition.string.markdown }
      15: { name: string.other.link.description.title.markdown }
      16: { name: punctuation.definition.string.markdown }
      17: { name: punctuation.definition.string.markdown }
      18: { name: punctuation.definition.metadata.markdown }

  image-ref:
    captures:
      1: { name: punctuation.definition.string.begin.markdown }
      2: { name: string.other.link.description.markdown }
      4: { name: punctuation.definition.string.begin.markdown }
      5: { name: punctuation.definition.constant.markdown }
      6: { name: constant.other.reference.link.markdown }
      7: { name: punctuation.definition.constant.markdown }
    match: (\!\[)((?<square>[^\[\]\\]|\\.|\[\g<square>*+\])*+)(\])[ ]?(\[)(.*?)(\])
    name: meta.image.reference.markdown
    patterns: [include: '#escapes-embedded']

  link-email:
    captures:
      1: { name: punctuation.definition.link.markdown }
      2: { name: markup.underline.link.markdown }
      4: { name: punctuation.definition.link.markdown }
    match: (<)((?:mailto:)?[a-zA-Z\d.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z\d-]+(?:\.[a-zA-Z\d-]+)*)(>)
    name: meta.link.email.lt-gt.markdown
    patterns: [include: '#escapes-embedded']

  link-inet:
    captures:
      1: { name: punctuation.definition.link.markdown }
      2: { name: markup.underline.link.markdown }
      3: { name: punctuation.definition.link.markdown }
    match: (<)((?:https?|ftp)://.*?)(>)
    name: meta.link.inet.markdown
    patterns: [include: '#escapes-embedded']

  link-inline:
    captures:
      1: { name: punctuation.definition.string.begin.markdown }
      2: { name: string.other.link.title.markdown }
      4: { name: punctuation.definition.string.end.markdown }
      5: { name: punctuation.definition.metadata.markdown }
      6: { name: punctuation.definition.link.markdown }
      7: { name: markup.underline.link.markdown }
      9: { name: punctuation.definition.link.markdown }
      10: { name: string.other.link.description.title.markdown }
      11: { name: punctuation.definition.string.begin.markdown }
      12: { name: punctuation.definition.string.end.markdown }
      13: { name: string.other.link.description.title.markdown }
      14: { name: punctuation.definition.string.begin.markdown }
      15: { name: punctuation.definition.string.end.markdown }
      16: { name: string.other.link.description.title.markdown }
      17: { name: punctuation.definition.string.begin.markdown }
      18: { name: punctuation.definition.string.end.markdown }
      19: { name: punctuation.definition.metadata.markdown }
    match: |-
      (?x)
      (\[)((?<square>[^\[\]\\]|\\.|\[\g<square>*+\])*+)(\])
      # Match the link text.
      (\() # Opening paren for url
        (<?)((?<url>(?>[^\s()]+)|\(\g<url>*\))*)(>?) # The url
        [ \t]* # Optional whitespace
        (?:
            ((\().+?(\))) # Match title in parens...
          | ((").+?(")) # or in double quotes...
          | ((').+?(')) # or in single quotes.
        )? # Title is optional
        \s* # Optional whitespace
      (\))
    name: meta.link.inline.markdown
    patterns: [include: '#escapes-embedded']

  link-ref:
    captures:
      1: { name: punctuation.definition.string.begin.markdown }
      2: { name: string.other.link.title.markdown }
      4: { name: punctuation.definition.string.end.markdown }
      5: { name: punctuation.definition.constant.begin.markdown }
      6: { name: constant.other.reference.link.markdown }
      7: { name: punctuation.definition.constant.end.markdown }
    match: (\[)((?<square>[^\[\]\\]|\\.|\[\g<square>*+\])*+)(\])(\[)([^\]]*+)(\])
    name: meta.link.reference.markdown
    patterns: [include: '#escapes-embedded']

  link-ref-literal:
    captures:
      1: { name: punctuation.definition.string.begin.markdown }
      2: { name: string.other.link.title.markdown }
      4: { name: punctuation.definition.string.end.markdown }
      5: { name: punctuation.definition.constant.begin.markdown }
      6: { name: punctuation.definition.constant.end.markdown }
    match: (\[)((?<square>[^\[\]\\]|\\.|\[\g<square>*+\])*+)(\])[ ]?(\[)(\])
    name: meta.link.reference.literal.markdown
    patterns: [include: '#escapes-embedded']

  link-ref-shortcut:
    captures:
      1: { name: punctuation.definition.string.begin.markdown }
      2: { name: string.other.link.title.markdown }
      3: { name: punctuation.definition.string.end.markdown }
    match: (\[)(\S+?)(\])
    name: meta.link.reference.markdown
    patterns: [include: '#escapes-embedded']

  raw:
    captures:
      1: { name: punctuation.definition.raw.markdown }
      2: { patterns: [include: '#escapes-embedded'] }
      3: { name: punctuation.definition.raw.markdown }
    match: (`+)([^`]|(?!(?<!`)\1(?!`))`)*+(\1)
    name: markup.inline.raw.string.markdown
    patterns: [include: '#escapes-embedded']

  escapes-embedded:
    patterns:
      - include: '#string-escapes'
      - include: '#embedded-verbatim'

  markdown:
    patterns:
      - include: '#comments'
      - include: '#xml-entities'
      - include: '#html-tag'
      - include: '#escapes-embedded'
      - include: '#evaluated-code'
      - include: '#inline-styles'
      - include: '#headings'
      - include: '#blockquote'
      - include: '#unordered-list'
      - include: '#ordered-list'
      - include: '#inline-markdown'

  headings:
    applyEndPatternLast: true
    comment: '### Headings'
    begin: ^\s*(\#{1,6})\s+(.*)\n*
    end: (?=|$)
    beginCaptures:
      1: { name: punctuation.definition.heading.markdown }
      2:
        patterns:
          - applyEndPatternLast: true
            begin: (?<=\######\s*)
            end: (?=|$)
            name: heading.6.markdown entity.name.section.markdown
            patterns: [include: '#markdown']
          - applyEndPatternLast: true
            begin: (?<=\#####\s*)
            end: (?=|$)
            name: heading.5.markdown entity.name.section.markdown
            patterns: [include: '#markdown']
          - applyEndPatternLast: true
            begin: (?<=\####\s*)
            end: (?=|$)
            name: heading.4.markdown entity.name.section.markdown
            patterns: [include: '#markdown']
          - applyEndPatternLast: true
            begin: (?<=\###\s*)
            end: (?=|$)
            name: heading.3.markdown entity.name.section.markdown
            patterns: [include: '#markdown']
          - applyEndPatternLast: true
            begin: (?<=\##\s*)
            end: (?=|$)
            name: heading.2.markdown entity.name.section.markdown
            patterns: [include: '#markdown']
          - applyEndPatternLast: true
            begin: (?<=\#\s*)
            end: (?=|$)
            name: heading.1.markdown entity.name.section.markdown
            patterns: [include: '#markdown']
    name: markup.heading.markdown
    patterns: [include: '#markdown']

  blockquote:
    comment: '* blockquote'
    applyEndPatternLast: true
    begin: ^\s*(>)(\s+.*)\n*
    end: (?=|$)
    beginCaptures:
      1: { name: punctuation.definition.quote.begin.markdown }
      2:
        name: markup.quote.markdown
        patterns: [include: '#markdown']
    name: markup.quote.markdown
    patterns: [include: '#markdown']

  unordered-list:
    comment: '- unordered list'
    applyEndPatternLast: true
    begin: ^\s*(-)(?!>)\s+(.*)\n*
    end: (?=|$)
    beginCaptures:
      1: { name: punctuation.definition.list.begin.markdown }
      2:
        name: markup.list.unnumbered.markdown
        patterns: [include: '#markdown']
    name: markup.list.unnumbered.markdown
    patterns: [include: '#markdown']

  ordered-list:
    comment: '+ ordered list'
    applyEndPatternLast: true
    begin: ^\s*(\+)(?!>)\s+(.*)\n*
    end: (?=|$)
    beginCaptures:
      1: { name: punctuation.definition.list.begin.markdown }
      2:
        name: markup.list.numbered.markdown
        patterns: [include: '#markdown']
    name: markup.list.numbered.markdown
    patterns: [include: '#markdown']

  evaluated-code:
    comment: Evaluated code
    applyEndPatternLast: true
    begin: ^\s*(;)(?!>)\s+
    end: (?=|$)
    beginCaptures:
      1: { name: punctuation.definition.evaluated-code.markdown }
      2: { name: meta.evaluated-code.markdown }
    name: meta.evaluated-code.markdown
    patterns: [include: $self]

  html-tag:
    comment: <Tags
    applyEndPatternLast: true
    begin: (?<=^|[\w\s'"`])(<)\b
    end: (<?>?=?)|(?=)|$
    name: meta.tag.ruko
    captures:
      1: { name: punctuation.definition.tag.ruko }
    patterns:
      - comment: Tag name
        match: (?<=<)\b([\p{Pc}\p{L}]\w*\b(?:(?:[?!:]:|[?!]?\.|[?!-]>)[\p{Pc}\p{L}]\w*)*)\b
        captures:
          1:
            name: entity.name.tag.ruko
            patterns: [include: '#html-tags']
      - include: '#style-selectors'
      - begin: (\[)\s*
        end: \s*(\])
        captures:
          1: { name: punctuation.definition.directive.ruko }
        patterns:
          - include: '#attribute-selectors'
          - include: $self
      - begin: ({)\s*
        end: \s*(})
        captures:
          1: { name: punctuation.definition.mapping.ruko }
        patterns:
          - include: '#style-properties'
          - include: $self
      - begin: (\()\s*
        end: \s*(\))
        captures:
          1: { name: punctuation.definition.parameters.ruko }
        patterns:
          - include: '#tag-attributes'
          - include: $self
      - include: '#literals'
      - include: '#regexps'
      - include: '#punctuation'
      - include: '#comments'
      - include: '#space'

  html-tags:
    patterns:
      - match: ([?!:]:|[?!]?\.|[?!-]>)
        captures:
          1: { name: punctuation.separator.namespace.ruko }
      - match: \b([\p{Pc}\p{L}]\w*)\b(?=[:.])
        name: entity.name.tag.namespace.ruko
      - match: \b((?:[\p{Pc}\p{L}&&\P{Ll}][\w&&\P{Lu}]*)+)\b
        name: support.class.component.ruko
      - include: '#clauses'
      - include: '#declarations'
      - include: '#keywords'
      - include: '#html-tag-names'

  inline-styles:
    begin: (?<=^|[\w\s'"`])(\+>)(.*)\n*
    beginCaptures:
      1: { name: storage.type.style.ruko }
      2:
        patterns:
          - match: (?<=^|\s)([?:]?=)(?=\s+|$)
            captures:
              1: { name: keyword.operator.assignment.ruko }
          - include: '#comments'
          - include: '#style-pair'
          - include: '#style-rules'
          - include: '#declaration-clause'
          - match: &entity-name |
              (?x) \s*\b

              (?!
                (?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b
                (?: # keywords
                  # wordlike operators
                  [io]n|off?|[ai]s|has|new|old|del|(?:de)?ref|to
                  |(?:un)?[gs]et|n?and|x?n?or|c?n?imply|not|by

                  # declaration keywords
                  |va[rl]|dyn|mut|let|const
                  |func|pro[pc]|type|class|actor|trait|enum|in?ter
                  |module|schema|struct|record|object|union|macro
                  |query|quote|style|script|entity|temp|oper|realm

                  # control flow keywords
                  |if|else|[tw]hen|guard|with|unless
                  |for|while|loop|goto|break|skip|redo|until
                  |try|switch|[cm]atch|case|def|throw|raise|error
                  |return|yield|await|move|goto|pass|defer
                  |[gd]o|from|where|(?:im|ex)(?:port|tern)

                  # miscellaneous keywords
                  |debug|assert|check|decl
                  |use|echo|eval|expr|scope
                  |begin|end|prev|next
                )
                \b
              )

              # identifier
              ([\p{Pc}\p{L}]\w*)
              \b
            name: entity.name.style.ruko
    end: ^(?=\S)|(?!\G)
    patterns:
      - begin: ^(\s+)(?!\s)
        end: ^(?!\1|\s*$)
        name: meta.style.yaml
        patterns: [include: '#style-properties']

  # Special code blocks

  html-builtins:
    patterns:
      - include: source.css.scss#constant_functions
      - include: source.css.scss#constant_sass_functions
      - include: source.css.scss#constant_important
      - include: source.css.scss#constant_default
      - include: source.css.scss#constant_optional

  property-name:
    match: (\b[\p{Pc}\p{L}]\w*\b(?:(?:(?:[?!:]:|[?!]?\.|[?!-]>)?[\p{Pc}\p{L}]\w*)*)\b)
    name: meta.property-name.ruko
    captures:
      1:
        patterns:
          - include: '#css-property-values'
          - match: \b([\p{Pc}\p{L}]\w*)\b(?=[.:])
            name: constant.other.ruko
          - match: \b([\p{Pc}\p{L}]\w*)\b
            name: constant.language.ruko
          - match: '[?!:]:|[?!]?\.|[?!-]>'
            name: punctuation.separator.namespace.ruko

  style-list:
    begin: \s*(\[)\s*
    end: \s*(\])\s*
    name: meta.brace.square.ruko
    captures:
      1: { name: punctuation.definition.expression.ruko }
    patterns:
      - include: '#punctuation'
      - include: '#style-property-values'
      - include: $self

  style-property-values:
    patterns:
      - include: '#hex-colors'
      - include: '#embedded-expressions'
      - include: '#embedded-formatting'
      - include: '#embedded-arguments'
      - include: '#css-property-values'
      - include: '#unit-suffix'
      - include: $self

  hex-colors:
    match: \s*(\#)\b(\h{3,4}|\h{6}|\h{8})\b\s*
    captures:
      1: { name: punctuation.definition.constant.css }
      2:
        name: constant.other.color.rgb-value.hex.css
        patterns:
          - match: (\h{2})(\h{2})(\h{2})(\h{2})?
            captures:
              1: { name: constant.other.color.red-value.hex.css }
              2: { name: constant.other.color.green-value.hex.css }
              3: { name: constant.other.color.blue-value.hex.css }
              4: { name: constant.other.color.alpha-value.hex.css }
          - match: (\h)(\h)(\h)(\h)?
            captures:
              1: { name: constant.other.color.red-value.hex.css }
              2: { name: constant.other.color.green-value.hex.css }
              3: { name: constant.other.color.blue-value.hex.css }
              4: { name: constant.other.color.alpha-value.hex.css }

  tag-names:
    match: \s*\b([\p{Pc}\p{L}]\w*\b(?:(?:[?!:]:|[?!]?\.|[?!-]>)?[\p{Pc}\p{L}]\w*)*)\b\s*
    name: entity.name.tag.ruko
    captures:
      1:
        name: entity.name.tag.ruko
        patterns: [include: '#html-tags']

  script-blocks:
    define: &script-blocks
      end: \s*(})\s*
      name: meta.brace.script.ruko
      beginCaptures:
        1: { name: storage.type.language.ruko }
        2: { name: punctuation.definition.block.script.ruko }
      endCaptures:
        1: { name: punctuation.definition.block.script.ruko }

    patterns:
      - begin: \b((?i:js))\b\s*({)\s*
        <<: *script-blocks
        patterns:
          - include: '#embedded'
          - include: source.js
      - begin: \b((?i:jsx))\b\s*({)\s*
        <<: *script-blocks
        patterns:
          - include: '#embedded'
          - include: source.jsx
      - begin: \b((?i:ts))\b\s*({)\s*
        <<: *script-blocks
        patterns:
          - include: '#embedded'
          - include: source.ts
      - begin: \b((?i:tsx))\b\s*({)\s*
        <<: *script-blocks
        patterns:
          - include: '#embedded'
          - include: source.tsx
      - begin: \b((?i:py))\b\s*({)\s*
        <<: *script-blocks
        patterns:
          - include: '#embedded'
          - include: source.python
      - begin: \b((?i:rb))\b\s*({)\s*
        <<: *script-blocks
        patterns:
          - include: '#embedded'
          - include: source.ruby
      - begin: \b((?i:php))\b\s*({)\s*
        <<: *script-blocks
        patterns:
          - include: '#embedded'
          - include: source.php
      - begin: \b((?i:java))\b\s*({)\s*
        <<: *script-blocks
        patterns:
          - include: '#embedded'
          - include: source.java
      - begin: \b((?i:c))\b\s*({)\s*
        <<: *script-blocks
        patterns:
          - include: '#embedded'
          - include: source.c
      - begin: \b((?i:cpp))\b\s*({)\s*
        <<: *script-blocks
        patterns:
          - include: '#embedded'
          - include: source.cpp
      - begin: \b((?i:cs))\b\s*({)\s*
        <<: *script-blocks
        patterns:
          - include: '#embedded'
          - include: source.cs
      - begin: \b((?i:go))\b\s*({)\s*
        <<: *script-blocks
        patterns:
          - include: '#embedded'
          - include: source.go
      - begin: \b((?i:rs))\b\s*({)\s*
        <<: *script-blocks
        patterns:
          - include: '#embedded'
          - include: source.rust
      - begin: \b((?i:swift))\b\s*({)\s*
        <<: *script-blocks
        patterns:
          - include: '#embedded'
          - include: source.swift
      - begin: \b((?i:kt))\b\s*({)\s*
        <<: *script-blocks
        patterns:
          - include: '#embedded'
          - include: source.kotlin
      - begin: \b((?i:scala))\b\s*({)\s*
        <<: *script-blocks
        patterns:
          - include: '#embedded'
          - include: source.scala
      - begin: \b((?i:hs))\b\s*({)\s*
        <<: *script-blocks
        patterns:
          - include: '#embedded'
          - include: source.haskell
      - begin: \b((?i:lua))\b\s*({)\s*
        <<: *script-blocks
        patterns:
          - include: '#embedded'
          - include: source.lua
      - begin: \b((?i:dart))\b\s*({)\s*
        <<: *script-blocks
        patterns:
          - include: '#embedded'
          - include: source.dart
      - begin: \b((?i:objc))\b\s*({)\s*
        <<: *script-blocks
        patterns:
          - include: '#embedded'
          - include: source.objc
      - begin: \b((?i:objcpp))\b\s*({)\s*
        <<: *script-blocks
        patterns:
          - include: '#embedded'
          - include: source.objcpp
      - begin: \b((?i:perl))\b\s*({)\s*
        <<: *script-blocks
        patterns:
          - include: '#embedded'
          - include: source.perl
      - begin: \b((?i:r))\b\s*({)\s*
        <<: *script-blocks
        patterns:
          - include: '#embedded'
          - include: source.r
      - begin: \b((?i:sh))\b\s*({)\s*
        <<: *script-blocks
        patterns:
          - include: '#embedded'
          - include: source.shell
      - begin: \b((?i:sql))\b\s*({)\s*
        <<: *script-blocks
        patterns:
          - include: '#embedded'
          - include: source.sql
      - begin: \b((?i:html))\b\s*({)\s*
        <<: *script-blocks
        patterns:
          - include: '#embedded'
          - include: text.html.basic
      - begin: \b((?i:css))\b\s*({)\s*
        <<: *script-blocks
        patterns:
          - include: '#embedded'
          - include: source.css
      - begin: \b((?i:json))\b\s*({)\s*
        <<: *script-blocks
        patterns:
          - include: '#embedded'
          - include: source.json
      - begin: \b((?i:xml))\b\s*({)\s*
        <<: *script-blocks
        patterns:
          - include: '#embedded'
          - include: text.xml
      - begin: \b((?i:yaml|yml))\b\s*({)\s*
        <<: *script-blocks
        patterns:
          - include: '#embedded'
          - include: source.yaml
      - begin: \b((?i:markdown|md))\b\s*({)\s*
        <<: *script-blocks
        patterns:
          - include: '#embedded'
          - include: text.html.markdown
      - begin: \b((?i:latex|tex))\b\s*({)\s*
        <<: *script-blocks
        patterns:
          - include: '#embedded'
          - include: text.tex.latex
      - begin: \b((?i:wa(?>s[im]|t)))\b\s*({)\s*
        <<: *script-blocks
        patterns:
          - include: '#embedded'
          - include: source.wat
      - begin: \b((?i:cljs?))\b\s*({)\s*
        <<: *script-blocks
        patterns:
          - include: '#embedded'
          - include: source.clojure
      - begin: \b((?i:makefile|make))\b\s*({)\s*
        <<: *script-blocks
        patterns:
          - include: '#embedded'
          - include: source.makefile
      - begin: \b((?i:hs))\b\s*({)\s*
        <<: *script-blocks
        patterns:
          - include: '#embedded'
          - include: source.haskell
      - begin: \b((?i:ml))\b\s*({)\s*
        <<: *script-blocks
        patterns:
          - include: '#embedded'
          - include: source.ml
      - begin: \b((?i:ocaml))\b\s*({)\s*
        <<: *script-blocks
        patterns:
          - include: '#embedded'
          - include: source.ocaml
      - begin: \b((?i:fs))\b\s*({)\s*
        <<: *script-blocks
        patterns:
          - include: '#embedded'
          - include: source.fsharp

  operator-declarations:
    comment: 'Operator declarations.
      Format: <prec> <associativity> <fixity> <operator> (-> <return type>)'
    patterns:
      - include: '#comments'
      - match: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(prec)\b\s*(?:(\d+)|([\p{Pc}\p{L}]\w*))
        captures:
          1: { name: storage.modifier.precedence.ruko }
          2: { name: constant.numeric.integer.ruko }
          3: { name: constant.language.ruko }
      - match: *entity-name
        name: variable.parameter.operator.ruko
      - include: '#type-signature'
      - include: '#suffix-operators'
      - include: '#prefix-operators'
      - include: '#infix-operators'

  style-block:
    begin: \s*({)\s*
    end: \s*(})\s*
    name: meta.brace.style.ruko
    captures:
      1: { name: punctuation.section.property-list.ruko }
    patterns:
      - include: '#style-properties'
      - include: '#style-list'
      - include: $self

  style-selectors:
    define: &attribute-selectors
      applyEndPatternLast: true
      end: (?=)|$
      patterns:
        - match: '[\p{Pd}\w]+'
          patterns: [include: '#css-property-keys']
        - begin: (<)
          end: (>)
          name: meta.brace.angle.ruko
          captures:
            1: { name: punctuation.definition.variable.ruko }
          patterns:
            - include: '#style-property-values'
            - include: $self

    patterns:
      - match: \s*([@#&*|%.:~^?]|::)(?=[\w$'"`])
        name: punctuation.definition.entity.ruko
      - begin: \s*(?<=[~\s])\b
        <<: *attribute-selectors
        name: entity.other.attribute-name.key.ruko
      - begin: \s*(?<=#)\b
        <<: *attribute-selectors
        name: entity.other.attribute-name.id.ruko
      - begin: \s*(?<=\.)\b
        <<: *attribute-selectors
        name: entity.other.attribute-name.class.ruko
      - begin: \s*(?<=::)\b
        <<: *attribute-selectors
        name: entity.other.attribute-name.pseudo-component.ruko
      - begin: \s*(?<=@)\b
        <<: *attribute-selectors
        name: entity.name.decorator.ruko
      - begin: \s*(?<=&)\b
        <<: *attribute-selectors
        name: entity.name.type.anchor.ruko
      - begin: \s*(?<=\*)\b
        <<: *attribute-selectors
        name: entity.name.type.alias.ruko
      - begin: \s*(?<=%)\b
        <<: *attribute-selectors
        name: entity.name.function.ruko
      - begin: \s*(?<=\|)\b
        <<: *attribute-selectors
        name: entity.name.method.ruko
      - begin: \s*(?<=:)\b
        <<: *attribute-selectors
        name: entity.name.procedure.ruko
      - begin: \s*(?<=\^)\b
        <<: *attribute-selectors
        name: entity.name.property.ruko
      - begin: \s*(?<=\?)\b
        <<: *attribute-selectors
        name: entity.name.predicate.ruko

  style-pair:
    begin: (?<=^|[;,{\[(])\s*\b([\p{Pd}\w]+)\b(:)\s*
    end: (?=[;,}\])])|$
    name: meta.property.css.ruko
    beginCaptures:
      1:
        name: support.type.property-name.ruko
        patterns: [include: '#css-property-keys']
      2: { name: punctuation.separator.key-value.ruko }
    patterns:
      - include: '#style-property-values'
      - include: '#space'

  style-properties:
    patterns:
      - include: '#comments'
      - include: '#style-pair'
      - include: '#embedded'
      - include: '#clauses'
      - include: '#declarations'
      - include: '#keywords'
      - include: '#style-rules'
      - include: '#style-block'
      - include: '#space'
      - include: $self

  style-rules:
    patterns:
      - include: '#type-operators'
      - begin: \s*(\()\s*
        end: \s*(\))
        captures:
          1: { name: punctuation.definition.parameters.ruko }
        patterns:
          - match: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(as)\b\s*
            name: keyword.operator.expression.as.ruko
          - include: '#clauses'
          - include: '#constants'
          - include: '#declarations'
          - include: '#expression-keywords'
          - include: '#style-pair'
          - include: '#call-arguments'
          - include: $self
      - begin: \s*(\[)\s*
        end: \s*(\])\s*
        captures:
          1: { name: punctuation.definition.selector.ruko }
        patterns:
          - include: '#attribute-selectors'
          - include: $self
      - match: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(from|to|except|only|as)\b\s*
        name: keyword.operator.expression.ruko
      - include: '#style-selectors'
      - include: '#format-syntax'
      - include: '#tag-names'

  # Comments

  comments:
    patterns:
      - include: '#block-comments'
      - include: '#line-comments'

  block-comments:
    patterns:
      - begin: \s*(/\*\*)(?![\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]+)
        end: \s*(\*/)
        name: comment.block.documentation.ruko
        captures:
          1: { name: punctuation.definition.comment.ruko }
        patterns:
          - include: '#jsdoc'
          - include: text.html.markdown#inline
          - include: '#nested-jsdoc-comment'
      - begin: \s*(/\*)(?![\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]+)
        end: \s*(\*/)
        name: comment.block.ruko
        captures:
          1: { name: punctuation.definition.comment.ruko }
        patterns:
          - include: text.html.markdown#inline
          - include: '#nested-block-comment'

  line-comments:
    patterns:
      - begin: \s*(///)(?![\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]+)
        end: \s*$
        name: comment.line.documentation.ruko
        captures:
          1: { name: punctuation.definition.comment.ruko }
        patterns:
          - include: '#jsdoc'
          - include: text.html.markdown#inline
      - begin: \s*(//)(?![\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]+)
        end: \s*$
        name: comment.line.number-sign.ruko
        captures:
          1: { name: punctuation.definition.comment.ruko }
        patterns:
          - include: text.html.markdown#inline

  nested-jsdoc-comment:
    begin: (/\*\*?)(?![\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]+)
    end: \s*(\*/)
    name: comment.block.documentation.nested.ruko
    captures:
      1: { name: punctuation.definition.comment.ruko }
    patterns:
      - include: '#jsdoc'
      - include: text.html.markdown#inline
      - include: '#nested-jsdoc-comment'

  nested-block-comment:
    begin: (/\*)(?![\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]+)
    end: \s*(\*/)
    name: comment.block.nested.ruko
    captures:
      1: { name: punctuation.definition.comment.ruko }
    patterns:
      - include: text.html.markdown#inline
      - include: '#nested-block-comment'

  # JSDoc

  jsdoc:
    patterns:
      - include: '#jsdoc-inline-tags'
      - include: '#jsdoc-access'
      - include: '#jsdoc-as-name-path'
      - include: '#jsdoc-simple'
      - include: '#jsdoc-simple-name-path'
      - include: '#jsdoc-module'
      - include: '#jsdoc-type-name'
      - include: '#jsdoc-type-no-name'
      - comment: additional jsdoc V2 keywords
        match: (?<!\w)@(add|api|body|codeend|codestart|demo|download|group|hide|iframe|image|inherits|option|outline|page|parent|signature|tag)\b
        name: storage.type.class.jsdoc
      - comment: additional jsdoc keywords
        match: (?<!\w)@(accessor|alternateClassName|aside|cfg|chainable|docauthor|evented|experimental|ftype|hide|inheritable|localdoc|markdown|mixins|new|override|preventable|ptype|removed|scss mixin|object|template|uses|xtype)\b
        name: storage.type.class.jsdoc

  jsdoc-access:
    comment: '@tag protected....'
    match: (@(access))\s*(private|protected|public)?(?=\s|$)
    captures:
      1: { name: storage.type.class.jsdoc }
      3: { name: storage.modifier.jsdoc }

  jsdoc-module:
    comment: '@tag {optional type} module:file'
    begin: (@(exports|module|listens|requires)\b)\s*(?=({(?:(?>(?:[^\\{}]|\\.)+)|\g<-1>)*\})?\s*(\S*)([\S\s]*))
    end: ^|(?=\*/)|(?=\5$)
    beginCaptures:
      1: { name: storage.type.class.jsdoc }
    patterns:
      - include: '#jsdoc-typedef-scopes'
      - match: (?:(module)(:))?(((?!\*/)\S)+)
        captures:
          1: { name: keyword.module.jsdoc }
          2: { name: punctuation.jsdoc }
          3: { name: string.modulename.jsdoc }

  jsdoc-as-name-path:
    comment: to terminate the block
    begin: (@(borrows|lends)\b)\s*(?=(?!\*/)\S+(?:(?:\s*\bas\b\s*(?!\*/)\S+)?)?([\S\s]*))
    end: ^|(?=\*/)|(?=\3$)
    beginCaptures:
      1: { name: storage.type.class.jsdoc }
    patterns: [include: '#jsdoc-name-path-scopes']

  jsdoc-simple:
    comment: '@tag'
    match: (@(abs|author|classdesc|copyright|default|defaultvalue|deprecated|description|desc|example|external|fileoverview|file|global|host|ignore|inheritdoc|inner|instance|license|override|overview|readonly|see|since|stat|summary|todo|tutorial|virtual|variation|version)\b)(?=$|\s)
    captures:
      1: { name: storage.type.class.jsdoc }

  jsdoc-simple-name-path:
    comment: '@tag {opt type} Class#xxx or Class#Event:aaaa etc'
    begin: (@(alias|augments|callback|extends|emits|event|fires|inter|memberof|mixes|name|property|property|this|typedef)\b)\s*(?=({(?:(?>(?:[^\\{}]|\\.)+)|\g<-1>)*\})?\s*\S*([\S*\s]*))
    end: ^|(?=\*/)|(?=\4$)
    beginCaptures:
      1: { name: storage.type.class.jsdoc }
    patterns:
      - include: '#jsdoc-typedef-scopes'
      - include: '#jsdoc-name-path-scopes'

  jsdoc-type-name:
    comment: '@tag {optional type} name'
    begin: (@(arg|argument|class|constant|constructor|constructs|const|function|fn|kind|member|method|mixin|actor|param|var)\b)\s*(?=({(?:(?>(?:[^\\{}]|\\.)+)|\g<-1>)*\})?\s*(((\[(?:(?>[^\[\]]+)|\g<-1>)*\])|\S)+)?([\S\s]*))
    end: ^|(?=\*/)|(?=\7$)
    beginCaptures:
      1: { name: storage.type.class.jsdoc }
    patterns:
      - include: '#jsdoc-typedef-scopes'
      - include: '#jsdoc-name-scopes'

  jsdoc-type-no-name:
    comment: '@tag {types}'
    begin: (@(enum|exception|implements|private|protected|public|returns|return|throws|type)\b)\s*(?=({(?:(?>(?:[^\\{}]|\\.)+)|\g<-1>)*\})?\s*([\S\s]*))
    end: ^|(?=\*/)|(?=\4$)
    beginCaptures:
      1: { name: storage.type.class.jsdoc }
    patterns: [include: '#jsdoc-typedef-scopes']

  jsdoc-inline-tags:
    name: meta.tag.inline.jsdoc
    begin: (\[(?:(?>[^\[\]]+)|\g<-1>)*\])?({)(?=@)
    end: \s*(})
    beginCaptures:
      1: { name: string.linktext.jsdoc }
      2: { name: meta.brace.curly.jsdoc }
    endCaptures:
      1: { name: meta.brace.curly.jsdoc }
    patterns:
      - match: (@(link|tutorial))\b([^}]*)
        captures:
          1: { name: storage.type.class.jsdoc }
          3: { name: string.jsdoc }

  jsdoc-typedef-scopes:
    name: entity.name.type.instance.jsdoc
    begin: '{'
    end: '}|^'
    captures:
      0: { name: meta.brace.curly.jsdoc }
    patterns:
      - include: '#jsdoc-typedef-primitives'
      - include: '#jsdoc-name-path-scopes'
      - include: '#jsdoc-typedef-obj'

  jsdoc-typedef-primitives:
    match: \b(null|undefined|boolean|string|number)\b
    captures:
      1: { name: support.type.builtin.primitive.jsdoc }

  jsdoc-typedef-obj:
    comment: typedef object
    begin: '{'
    end: '}|^'
    captures:
      0: { name: meta.brace.curly.jsdoc }
    patterns:
      - include: '#jsdoc-typedef-primitives'
      - match: \b([\p{Pc}\p{L}]\w*)\b\s*(:)
        captures:
          1: { name: variable.other.readwrite.jsdoc }
      - include: '#jsdoc-name-path-scopes'
      - include: '#jsdoc-typedef-obj'

  jsdoc-name-scopes:
    patterns:
      - match: ((?!\*/)[\S&&[^\[\]"']])+
        captures:
          0: { name: variable.other.jsdoc }
      - name: variable.other.jsdoc
        begin: \[
        end: \]|^
        patterns:
          - include: '#jsdoc-string'
          - include: '#jsdoc-name-scopes'

  jsdoc-name-path-scopes:
    patterns:
      - match: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(as)\b\s*(?=[\p{Pc}\p{L}])
        captures:
          1: { name: keyword.as.jsdoc }
      - match: \s*(?:([\p{Pc}\p{L}&&\P{Ll}]+\w*)|([\p{Pc}\p{L}]\w*))(?=[\s\-~.#]|$)
        captures:
          1: { name: entity.name.class.jsdoc }
          2: { name: entity.name.function.jsdoc }
      - match: (\.)([\p{Pc}\p{L}]\w*)\b(?=\s|$|\")
        captures:
          1: { name: keyword.operator.accessor.jsdoc }
          2: { name: entity.name.function.method.static.jsdoc }
      - match: (\#)([\p{Pc}\p{L}]\w*)\b(?=\s|$|\")
        captures:
          1: { name: keyword.operator.accessor.jsdoc }
          2: { name: entity.name.function.method.instance.jsdoc }
      - match: (~|-)([\p{Pc}\p{L}]\w*)\b(?=\s|$|\")
        captures:
          1: { name: keyword.operator.accessor.jsdoc }
          2: { name: entity.name.function.method.inner.jsdoc }
      - match: (\#)(event)(:)
        captures:
          1: { name: keyword.operator.accessor.jsdoc }
          2: { name: keyword.event.jsdoc }
          3: { name: keyword.operator.jsdoc }
      - name: string.method.jsdoc
        begin: \.(?="|')
        end: (?=.)
        applyEndPatternLast: true
        patterns: [include: '#jsdoc-string']

  jsdoc-string:
    name: string.jsdoc
    match: '"(\\"|[^"])*"|''(\\''|[^''])*'

  # Function and method calls

  sigil-function-calls:
    name: meta.function.arguments.ruko
    match: |-
      (?x)
      \b
      (
        (?:
          \b[\p{Pc}\p{L}]\w*\b # identifier
          (?:(?:[?!]?\.|[?!:]:|[?!-]>)=?) # qualified name separator
        )*
        [\p{Pc}\p{L}]\w* # last part of identifier
      )
      \b
      (?=
        \s*
        (?:
            (?: [$@] | <\|+ | <!+ | <[-+]) (?:['"`\w\s]|\#?[(\[{]) # function application, composition and piping
          | (?:(?:[?!]?\.|[?!:]:|[?!-]>)=?)? \#? [({] # C-style function call
          | (?:(?:[?!]?\.|[?!:]:|[?!-]>)=?)? < [\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]* (?:['"`\w]|\#?[(\[{]) # generics
          | [!~] \#? [({] # macro and destructor calls
          | (?:\w*|[\\$\#%]*)['"] | `\s*(?=\N) # strings
          | :[\p{Pc}\p{L}]\w* # symbols
        )
      )
    captures:
      1: { patterns: [include: '#function-names'] }

  function-calls:
    patterns:
      - comment: Backward piped function calls
        name: meta.function.arguments.ruko
        match: |-
          (?x)
          (?<=
            (?:
                (?: 
                  ^ # start of line
                  | [,;] # delimiter 
                  | (?: ['"`)}\]\w\s] | \\.): # postfix colon
                  | \#? [({\[] # opening bracket
                  | [)\]}] # closing bracket
                ) \s*
              | # infix operator
                \s+ (?:[\p{P}\p{S}&&[^,;'"`/\\({\[)}\]\p{Pc}]]+
                  (?:[\p{P}\p{S}]*
                    [\p{P}\p{S}&&[^,;'"`/\\({\[)}\]\p{Pc}]]+
                  )?
                ) \s+
              | # primary operator
                \b (?:[\p{P}\p{S}&&[^,;'"`/\\({\[)}\]\p{Pc}]]+
                  (?:[\p{P}\p{S}]*
                    [\p{P}\p{S}&&[^,;'"`/\\({\[)}\]\p{Pc}]]+
                  )?
                ) \b
              | (?:
                (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
                \b
                  (?: # keywords
                    # wordlike operators
                    [io]n|off?|[ai]s|has|new|old|del|(?:de)?ref|to
                    |(?:un)?[gs]et|n?and|x?n?or|c?n?imply|not|by

                    # declaration keywords
                    |va[rl]|dyn|mut|let|const
                    |func|pro[pc]|type|class|actor|trait|enum|in?ter
                    |module|schema|struct|record|object|union|macro
                    |query|quote|style|script|entity|temp|oper|realm

                    # control flow keywords
                    |if|else|[tw]hen|guard|with|unless
                    |for|while|loop|goto|break|skip|redo|until
                    |try|switch|[cm]atch|case|def|throw|raise|error
                    |return|yield|await|move|goto|pass|defer
                    |[gd]o|from|where|(?:im|ex)(?:port|tern)

                    # miscellaneous keywords
                    |debug|assert|check|decl
                    |use|echo|eval|expr|scope
                    |begin|end|prev|next
                  )
                \b
              ) \s*
            )
            [\p{P}\p{S}&&[^,;'"`/\({\[)}\]\p{Pc}]]* # prefix operator except slashes
          )
          \b
          (
            # ignore all keywords
            (?!
              (?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b
              (?: # keywords
                # wordlike operators
                [io]n|off?|[ai]s|has|new|old|del|(?:de)?ref|to
                |(?:un)?[gs]et|n?and|x?n?or|c?n?imply|not|by

                # declaration keywords
                |va[rl]|dyn|mut|let|const
                |func|pro[pc]|type|class|actor|trait|enum|in?ter
                |module|schema|struct|record|object|union|macro
                |query|quote|style|script|entity|temp|oper|realm

                # control flow keywords
                |if|else|[tw]hen|guard|with|unless
                |for|while|loop|goto|break|skip|redo|until
                |try|switch|[cm]atch|case|def|throw|raise|error
                |return|yield|await|move|goto|pass|defer
                |[gd]o|from|where|(?:im|ex)(?:port|tern)

                # miscellaneous keywords
                |debug|assert|check|decl
                |use|echo|eval|expr|scope
                |begin|end|prev|next
              ) \b
            )
            (?:
              \b[\p{Pc}\p{L}]\w*\b # identifier
              (?:(?:[?!]?\.|[?!:]:|[?!-]>)=?) # qualified name separator
            )*
            [\p{Pc}\p{L}]\w* # last part of identifier
          )
          \b
          (?=
            \s+ (?:<[-=]?\||<\+) (?:['"`\w\s]|\#?[(\[{]) # function composition and piping
          )
        captures:
          1:
            name: meta.function.name.ruko
            patterns: [include: '#function-names']
      - comment: Normal (bracketed or bracketless) function calls
        name: meta.function.arguments.ruko
        match: |-
          (?x)
          (?<=
            (?:
                (?: 
                  ^ # start of line
                  | [,;] # delimiter 
                  | (?: ['"`)}\]\w\s] | \\.): # postfix colon
                  | \#? [({\[] # opening bracket
                  | [)\]}] # closing bracket
                ) \s*
              | # infix operator
                \s+ (?:[\p{P}\p{S}&&[^,;'"`\\({\[)}\]\p{Pc}]]+
                  (?:[\p{P}\p{S}]*
                    [\p{P}\p{S}&&[^,;'"`\\({\[)}\]\p{Pc}]]+
                  )?
                ) \s+
              | # primary operator
                \b (?:[\p{P}\p{S}&&[^,;'"`/\\({\[)}\]\p{Pc}]]+
                  (?:[\p{P}\p{S}]*
                    [\p{P}\p{S}&&[^,;'"`/\\({\[)}\]\p{Pc}]]+
                  )?
                ) \b
              | (?:
                (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
                \b
                  (?: # keywords
                    # wordlike operators
                    [io]n|off?|[ai]s|has|new|old|del|(?:de)?ref|to
                    |(?:un)?[gs]et|n?and|x?n?or|c?n?imply|not|by

                    # declaration keywords
                    |va[rl]|dyn|mut|let|const
                    |func|pro[pc]|type|class|actor|trait|enum|in?ter
                    |module|schema|struct|record|object|union|macro
                    |query|quote|style|script|entity|temp|oper|realm

                    # control flow keywords
                    |if|else|[tw]hen|guard|with|unless
                    |for|while|loop|goto|break|skip|redo|until
                    |try|switch|[cm]atch|case|def|throw|raise|error
                    |return|yield|await|move|goto|pass|defer
                    |[gd]o|from|where|(?:im|ex)(?:port|tern)

                    # miscellaneous keywords
                    |debug|assert|check|decl
                    |use|echo|eval|expr|scope
                    |begin|end|prev|next
                  )
                \b
              ) \s*
            )
            [\p{P}\p{S}&&[^,;'"`/\({\[)}\]\p{Pc}]]* # prefix operator except slashes
          )
          \b
          (
            # ignore all keywords
            (?!
              (?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b
              (?: # keywords
                # wordlike operators
                [io]n|off?|[ai]s|has|new|old|del|(?:de)?ref|to
                |(?:un)?[gs]et|n?and|x?n?or|c?n?imply|not|by

                # declaration keywords
                |va[rl]|dyn|mut|let|const
                |func|pro[pc]|type|class|actor|trait|enum|in?ter
                |module|schema|struct|record|object|union|macro
                |query|quote|style|script|entity|temp|oper|realm

                # control flow keywords
                |if|else|[tw]hen|guard|with|unless
                |for|while|loop|goto|break|skip|redo|until
                |try|switch|[cm]atch|case|def|throw|raise|error
                |return|yield|await|move|goto|pass|defer
                |[gd]o|from|where|(?:im|ex)(?:port|tern)

                # miscellaneous keywords
                |debug|assert|check|decl
                |use|echo|eval|expr|scope
                |begin|end|prev|next
              ) \b
            )
            (?:
              \b[\p{Pc}\p{L}]\w*\b # identifier
              (?:(?:[?!]?\.|[?!:]:|[?!-]>)=?) # qualified name separator
            )*
            [\p{Pc}\p{L}]\w* # last part of identifier
          )
          \b
          (?! # infix operator
            \s+
              (?:[\p{P}\p{S}&&[^,;'"`\\({\[)}\]\p{Pc}]]+
              (?:[\p{P}\p{S}]*
                [\p{P}\p{S}&&[^,;'"`\\({\[)}\]\p{Pc}]]+
              )?
              (?=\s|$)
            )
          )
          (?! # function name
            \s+ \\ # infix function operator
                [\p{P}\p{S}&&[^.,;'"`/\\({\[)}\]\p{Pc}]]* # prefix operators except slashes
                (?: ['"`\w] | \#?[(\[{]) # literal or opening bracket
          )
          (?! # function name
            \s*\b
            # ignore all keywords
            (?!
              (?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b
              (?: # keywords
                # wordlike operators
                [io]n|off?|[ai]s|has|new|old|del|(?:de)?ref|to
                |(?:un)?[gs]et|n?and|x?n?or|c?n?imply|not|by

                # declaration keywords
                |va[rl]|dyn|mut|let|const
                |func|pro[pc]|type|class|actor|trait|enum|in?ter
                |module|schema|struct|record|object|union|macro
                |query|quote|style|script|entity|temp|oper|realm

                # control flow keywords
                |if|else|[tw]hen|guard|with|unless
                |for|while|loop|goto|break|skip|redo|until
                |try|switch|[cm]atch|case|def|throw|raise|error
                |return|yield|await|move|goto|pass|defer
                |[gd]o|from|where|(?:im|ex)(?:port|tern)

                # miscellaneous keywords
                |debug|assert|check|decl
                |use|echo|eval|expr|scope
                |begin|end|prev|next
              ) \b
            )
            \b[\p{Pc}\p{L}]\w*\b # identifier
            : (?: \s* (?: [,;'"`)}\]\w\s] | \#?[(\[{]|\\.) | $) # postfix colon or delimiter
          )
          (?=
              (?:(?:[?!]|[?!:]:|[?!-]>)=?)? \#? [({] # C-style function call
            | (?:(?:[?!]|[?!:]:|[?!-]>)=?)? < [\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]* (?:['"`\w]|\#?[(\[{]) # generics
            | [!~] \#? [({] # macro and destructor calls
            | \s* (?:\w*|[\\$\#%]*)['"] # quoted string literals
            | \s*`\N # unquoted string literals
            | \s+ :[\p{Pc}\p{L}]\w* # symbols
            | \s*\b\d # numbers
            | \s+ \#? [(\[] # opening brackets
            | \s+ [\p{P}\p{S}&&[^.,;'"`/\\({\[)}\]\p{Pc}]] # prefix operators except slashes
                  [\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]* # followed by other operators
                  (?: ['"`\w] | \#?[(\[{]) # literal or opening bracket
            | \s+ # XML tag component name or splice expression
                <[\p{Pc}\p{L}(\[{$]
            | \s+ # regexp literal
                /['"`\w\\(\[{]
            | \s+ \|(?: \#?[(\[{] )? # opening bracket
                (?: [;,] \s* )* # optional separators
                (?:
                  ((?:[*&%@^!~?\\\-+]|\.{3})*) # any sigils
                  (\b[\p{Pc}\p{L}]\w*\b) # identifier
                  ([!?]*) # optional sigils
                  \s*
                )
            | \s+[\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]* # followed by other operators
              (?: # identifier
                # ignore all keywords
                (?!
                  (?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b
                  (?: # keywords
                    # wordlike operators
                    [io]n|off?|[ai]s|has|new|old|del|(?:de)?ref|to
                    |(?:un)?[gs]et|n?and|x?n?or|c?n?imply|not|by

                    # declaration keywords
                    |va[rl]|dyn|mut|let|const
                    |func|pro[pc]|type|class|actor|trait|enum|in?ter
                    |module|schema|struct|record|object|union|macro
                    |query|quote|style|script|entity|temp|oper|realm

                    # control flow keywords
                    |if|else|[tw]hen|guard|with|unless
                    |for|while|loop|goto|break|skip|redo|until
                    |try|switch|[cm]atch|case|def|throw|raise|error
                    |return|yield|await|move|goto|pass|defer
                    |[gd]o|from|where|(?:im|ex)(?:port|tern)

                    # miscellaneous keywords
                    |debug|assert|check|decl
                    |use|echo|eval|expr|scope
                    |begin|end|prev|next
                  )
                  \b
                )
                (?:
                  \b[\p{Pc}\p{L}]\w*\b # identifier
                  (?:(?:[?!]?\.|[?!:]:|[?!-]>)=?) # qualified name separator
                )*
                [\p{Pc}\p{L}]\w* # last part of identifier
              )
              \s*\b[\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]* # followed by other operators
          )
        captures:
          1:
            name: meta.function.name.ruko
            patterns: [include: '#function-names']
      - comment: Piped function calls
        name: meta.function.arguments.ruko
        match: |-
          (?x)
          (?<=
              \s+ (?:\|[-=]?>|\+>) \s+ # infix operator
            | \b  (?:\|[-=]?>|\+>) \b  # primary operator
          )
          \b
          (
            # ignore all keywords
            (?!
              (?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b
              (?: # keywords
                # wordlike operators
                [io]n|off?|[ai]s|has|new|old|del|(?:de)?ref|to
                |(?:un)?[gs]et|n?and|x?n?or|c?n?imply|not|by

                # declaration keywords
                |va[rl]|dyn|mut|let|const
                |func|pro[pc]|type|class|actor|trait|enum|in?ter
                |module|schema|struct|record|object|union|macro
                |query|quote|style|script|entity|temp|oper|realm

                # control flow keywords
                |if|else|[tw]hen|guard|with|unless
                |for|while|loop|goto|break|skip|redo|until
                |try|switch|[cm]atch|case|def|throw|raise|error
                |return|yield|await|move|goto|pass|defer
                |[gd]o|from|where|(?:im|ex)(?:port|tern)

                # miscellaneous keywords
                |debug|assert|check|decl
                |use|echo|eval|expr|scope
                |begin|end|prev|next
              ) \b
            )
            (?:
              \b[\p{Pc}\p{L}]\w*\b # identifier
              (?:(?:[?!]?\.|[?!:]:|[?!-]>)=?) # qualified name separator
            )*
            [\p{Pc}\p{L}]\w* # last part of identifier
          )
          \b
        captures:
          1:
            name: meta.function.name.ruko
            patterns: [include: '#function-names']

  embedded-function-calls:
    name: meta.function.name.ruko
    match: |-
      (?x)
      (?:
        (?<=
          (?:^ | [,;'"`)\]}\w\s] | \#?[(\[{] | \\.) # literal, bracket or space
          (?:[?!]?\.|[?!:]:|[?!-]>)=? # accessor or qualified name separator
        )
        \b # methods
          (?:
              (\p{Pc}+\w*(?!\p{Pc}+)\b) # Leading underscore
            | ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*) # Screaming snake case
            | ((?:[\p{Pc}\p{L}&&\P{Ll}][\w&&\P{Lu}]*)+) # Pascal case
            | ([\p{Pc}\p{L}]\w*) # Camel or snake case
          )
        \b
        (?= 
            [!~]? \#? [({] # opening macro, destructor, or function call
          | (?: [?!]?\. | [?!:]: | [?!-]> ) < # generics
        )
        |
        (?<= ^ # beginning of line
          | (?: [,;'"`)}\]\w\s] | \#?[(\[{] | \\.) # literal
          (?: # operators
            [\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]+
          )?
        ) \b
          (?: # Regular variables
              (\p{Pc}+\w*(?!\p{Pc}+)\b) # Leading underscore
            | ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*) # Screaming snake case
            | ((?:[\p{Pc}\p{L}&&\P{Ll}][\w&&\P{Lu}]*)+) # Pascal case
            | ([\p{Pc}\p{L}]\w*) # Camel or snake case
          )
        \b
          (?=  
              [!~]? \#? [({] # opening macro, destructor, or function call
            | (?: [?!]?\. | [?!:]: | [?!-]> ) < # generics
          )
      )
    captures:
      1:
        patterns: &builtin-names
          - include: '#type-names'
          - include: '#support-functions'
        name: entity.name.tag.directive.ruko
      2:
        name: entity.name.function.tagged-template.ruko
        patterns: *builtin-names
      3:
        name: entity.name.function.method.ruko
        patterns: *builtin-names
      4:
        name: entity.name.function.member.ruko
        patterns: *builtin-names
      5:
        name: entity.name.tag.function.ruko
        patterns: *builtin-names
      6:
        name: entity.name.subroutine.ruko
        patterns: *builtin-names
      7:
        name: entity.name.instance.ruko
        patterns: *builtin-names
      8:
        name: entity.name.function.ruko
        patterns: *builtin-names

  function-names:
    patterns:
      - &function-names
        name: meta.function.name.ruko
        match: |-
          (?x)
          (?:
            (?<=
              (?: [,;'"`)\]}\w] | \#?[(\[{] | \\.?) # literal, bracket or space
              (?:[?!]?\.|[?!:]:|[?!-]>)=? # accessor or qualified name separator
            )
            \b # methods
              (?:
                  (\p{Pc}+\w*(?!\p{Pc}+)\b) # Leading underscore
                | ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*) # Screaming snake case
                | ((?:[\p{Pc}\p{L}&&\P{Ll}][\w&&\P{Lu}]*)+) # Pascal case
                | ([\p{Pc}\p{L}]\w*) # Camel or snake case
              )
            \b
            (?=
                $ # end of line
              | (?: <\|{1,3} | <[-+] | \|{1,3}> | \+> )? # operators
                (?:[,;'"`)}\]\w\s] | \#?[(\[{] | \\.)
            )
            |
            (?<=
              (?: ^ | [,;'"`)}\]\w\s] | \#?[(\[{] | \\.) # literal, bracket or space
              [\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]* # operators
            ) \b
              (?: # Regular variables
                  (\p{Pc}+\w*(?!\p{Pc}+)\b) # Leading underscore
                | ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*) # Screaming snake case
                | ((?:[\p{Pc}\p{L}&&\P{Ll}][\w&&\P{Lu}]*)+) # Pascal case
                | ([\p{Pc}\p{L}]\w*) # Camel or snake case
              )
            \b
              (?=
                  $ # end of line
                | (?: <\|{1,3} | <[-+] | \|{1,3}> | \+> )? # operators
                  (?:[,;'"`)}\]\w\s] | \#?[(\[{] | \\.)
              )
          )
        captures:
          1:
            name: entity.name.tag.directive.ruko
            patterns: *builtin-names
          2:
            name: entity.name.function.tagged-template.ruko
            patterns: *builtin-names
          3:
            name: entity.name.function.method.ruko
            patterns: *builtin-names
          4:
            name: entity.name.function.member.ruko
            patterns: *builtin-names
          5:
            name: entity.name.tag.function.ruko
            patterns: *builtin-names
          6:
            name: entity.name.subroutine.ruko
            patterns: *builtin-names
          7:
            name: entity.name.instance.ruko
            patterns: *builtin-names
          8:
            name: entity.name.function.ruko
            patterns: *builtin-names
      - include: '#variables'
      - include: '#interfix-operators'

  # Variables

  call-arguments:
    patterns:
      - applyEndPatternLast: true
        begin: (?<=(?:(?:[)}\]\w'"`]|\\.)[!?]?>*)*)(:)(?=$|<*(?:['"`\w\s]|\#?[(\[{]))
        end: (?=)|$
        beginCaptures:
          1: { name: punctuation.definition.annotation.ruko }
        name: meta.type.ruko
        patterns: [include: '#types']
      - match: |-
          (?x)
          (?<=
            (?:
              ^ # start of line
              | (?:^ | [^|]) \| # open pipe
              | \#?[({\[] # open bracket
              | [;,] # separator
              | [(|]\. \s # uncurried function
              | (?:^ | [,;'"`)}\]\s] | \#?[(\[{] | \\.) # literal, bracket or space
                \b (?: # declaration keywords
                  va[rl]|dyn|mut|let|const
                  |func|pro[pc]|type|class|actor|trait|enum|in?ter
                  |module|schema|struct|record|object|union|macro
                  |query|quote|style|script|entity|temp|oper|realm
                ) \b
                (?:$|[,;'"`)}\]\s] | \#?[(\[{] | \\.)
            ) \s*
          )

          (?:
            \s*
            ([*&%@^!~?\\\-+]*) # any sigils
            (\b[\p{Pc}\p{L}]\w*\b) # identifier
            ([!?]*) # optional sigils
            \s*
          )*

          (?:
            \s*
            ((?:[*&%@^!~?\\\-+]|\.{3})*) # any sigils
            (\b[\p{Pc}\p{L}]\w*\b) # identifier
            ([!?]*) # optional sigils
            \s*
          )

          (?=
            $ | \s* (?: # end of line
              | [)}\]] # close bracket or pipe
              | \|:? (?:$|['"`<\w\s)\]}]|\#?[(\[{]|\\.) # pipe
              | [;,] # separator
              | (?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(as)\b # as keyword (aliasing)
              | \s (?::|[?:]?=) \s+ (?:[*&%@^!~?\\\-+]*) (?:['"`\w]|\#?[(\[{]) # type specifier and assignment
            )
          )
        captures:
          1:
            name: keyword.operator.prefix.ruko
            patterns: [include: '#parameter-type-operators']
          2:
            name: storage.type.ruko
            patterns:
              - include: '#declaration-keywords'
              - include: '#modifiers'
          3:
            name: keyword.operator.suffix.ruko
            patterns: [include: '#parameter-type-operators']
          4:
            name: keyword.operator.prefix.ruko
            patterns: [include: '#parameter-type-operators']
          5:
            name: variable.parameter.ruko
            patterns: [include: '#constants']
          6:
            name: keyword.operator.suffix.ruko
            patterns: [include: '#parameter-type-operators']
        name: meta.binding-pattern.ruko

  call-parameters:
    match: |-
      (?x)
      (?<=
        (?:
          ^ # start of line
          | (?:^ | [^|]) \| # open pipe
          | \#?[({\[] # open bracket
          | [;,] # separator
          | [(|]\. \s # uncurried function
          | (?:^ | [,;'"`)}\]\s] | \#?[(\[{] | \\.) # literal, bracket or space
            \b (?: # declaration keywords
              va[rl]|dyn|mut|let|const
              |func|pro[pc]|type|class|actor|trait|enum|in?ter
              |module|schema|struct|record|object|union|macro
              |query|quote|style|script|entity|temp|oper|realm
            ) \b
            (?:$|[,;'"`)}\]\s] | \#?[(\[{] | \\.)
        ) \s*
      )

      (?:
        \s*
        ([*&%@^!~?\\\-+]*) # any sigils
        (\b[\p{Pc}\p{L}]\w*\b) # identifier
        ([!?]*) # optional sigils
        \s*
      )*

      (?:
        \s*
        ((?:[*&%@^!~?\\\-+]|\.{3})*) # any sigils
        (\b[\p{Pc}\p{L}]\w*\b) # identifier
        ([!?]*) # optional sigils
        \s*
      )

      (:)(?=$|<*(?:['"`\w\s]|\#?[(\[{]))
    captures:
      1:
        name: keyword.operator.prefix.ruko
        patterns: [include: '#parameter-type-operators']
      2:
        name: storage.type.ruko
        patterns:
          - include: '#declaration-keywords'
          - include: '#modifiers'
      3:
        name: keyword.operator.suffix.ruko
        patterns: [include: '#parameter-type-operators']
      4:
        name: keyword.operator.prefix.ruko
        patterns: [include: '#parameter-type-operators']
      5:
        name: variable.parameter.ruko
        patterns: [include: '#constants']
      6:
        name: keyword.operator.suffix.ruko
        patterns: [include: '#parameter-type-operators']
      7: { name: punctuation.definition.key-value.ruko }
    name: meta.binding-pattern.ruko

  variables:
    patterns:
      - applyEndPatternlast: true
        begin: |-
          (?x)
          (?<=
            \b[\p{Pc}\p{L}]\w*\b # identifier
            (?:[?!]?\.|[?!:]:|[?!-]>)=
          )
          ([+-])?
          (?=\d\w*) # number literal
        end: (?=)|$
        name: variable.other.index.ruko
        captures:
          1: { name: keyword.operator.arithmetic.ruko }
        patterns: [include: '#numbers']
      - match: |-
          (?x)\b

          (?:
            (?<=
              (?: ['"`)\]}\w] | \\.) \s* # literal, bracket or space
              (?:[?!]?\.|[?!:]:|[?!-]>)=? # accessor or qualified name separator
            )
            \b # methods
            (?: # Properties
                (\p{Pc}+\w*(?!\p{Pc}+)\b) # Leading underscore
              | ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*) # Screaming snake case
              | ((?:[\p{Pc}\p{L}&&\P{Ll}][\w&&\P{Lu}]*)+) # Pascal case
              | ([\p{Pc}\p{L}]\w*) # Camel or snake case
            )
            |
            (?<!
              (?: [,;'"`)}\]\w] | \\.) # literal, bracket or space
              (?: [\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]+ ) # operators
            )
            \b
            (?: # Objects
                (\p{Pc}+\w*(?!\p{Pc}+)\b) # Leading underscore
              | ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*) # Screaming snake case
              | ((?:[\p{Pc}\p{L}&&\P{Ll}][\w&&\P{Lu}]*)+) # Pascal case
              | ([\p{Pc}\p{L}]\w*) # Camel or snake case
            )
            (?! [?!]?\.\.+ ) # not a range operator
            (?=
                (?:[?!]?\.|[?!:]:|[?!-]>)=? # accessor or qualified name separator
              | \#?\[ # or array access
            )
            |
            (?: # Regular variables
                (\p{Pc}+\w*(?!\p{Pc}+)\b) # Leading underscore
              | ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*) # Screaming snake case
              | ((?:[\p{Pc}\p{L}&&\P{Ll}][\w&&\P{Lu}]*)+) # Pascal case
              | ([\p{Pc}\p{L}]\w*) # Camel or snake case
            )
          )\b
        captures:
          1: { name: variable.other.property.dynamic.ruko }
          2: { name: variable.other.constant.property.ruko }
          3: { name: variable.other.property.static.ruko }
          4: { name: variable.other.property.ruko }
          5: { name: variable.other.global.ruko }
          6: { name: variable.other.constant.object.ruko }
          7: { name: variable.other.class.static.ruko }
          8: { name: variable.other.object.ruko }
          9: { name: variable.other.dollar.ruko }
          10: { name: variable.other.constant.ruko }
          11: { name: variable.other.class.ruko }
          12: { name: variable.other.readwrite.ruko }
        name: meta.variable.ruko

  # Operators

  operators:
    patterns:
      - include: '#named-infix-operators'
      - include: '#special-operators'
      - include: '#infix-operators'
      - include: '#interfix-operators'
      - include: '#suffix-operators'
      - include: '#prefix-operators'

  special-operators:
    patterns:
      - match: (?<=(?:^|[,;]|\#?[(\[{])\s*)(\.{3})(?=[\p{P}\p{S}&&[^,;'"`\\({\[)}\]\p{Pc}]]*(?:['"`\w]|\#?[(\[{]))
        captures:
          1: { name: keyword.operator.spread.ruko }
      - match: (?<=>|\w)(!)(?=\#?[({])
        captures:
          1: { name: keyword.operator.macro.ruko }
      - match: (?<=>|\w)(~)(?=\#?[({])
        captures:
          1: { name: keyword.operator.destructor.ruko }

  named-infix-operators:
    comment: 'Named infix operators: x \fn\ y'
    contentName: keyword.operator.infix.named.ruko
    begin: (?<=['"`)}\]\w\s]|\\.)(\\)\s*
    end: \s*(\\)(?=$|['"`\w\s]|\#?[(\[{])
    captures:
      1: { name: punctuation.definition.operator.ruko }
    patterns:
      - match: (?<=\\?)([?!:]:|[?!]?\.|[?!-]>)([\p{Pc}\p{L}]\w*)(?!(?:[?!:]:|[?!]?\.|[?!-]>))
        captures:
          1:
            name: punctuation.separator.accessor.ruko
            patterns: [include: '#accessor-operators']
          2:
            name: entity.name.function.member.ruko
            patterns: [include: '#function-names']
      - match: |-
          (?x)
          (?<=\\?)
          ( # function name
            \b
            # ignore all keywords
            (?!
              (?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b
              (?: # keywords
                # wordlike operators
                [io]n|off?|[ai]s|has|new|old|del|(?:de)?ref|to
                |(?:un)?[gs]et|n?and|x?n?or|c?n?imply|not|by

                # declaration keywords
                |va[rl]|dyn|mut|let|const
                |func|pro[pc]|type|class|actor|trait|enum|in?ter
                |module|schema|struct|record|object|union|macro
                |query|quote|style|script|entity|temp|oper|realm

                # control flow keywords
                |if|else|[tw]hen|guard|with|unless
                |for|while|loop|goto|break|skip|redo|until
                |try|switch|[cm]atch|case|def|throw|raise|error
                |return|yield|await|move|goto|pass|defer
                |[gd]o|from|where|(?:im|ex)(?:port|tern)

                # miscellaneous keywords
                |debug|assert|check|decl
                |use|echo|eval|expr|scope
                |begin|end|prev|next
              ) \b
            )
            \b[\p{Pc}\p{L}]\w*\b # identifier
          )
          (?=\\)
        captures:
          1:
            name: entity.name.function.ruko
            patterns: [include: '#function-names']
      - include: '#operators'
      - include: $self

  infix-operators:
    comment: Infix operators - e.g., x + y
    match: |
      (?x)
      (?<=^|[\s({\[])(?:
          ( [\p{P}\p{S}&&[^~<=>.,:;!''"`({\[)}\]\p{Pc}]][\p{P}\p{S}&&[^,;''"`({\[)}\]\p{Pc}]]*= ) # compound assignment
        | ( \?[.:>] ) # optional
        | ( ![.:>] ) # mandatory
        | ( (?:\.|::|->) ) # accessors
        | ( &&|\|\||\^\^|§§|¦¦|¤¤|\#\#|¶¶ ) # logical
        | ( [&|^§¦¤#¶] ) # bitwise
        | ( <<[<>]?|[<>]?>> ) # bitwise shift
        | ( \+\+|--|××|÷÷|%%|\# ) # string
        | ( [+\-×÷][%|]?|\*\*?[%|]?|~?/|%%? ) # arithmetic
        | ( <[-=]?\||\|[-=]?> ) # pipeline
        | ( <\+|\+>|∘ ) # compose
        | ( [<>][:!]|[:!][<>] ) # class
        | ( [>.]\.[.<]|[=.]\.[.=]|\.\. ) # range
        | ( [<>]=?|<=?> ) # relational
        | ( \.\.+|··+ ) # dots
        | ( [!=]==? ) # comparison
        | ( ~[=!]|[=!]~|[=>]< ) # similarity
        | ( <[/*|+$:]>?|[/*|+$:]> ) #
        | ( \?\?\?? ) # null-coalescing
        | ( !!!? ) # coalescing
        | ( \?:? ) # conditional
        | ( !:? ) # ternary
        | ( [.:$]|:::? ) # macro
        | ( :?:?= ) # assignment
        | ( ==?>|<== ) # fat arrow
        | ( --?>|<--? ) # thin arrow
        | ( ~~?>|<~~? ) # wavy arrow
        | ( \p{Sm}+ ) # math symbols
        | ( \p{Sc}+ ) # currency symbols
        | ( [!#-&*+\-./:-@\\^|~¡-©«-±´¶·¸»¿×÷]+ ) # ascii operators
        | ( [\p{In_Arrows}\p{In_Supplemental_Arrows_A}\p{In_Supplemental_Arrows_B}\p{In_Supplemental_Arrows_C}\p{In_Miscellaneous_Symbols_and_Arrows}]+ ) # arrow-like
        | ( [\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]+ ) # other operators
      )(?=$|[)}\]\s])
    captures:
      1: { name: keyword.operator.assignment.augmented.ruko }
      2: { name: keyword.operator.optional.ruko }
      3: { name: keyword.operator.unwrap.ruko }
      4: { name: keyword.operator.accessor.ruko }
      5: { name: keyword.operator.logical.ruko }
      6: { name: keyword.operator.bitwise.ruko }
      7: { name: keyword.operator.bitwise.shift.ruko }
      8: { name: keyword.operator.successor.ruko }
      9: { name: keyword.operator.arithmetic.ruko }
      10: { name: keyword.operator.pipeline.ruko }
      11: { name: keyword.operator.compose.ruko }
      12: { name: keyword.operator.class.ruko }
      13: { name: keyword.operator.range.ruko }
      14: { name: keyword.operator.relational.ruko }
      15: { name: keyword.operator.dots.ruko }
      16: { name: keyword.operator.comparison.ruko }
      17: { name: keyword.operator.similarity.ruko }
      18: { name: keyword.operator.special.ruko }
      19: { name: keyword.operator.null-coalescing.ruko }
      20: { name: keyword.operator.coalescing.ruko }
      21: { name: keyword.operator.conditional.ruko }
      22: { name: keyword.operator.ternary.ruko }
      23: { name: keyword.operator.macro.ruko }
      24: { name: keyword.operator.assignment.ruko }
      25: { name: keyword.operator.arrow.fat.ruko }
      26: { name: keyword.operator.arrow.thin.ruko }
      27: { name: keyword.operator.arrow.wavy.ruko }
      28: { name: keyword.operator.math.custom.ruko }
      29: { name: keyword.operator.currency.custom.ruko }
      30: { name: keyword.operator.ascii.ruko }
      31: { name: keyword.operator.arrow.ruko }
      32: { name: keyword.operator.infix.ruko }

  interfix-operators:
    comment: Interfix operators - x+y (without spaces)
    match: |
      (?x)
      (?<=['"`)}\]\w]|\\.)(?:
          ( [\p{P}\p{S}&&[^~<=>.,:;!''"`({\[)}\]\p{Pc}]][\p{P}\p{S}&&[^,;''"`({\[)}\]\p{Pc}]]*= ) # compound assignment
        | ( \?[.:>] ) # optional
        | ( ![.:>] ) # mandatory
        | ( (?:\.|::|->) ) # accessors
        | ( &&|\|\||\^\^|§§|¦¦|¤¤|\#\#|¶¶ ) # logical
        | ( [&|^§¦¤#¶] ) # bitwise
        | ( <<[<>]?|[<>]?>> ) # bitwise shift
        | ( \+\+|--|××|÷÷|%%|\# ) # string
        | ( [+\-×÷][%|]?|\*\*?[%|]?|~?/|%%? ) # arithmetic
        | ( <[-=]?\||\|[-=]?> ) # pipeline
        | ( <\+|\+>|∘ ) # compose
        | ( [<>][:!]|[:!][<>] ) # class
        | ( [>.]\.[.<]|[=.]\.[.=]|\.\. ) # range
        | ( [<>]=?|<=?> ) # relational
        | ( \.\.+|··+ ) # dots
        | ( [!=]==? ) # comparison
        | ( ~[=!]|[=!]~|[=>]< ) # similarity
        | ( <[/*|+$:]>?|[/*|+$:]> ) #
        | ( \?\?\?? ) # null-coalescing
        | ( !!!? ) # coalescing
        | ( \?:? ) # conditional
        | ( !:? ) # ternary
        | ( [.:$]|:::? ) # macro
        | ( :?:?= ) # assignment
        | ( ==?>|<== ) # fat arrow
        | ( --?>|<--? ) # thin arrow
        | ( ~~?>|<~~? ) # wavy arrow
        | ( \p{Sm}+ ) # math symbols
        | ( \p{Sc}+ ) # currency symbols
        | ( [!#-&*+\-./:-@\\^|~¡-©«-±´¶·¸»¿×÷]+ ) # ascii operators
        | ( [\p{In_Arrows}\p{In_Supplemental_Arrows_A}\p{In_Supplemental_Arrows_B}\p{In_Supplemental_Arrows_C}\p{In_Miscellaneous_Symbols_and_Arrows}]+ ) # arrow-like
        | ( [\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]+ ) # other operators
      )(?=(?:['"`\w]|\#?[(\[{]))
    captures:
      1: { name: keyword.operator.assignment.augmented.ruko }
      2: { name: keyword.operator.optional.ruko }
      3: { name: keyword.operator.unwrap.ruko }
      4: { name: keyword.operator.accessor.ruko }
      5: { name: keyword.operator.logical.ruko }
      6: { name: keyword.operator.bitwise.ruko }
      7: { name: keyword.operator.bitwise.shift.ruko }
      8: { name: keyword.operator.successor.ruko }
      9: { name: keyword.operator.arithmetic.ruko }
      10: { name: keyword.operator.pipeline.ruko }
      11: { name: keyword.operator.compose.ruko }
      12: { name: keyword.operator.class.ruko }
      13: { name: keyword.operator.range.ruko }
      14: { name: keyword.operator.relational.ruko }
      15: { name: keyword.operator.dots.ruko }
      16: { name: keyword.operator.comparison.ruko }
      17: { name: keyword.operator.similarity.ruko }
      18: { name: keyword.operator.special.ruko }
      19: { name: keyword.operator.null-coalescing.ruko }
      20: { name: keyword.operator.coalescing.ruko }
      21: { name: keyword.operator.conditional.ruko }
      22: { name: keyword.operator.ternary.ruko }
      23: { name: keyword.operator.macro.ruko }
      24: { name: keyword.operator.assignment.ruko }
      25: { name: keyword.operator.arrow.fat.ruko }
      26: { name: keyword.operator.arrow.thin.ruko }
      27: { name: keyword.operator.arrow.wavy.ruko }
      28: { name: keyword.operator.math.custom.ruko }
      29: { name: keyword.operator.currency.custom.ruko }
      30: { name: keyword.operator.ascii.ruko }
      31: { name: keyword.operator.arrow.ruko }
      32: { name: keyword.operator.interfix.ruko }

  prefix-operators:
    comment: Prefix operators
    match: ([\p{P}\p{S}&&[^,;'"`\\({\[)}\]\p{Pc}]])(?=[\p{P}\p{S}&&[^,;'"`\\({\[)}\]\p{Pc}]]*(?:['"`\w]|\#?[(\[{]))
    name: keyword.operator.prefix.ruko
    captures:
      1:
        patterns:
          - match: \*
            name: keyword.operator.pointer.ruko
          - match: /
            name: keyword.operator.spread.ruko # not captured, begins regexp
          - match: \+
            name: keyword.operator.increment.ruko
          - match: '-'
            name: keyword.operator.decrement.ruko
          - match: '&'
            name: keyword.operator.reference.ruko
          - match: \|
            name: keyword.operator.union.ruko # not captured, begins lambda
          - match: \^
            name: keyword.operator.borrow.ruko
          - match: '!'
            name: keyword.operator.logical.ruko
          - match: \$\b
            name: punctuation.definition.variable.ruko # sigil
          - match: \$
            name: keyword.operator.variable.ruko
          - match: '@\b'
            name: punctuation.definition.decorator.ruko # sigil
          - match: '@'
            name: keyword.operator.decorator.ruko
          - match: '~'
            name: keyword.operator.bitwise.ruko
          - match: \?
            name: keyword.operator.existential.ruko
          - match: =
            name: keyword.operator.assignment.ruko
          - match: '#\b'
            name: punctuation.definition.anchor.ruko # sigil
          - match: '#'
            name: keyword.operator.anchor.ruko
          - match: '%'
            name: keyword.operator.private.ruko
          - match: \.
            name: keyword.operator.accessor.ruko
          - match: \\
            name: keyword.operator.lifetime.ruko # not captured, begins named infix operator

  suffix-operators:
    comment: Suffix operators
    match: (?<=(?:['"`)}\]\w]|\\.)[\p{P}\p{S}&&[^,;'"`\\({\[)}\]\p{Pc}]]*)([\p{P}\p{S}&&[^,;'"`\\({\[)}\]\p{Pc}]])
    name: keyword.operator.suffix.ruko
    captures:
      1:
        patterns:
          - match: \*
            name: keyword.operator.pointer.ruko
          - match: /
            name: keyword.operator.spread.ruko
          - match: \+
            name: keyword.operator.increment.ruko
          - match: '-'
            name: keyword.operator.decrement.ruko
          - match: '&'
            name: keyword.operator.reference.ruko
          - match: \|
            name: keyword.operator.union.ruko
          - match: \^
            name: keyword.operator.borrow.ruko
          - match: '!'
            name: keyword.operator.unwrap.ruko
          - match: \$
            name: keyword.operator.variable.ruko
          - match: '@'
            name: keyword.operator.decorator.ruko
          - match: '~'
            name: keyword.operator.bitwise.ruko
          - match: \?
            name: keyword.operator.optional.ruko
          - match: =
            name: keyword.operator.assignment.ruko
          - match: '#'
            name: keyword.operator.anchor.ruko
          - match: '%'
            name: keyword.operator.private.ruko
          - match: \.
            name: keyword.operator.accessor.ruko
          - match: \\
            name: keyword.operator.lifetime.ruko

  # Clauses and Keywords

  parameter-brackets:
    begin: (\()\s*
    end: \s*(\))
    captures:
      1: { name: punctuation.definition.parameters.ruko }
    patterns:
      - include: '#binding-pattern'
      - include: $self

  modifier-keywords:
    name: storage.modifier.ruko
    match: |-
      (?x)
      (
        (?:
          (?:
          \s*
            (?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b
            [\p{Pc}\p{L}]\w*
          )
          \b\s*
        )*
      )
      (?=
        \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b
        (?: # declaration keywords
          va[rl]|dyn|mut|let|const
          |func|pro[pc]|type|class|actor|trait|enum|in?ter
          |module|schema|struct|record|object|union|macro
          |query|quote|style|script|entity|temp|oper|realm
        ) 
        \b\s*
      )
    captures:
      1: { patterns: [include: '#modifiers'] }

  type-modifiers:
    patterns:
      - name: storage.modifier.ruko
        match: |-
          (?x)
          \s*\b
          (
            # ignore all keywords
            (?!
              (?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b
              (?: # keywords
                # wordlike operators
                [io]n|off?|[ai]s|has|new|old|del|(?:de)?ref|to
                |(?:un)?[gs]et|n?and|x?n?or|c?n?imply|not|by

                # declaration keywords
                |va[rl]|dyn|mut|let|const
                |func|pro[pc]|type|class|actor|trait|enum|in?ter
                |module|schema|struct|record|object|union|macro
                |query|quote|style|script|entity|temp|oper|realm

                # control flow keywords
                |if|else|[tw]hen|guard|with|unless
                |for|while|loop|goto|break|skip|redo|until
                |try|switch|[cm]atch|case|def|throw|raise|error
                |return|yield|await|move|goto|pass|defer
                |[gd]o|from|where|(?:im|ex)(?:port|tern)

                # miscellaneous keywords
                |debug|assert|check|decl
                |use|echo|eval|expr|scope
                |begin|end|prev|next
              ) \b
            )
            \b[\p{Pc}\p{L}]\w*\b # identifier
          )
          \b\s*
          (?=
            (?!
              (?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b
              (?: # keywords
                # wordlike operators
                [io]n|off?|[ai]s|has|new|old|del|(?:de)?ref|to
                |(?:un)?[gs]et|n?and|x?n?or|c?n?imply|not|by

                # declaration keywords
                |va[rl]|dyn|mut|let|const
                |func|pro[pc]|type|class|actor|trait|enum|in?ter
                |module|schema|struct|record|object|union|macro
                |query|quote|style|script|entity|temp|oper|realm

                # control flow keywords
                |if|else|[tw]hen|guard|with|unless
                |for|while|loop|goto|break|skip|redo|until
                |try|switch|[cm]atch|case|def|throw|raise|error
                |return|yield|await|move|goto|pass|defer
                |[gd]o|from|where|(?:im|ex)(?:port|tern)

                # miscellaneous keywords
                |debug|assert|check|decl
                |use|echo|eval|expr|scope
                |begin|end|prev|next
              ) \b
            )
            [\p{Pc}\p{L}]\w*
          )
        captures:
          1: { patterns: [include: '#modifiers'] }

  modifiers:
    patterns:
      - comment: Access modifiers
        match: |-
          (?x)\s*\b
          (?:
            # abbreviated
            pub|priv|prot|fin|read|writ|ovrd|ovld
            |glob|loc|int|ext|mut|immt|mutl|init
            |const|var|dyn|stat|shr|uniq|ali|auto
            |post|get|set|put|del|req|opt|shr|stab
            |safe|unsf|virt|seal|abst|frnd|enmy|refl
            |inln|noil|cros|natv|embd|host|targ
            # full
            |final|write|override|overload
            |global|local|intern|extern|immutable|mutual
            |static|shared|unique|alias|unsafe|reflect
            |inline|noinline|cross|native|embed|host|target
          ) \b\s*
        name: storage.modifier.ruko
      - comment: Storage modifiers
        match: |-
          (?x)\s*\b
          (?:
            # abbreviated
            in|out|inout|inpl|ref|defr|asyn|sync
            |stat|dyn|lazy|eagr|bnd|free|uniq
            |unio|open|clos|seal|part|comp|appr
            |tran|vola|pers|temp|cach|auto
            |cros|natv|embd|host|targ|thrd
            |gloc|glob|remo|clus|dist|grid
            |atom|nomi|stru|cova|cont
            |shr|copy|move|borr|ownd|weak|soft
            # full
            |inplace|defer|lazy|eager|bound|unique|union|closed
            |approx|trans|volat|persist|temp|cache|cross|native|embed|host|target|thread
            |glocal|local|global|remote|cluster|dist|grid|atomic|nominal|struct
            |covariant|contravariant|shared|borrow|owned
          ) \b\s*
        name: storage.modifier.declaration.ruko
      - comment: Functional modifiers
        match: |-
          (?x)\s*\b
          (?:
            # abbreviated
            rec|gen|opr|curr|opaq|tail|macro|debug|trace
            |part|var|null|opt|rest|sprd|fold|unfld
            |coro|hook|evt|sig|slot|filt|asp|adv
            |getr|setr|bldr|ctor|dtor|meth|acc
            |prop|fld|attr|memb|evt|hndlr|stat
            |act|cmd|lamb|clos|cont|thnk
            |cb|prxy|adpt|wrap|deco|mon
            |fact|sing|flyw|brid|med
            |strat|tmpl|mixn|trat|role|intc
            # full
            |recursive|generic|operator|curried|opaque|tail|macro|debug|trace
            |partial|variadic|nullable|optional|rest|spread|fold|unfold
            |coroutine|hook|event|signal|slot|filter|aspect|advice
            |getter|setter|builder|constructor|destructor|method|accessor
            |property|field|attribute|member|event|handler|state
            |action|command|lambda|closure|continue|thunk
            |callback|proxy|adapter|wrapper|decorator|monitor
            |factory|singleton|flyweight|bridge|mediator
            |strategy|template|mixin|trait|role|interceptor
          )\b\s*
        name: storage.modifier.function.ruko
      - comment: Behavioral modifiers
        match: |-
          (?x)\s*\b
          (?:
            # abbreviated
            pure|imp|detm|nond
            |idemp|atom|tran|side
            |blk|nblk|conc|par
            |sync|async|react|evt
            |lazy|eager|defr|immed|prior
            |int|unint|cancel
            |recov|unrec|resil
            # full
            |pure|impure|deterministic|nondeterministic
            |idempotent|atomic|transactional|sideeffect
            |blocking|nonblocking|concurrent|parallel
            |synchronous|asynchronous|reactive|eventual
            |lazy|eager|deferred|immediate|prioritized
            |interruptible|uninterruptible|cancellable
            |recoverable|unrecoverable|resilient
          )\b\s*
        name: storage.modifier.behavior.ruko
      - comment: Inheritance modifiers
        match: |-
          (?x)\s*\b
          (?:
            # abbreviated
            ext|impl|ovrd|spec
            |mix|comp|incl|req|prov
            |inh|deriv|conf|real
            |own|borr|lend|share
            # full
            |extends|implements|overrides|specializes
            |mixes|composes|includes|requires|provides
            |inherits|derives|conforms|realizes
            |owns|borrows|lends|shares
          )\b\s*
        name: storage.modifier.inheritance.ruko
      - comment: Type modifiers
        match: |-
          (?x)\s*\b
          (?:
            # abbreviated
            null|nonn|opt|req
            |gen|conc|abst|intf
            |prim|comp|comps|enum
            |stru|unstr|dyn|stat
            |mut|immt|fix|var
            |covar|contr|invar
            |bnd|free|uniq|union
            |arr|list|set|map
            |dict|tbl|graph
            |iter|strm|chan
            |ptr|ref|slice|view
            |val|box|rc|arc|weak
            # full
            |nullable|nonnullable|optional|required
            |generic|concrete|abstract|interface
            |primitive|complex|composite|enumerated
            |structured|unstructured|dynamic|static
            |mutable|immutable|fixed|variable
            |covariant|contravariant|invariant
            |bound|free|unique|union
            |array|list|set|map
            |dictionary|table|graph
            |iterator|stream|channel
            |pointer|reference|slice|view
            |value|box|referencecounted|atomicreferencecounted|weak
          )\b\s*
        name: storage.modifier.type.ruko
      - comment: Access control modifiers
        match: |-
          (?x)\s*\b
          (?:
            # abbreviated
            pub|priv|prot|intnl|pkg
            |frnd|enmy|ro|wo|rw
            |fin|seal|open|close
            |read|writ|get|set|put|del
            |req|opt|shr|stab|safe
            # full
            |public|private|protected|internal|package
            |friend|enemy|readonly|writeonly|readwrite
            |final|sealed|open|closed
            |read|write|get|set|put|delete
            |request|optional|shared|stable|safe
          )\b\s*
        name: storage.modifier.access-control.ruko
      - comment: Annotation modifiers
        match: |-
          (?x)\s*\b
          (?:
            # abbreviated
            depr|exper|nore[pqt]
            |srl|check|debug|obsol
            |init|clnup|log|add|name
            |test|bench|todo|fixme
            |auth|ver|since|see|param
            |vararg|retval|kwarg|alias
            # full
            |deprecated|experimental|noreturn|norequire|notest
            |serial|check|debug|obsolete
            |initialize|cleanup|log|address|name
            |test|benchmark|todo|fixme
            |author|version|since|see|parameter
            |varargs|returnvalue|kwargs|alias
          )\b\s*
        name: storage.modifier.annotation.ruko
      - comment: Custom modifiers
        match: \s*\b([\p{Pc}\p{L}]\w*)\b\s*
        name: storage.modifier.specifier.ruko

  declaration-keywords:
    patterns:
      - match: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(decl)\b\s*
        name: keyword.other.declare.ruko
      - match: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(va[rl]|dyn|mut|let|const)\b\s*
        name: storage.type.ruko
      - match: |-
          (?x)
          \s*
          (?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b (?: # declaration keywords
            va[rl]|dyn|mut|let|const
            |func|pro[pc]|type|class|actor|trait|enum|in?ter
            |module|schema|struct|record|object|union|macro
            |query|quote|style|script|entity|temp|oper|realm
          ) \b\s*
        name: storage.type.$1.ruko

  general-keywords:
    comment: general keywords
    patterns:
      - match: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(if|else|when|guard|with|unless)\b\s*
        name: keyword.control.conditional.ruko
      - match: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(for|while|loop|goto|break|skip|redo|until)\b\s*
        name: keyword.control.loop.ruko
      - match: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(try|throw|catch|then|raise|error|retry)\b\s*
        name: keyword.control.trycatch.ruko
      - match: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(match|case|def)\b\s*
        name: keyword.control.match.ruko
      - match: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(switch|case|def)\b\s*
        name: keyword.control.switch.ruko
      - match: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(return|yield|await|move|goto|pass|defer)\b\s*
        name: keyword.control.flow.ruko
      - match: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b((?:im|ex)(?:port|tern))\b\s*
        name: keyword.control.module.ruko
      - match: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b([gd]o|defer|ref|deref|with|from)\b\s*
        name: keyword.control.$1.ruko
      - match: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(debug|assert|check|decl|use|echo|eval|expr|begin|end|prev|next)\b\s*
        name: keyword.other.$1.ruko
      - match: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(where)\b\s*
        name: keyword.control.validate.ruko

  expression-keywords:
    comment: expression keywords
    patterns:
      - match: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(as|old|new|by)\b\s*
        name: keyword.operator.expression.$1.ruko
      - match: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(not\s+)?([io]n|of)\b\s*
        name: keyword.operator.expression.$2.ruko
      - match: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(is\s+not|is|has\s+not|has)\b\s*
        name: keyword.operator.expression.is.ruko
      - match: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(del)\b\s*
        name: keyword.operator.expression.delete.ruko
      - match: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(unset)\b\s*
        name: keyword.operator.expression.void.ruko
      - match: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(n?and|x?n?or|c?n?imply|not)\b\s*
        name: keyword.operator.expression.logical.ruko

  keywords:
    patterns:
      - include: '#module-expression'
      - include: '#loop-expression'
      - include: '#flow-expression'
      - include: '#query-expression'
      - include: '#validation-expression'
      - include: '#extern-expression'
      - include: '#modifier-keywords'
      - include: '#declaration-keywords'
      - include: '#expression-keywords'
      - include: '#general-keywords'

  loop-expression:
    applyEndPatternLast: true
    begin: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(break|skip|redo)\b\s*
    end: (?=)|$
    beginCaptures:
      1: { name: keyword.control.loop.ruko }
    patterns:
      - match: *entity-name
        name: constant.other.label.ruko

  flow-expression:
    applyEndPatternLast: true
    begin: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(retry|goto|move|pass)\b\s*
    end: (?=)|$
    beginCaptures:
      1: { name: keyword.control.flow.ruko }
    patterns:
      - match: *entity-name
        name: constant.other.label.ruko

  extern-expression:
    applyEndPatternLast: true
    begin: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b((?:in|ex)tern)\b\s*
    end: (?=)|$
    beginCaptures:
      1: { name: keyword.control.module.ruko }
    patterns:
      - match: *entity-name
        name: constant.other.label.ruko

  module-expression:
    applyEndPatternLast: true
    begin: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b((?:im|ex)port)\b\s*
    end: (?=)|$
    beginCaptures:
      1: { name: keyword.control.module.ruko }
    patterns:
      - include: '#module-content'
      - include: '#extern-expression'

  module-content:
    patterns:
      - begin: ({)\s*
        end: \s*(})
        captures:
          1: { name: punctuation.definition.block.ruko }
        patterns:
          - include: '#module-content'
          - include: '#extern-expression'
          - include: $self
      - include: '#strings'
      - include: '#regexps'
      - include: '#symbols'
      - include: '#comments'
      - include: '#type-operators'
      - include: '#accessor-operators'
      - match: \s*(?<!:):(?!:)\s*
        name: keyword.operator.alias.ruko
      - include: '#regexp-patterns'
      - include: '#type-keywords'
      - match: \s*(?<!\*)\*(?!\*)\s*
        name: constant.language.import-export-all.ruko
      - include: '#type-modifiers'
      - include: '#comma'
      - include: '#line-continuation'
      - match: *entity-name
        name: string.unquoted.module.ruko

  validation-expression:
    comment: In validation expressions, every identifier that begins a newline
      is a keyword unless it is preceded by a dot or is a known keyword.
    begin: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(where)\b\s*
    beginCaptures:
      1: { name: keyword.control.validate.ruko }
    end: (?=[,;)}\]])
    patterns:
      - match: |-
          (?x)
          (?<=(?:^|[,;]|\#?[(\[{])\s*)
          (
            \b
            # ignore all keywords
            (?!
              (?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b
              (?: # keywords
                # wordlike operators
                [io]n|off?|[ai]s|has|new|old|del|(?:de)?ref|to
                |(?:un)?[gs]et|n?and|x?n?or|c?n?imply|not|by

                # declaration keywords
                |va[rl]|dyn|mut|let|const
                |func|pro[pc]|type|class|actor|trait|enum|in?ter
                |module|schema|struct|record|object|union|macro
                |query|quote|style|script|entity|temp|oper|realm

                # control flow keywords
                |if|else|[tw]hen|guard|with|unless
                |for|while|loop|goto|break|skip|redo|until
                |try|switch|[cm]atch|case|def|throw|raise|error
                |return|yield|await|move|goto|pass|defer
                |[gd]o|from|where|(?:im|ex)(?:port|tern)

                # miscellaneous keywords
                |debug|assert|check|decl
                |use|echo|eval|expr|scope
                |begin|end|prev|next
              ) \b
            )
            \b[\p{Pc}\p{L}]\w*\b # identifier
          )
        name: keyword.control.validate.ruko
      - include: $self

  query-expression:
    comment: RINQ (Ruko INtegrated Query) expression mini-language
    begin: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(from)\b\s*
    beginCaptures:
      1: { name: keyword.control.query.ruko }
    end: (?=[,;)}\]])
    patterns: &query-body
      - include: '#query-body'
      - include: $self

  query-body:
    patterns:
      - include: '#in-clause'
      - include: '#where-clause'
      - include: '#join-clause'
      - include: '#sort-clause'
      - include: '#select-clause'
      - include: '#group-clause'
      - include: '#take-clause'
      - include: '#reduce-clause'
      - include: '#set-clause'

  in-clause:
    begin: |-
      (?x)\s*
      (?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b
        (
          [io]n|of
        )
      \b\s*
    beginCaptures:
      1: { name: keyword.control.query.ruko }
      2: { patterns: [include: $self] }
      3: { name: keyword.control.query.ruko }
    end: (?=[,;)}\]])
    patterns:
      - include: '#query-body'
      - include: $self

  join-clause:
    begin: |-
      (?x)\s*
      (?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b
        (
             (?:inner|left|right|outer|cross)? \b\s*
          \b join
        )
      \b\s*
    beginCaptures:
      1: { name: keyword.control.query.ruko }
      2: { patterns: [include: $self] }
      3: { name: keyword.control.query.ruko }
    end: (?=[,;)}\]])
    patterns:
      - begin: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b([io]nto|[io]n|of|where)\b\s*
        end: (?=[,;)}\]])
        beginCaptures:
          1: { name: keyword.control.query.ruko }
        patterns: *query-body
      - include: '#query-body'
      - include: $self

  where-clause:
    begin: |-
      (?x)\s*
      (?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b
        (
          where|having|filter|reject
        )
      \b\s*
    beginCaptures:
      1: { name: keyword.control.query.ruko }
    end: (?=[,;)}\]])
    patterns:
      - begin: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(any|all|some|every)\b\s*
        end: (?=[,;)}\]])
        name: keyword.control.query.ruko
        patterns: *query-body
      - include: '#query-body'
      - include: $self

  sort-clause:
    begin: |-
      (?x)\s*
      (?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b
        (
             (?:sort|order|then) \b\s*
          \b (?:by|with)?
        )
      \b\s*
    beginCaptures:
      1: { name: keyword.control.query.ruko }
    end: (?=[,;)}\]])
    patterns:
      - match: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(asc|desc)\b\s*
        name: keyword.control.query.ruko
      - include: '#query-body'
      - include: $self

  select-clause:
    begin: |-
      (?x)\s*
      (?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b
        (
             (?:select|map) \b\s*
          \b (?:unique|any|all|some|every)?
        )
      \b\s*
    beginCaptures:
      1: { name: keyword.control.query.ruko }
    end: (?=[,;)}\]])
    patterns:
      - begin: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(by|with|while)\b\s*
        end: (?=[,;)}\]])
        name: keyword.control.query.ruko
        patterns: *query-body
      - include: '#query-body'
      - include: $self

  take-clause:
    begin: |-
      (?x)\s*
      (?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b
        (
             (?:take|drop|limit|offset|limit) \b\s*
          \b (?:first|last|head|tail)?
        )
      \b\s*
    beginCaptures:
      1: { name: keyword.control.query.ruko }
    end: (?=[,;)}\]])
    patterns:
      - begin: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(by|with|while)\b\s*
        end: (?=[,;)}\]])
        name: keyword.control.query.ruko
        patterns: *query-body
      - include: '#query-body'
      - include: $self

  reduce-clause:
    begin: |-
      (?x)\s*
      (?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b
        (
             (?:fold|reduce|scan) \b\s*
          \b (?:first|last|left|right)?
        )
      \b\s*
    beginCaptures:
      1: { name: keyword.control.query.ruko }
    end: (?=[,;)}\]])
    patterns:
      - match: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(to|by)\b\s*
        name: keyword.control.query.ruko
      - include: '#query-body'
      - include: $self

  group-clause:
    begin: |-
      (?x)\s*
      (?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b
        (
          group|lookup
        )
      \b\s*
    beginCaptures:
      1: { name: keyword.control.query.ruko }
    end: (?=[,;)}\]])
    patterns:
      - begin: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(by|[io]nto)\b\s*
        end: (?=[,;)}\]])
        name: keyword.control.query.ruko
        patterns: *query-body
      - include: '#query-body'
      - include: $self

  set-clause:
    comment: |
      Set operations in queries using logical operators
      - and: conjunction or intersection, & or &&
      - or: disjunction or union, | or ||
      - xor: exclusive or or symmetric difference, ^ or ^^
      - nand: "not and" or alternative denial, ~& or !&
      - nor: "not or" or joint denial, ~| or !|
      - xnor: "not xor" or equivalence or biconditional, ~^ or !^
      - imply: material conditional or implication (if-then), :> or ->
      - cimply: converse/reverse implication, <: or <-
      - nimply: non-implication or denial of the antecedent, :< or !<
      - cnimply: converse non-implication or denial of the consequent, >: or >!
    begin: |-
      (?x)\s*
      (?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b
        (
          (?: n?and # and, nand
            | x?n?or # or, xor, nor, xnor 
            | c?n?imply # imply, cimply, nimply, cnimply
          ) \b\s*\b
          (?: all | any | some | every)? # optional quantifier
        ) 
      \b\s*
    beginCaptures:
      1: { name: keyword.control.query.ruko }
    end: (?=[,;)}\]])
    patterns:
      - begin: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(by|with|while)\b\s*
        end: (?=[,;)}\]])
        name: keyword.control.query.ruko
        patterns:

      - include: '#query-body'
      - include: $self

  namespace-separators:
    patterns:
      - include: '#accessor-operators'
      - match: (?<!\\)\\(?!\\)
        name: punctuation.separator.namespace.ruko

  declarations:
    patterns:
      - applyEndPatternLast: true
        begin: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(quote)\b\s*
        end: (?=)|$
        beginCaptures:
          1: { name: storage.type.quote.ruko }
        name: meta.quote.ruko
        patterns:
          - begin: \s*({)\s*
            end: \s*(})\s*
            name: meta.quote.ruko
            captures:
              1: { name: punctuation.definition.block.ruko }
            patterns:
              - include: '#embedded-expressions'
              - include: '#embedded-formatting'
              - include: '#embedded-arguments'
              - include: $self
          - include: '#declaration-clause'
          - include: '#namespace-separators'
          - match: *entity-name
            name: entity.name.quote.ruko
      - applyEndPatternLast: true
        begin: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(style)\b\s*
        end: (?=$|['"`\w\s]|\#?[(\[{])
        beginCaptures:
          1: { name: storage.type.style.ruko }
        name: meta.style.ruko
        patterns:
          - include: '#style-rules'
          - include: '#style-pair'
          - include: '#style-block'
          - include: '#declaration-clause'
          - include: '#namespace-separators'
          - match: *entity-name
            name: entity.name.style.ruko
      - begin: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(oper)\b\s*
        end: (:?=(?:\s+|$)(?!\#?[(\[{]))|(?=\#?{|[;,]|$)
        beginCaptures:
          1: { name: storage.type.operator.ruko }
        endCaptures:
          1: { name: punctuation.terminator.operator.ruko }
        name: meta.operator.ruko
        patterns:
          - include: '#angle-brackets'
          - include: '#operator-declarations'
          - include: '#declaration-clause'
          - match: *entity-name
            name: variable.parameter.ruko
      - applyEndPatternLast: true
        begin: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(script)\b\s*
        end: (?=)|$
        beginCaptures:
          1: { name: storage.type.script.ruko }
        name: meta.script.ruko
        patterns:
          - include: '#script-blocks'
          - include: '#declaration-clause'
          - include: '#namespace-separators'
          - match: *entity-name
            name: entity.name.script.ruko
      - applyEndPatternLast: true
        begin: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(entity)\b\s*
        end: (?=)|$
        beginCaptures:
          1: { name: storage.type.component.ruko }
        patterns:
          - include: '#declaration-clause'
          - include: '#namespace-separators'
          - match: *entity-name
            name: entity.name.component.ruko
            patterns: [include: '#html-tags']
      - applyEndPatternLast: true
        begin: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(va[rl]|dyn|mut|let|const)\b\s*
        end: (?=)|$
        beginCaptures:
          1: { name: storage.type.variable.ruko }
      - applyEndPatternLast: true
        begin: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(decl)\b\s*
        end: (?=)|$
        beginCaptures:
          1: { name: keyword.other.declare.ruko }
      - applyEndPatternLast: true
        begin: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(func)\b\s*
        end: (?=)|$
        beginCaptures:
          1: { name: storage.type.function.ruko }
        patterns:
          - include: '#declaration-clause'
          - include: '#namespace-separators'
          - match: *entity-name
            name: entity.name.function.ruko
      - applyEndPatternLast: true
        begin: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(actor)\b\s*
        end: (?=)|$
        beginCaptures:
          1: { name: storage.type.namespace.ruko }
        patterns:
          - include: '#declaration-clause'
          - include: '#namespace-separators'
          - match: *entity-name
            name: entity.name.namespace.ruko
      - applyEndPatternLast: true
        begin: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(prop)\b\s*
        end: (?=)|$
        beginCaptures:
          1: { name: storage.type.property.ruko }
        patterns:
          - include: '#declaration-clause'
          - include: '#namespace-separators'
          - match: *entity-name
            name: entity.name.property.ruko
      - applyEndPatternLast: true
        begin: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(proc)\b\s*
        end: (?=)|$
        beginCaptures:
          1: { name: storage.type.procedure.ruko }
        patterns:
          - include: '#declaration-clause'
          - include: '#namespace-separators'
          - match: *entity-name
            name: entity.name.procedure.ruko
      - applyEndPatternLast: true
        begin: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(temp)\b\s*
        end: (?=)|$
        beginCaptures:
          1: { name: storage.type.template.ruko }
        patterns:
          - include: '#declaration-clause'
          - include: '#namespace-separators'
          - match: *entity-name
            name: entity.name.template.ruko
      - applyEndPatternLast: true
        begin: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(class)\b\s*
        end: (?=)|$
        beginCaptures:
          1: { name: storage.type.class.ruko }
        patterns:
          - include: '#declaration-clause'
          - include: '#namespace-separators'
          - match: *entity-name
            name: entity.name.class.ruko
      - applyEndPatternLast: true
        begin: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(inter)\b\s*
        end: (?=)|$
        beginCaptures:
          1: { name: storage.type.interface.ruko }
        patterns:
          - include: '#declaration-clause'
          - include: '#namespace-separators'
          - match: *entity-name
            name: entity.name.interface.ruko
      - applyEndPatternLast: true
        begin: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(enum)\b\s*
        end: (?=)|$
        beginCaptures:
          1: { name: storage.type.enum.ruko }
        patterns:
          - include: '#declaration-clause'
          - include: '#namespace-separators'
          - match: *entity-name
            name: entity.name.enum.ruko
      - applyEndPatternLast: true
        begin: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(module)\b\s*
        end: (?=)|$
        beginCaptures:
          1: { name: storage.type.module.ruko }
        patterns:
          - include: '#declaration-clause'
          - include: '#namespace-separators'
          - match: *entity-name
            name: entity.name.module.ruko
      - applyEndPatternLast: true
        begin: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(iter)\b\s*
        end: (?=)|$
        beginCaptures:
          1: { name: storage.type.iterator.ruko }
        patterns:
          - include: '#declaration-clause'
          - include: '#namespace-separators'
          - match: *entity-name
            name: entity.name.iterator.ruko
      - applyEndPatternLast: true
        begin: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(schema)\b\s*
        end: (?=)|$
        beginCaptures:
          1: { name: storage.type.schema.ruko }
        patterns:
          - include: '#declaration-clause'
          - include: '#namespace-separators'
          - match: *entity-name
            name: entity.name.schema.ruko
      - applyEndPatternLast: true
        begin: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(macro)\b\s*
        end: (?=)|$
        beginCaptures:
          1: { name: storage.type.macro.ruko }
        patterns:
          - include: '#declaration-clause'
          - include: '#namespace-separators'
          - match: *entity-name
            name: entity.name.macro.ruko
      - applyEndPatternLast: true
        begin: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(query)\b\s*
        end: (?=)|$
        beginCaptures:
          1: { name: storage.type.query.ruko }
        patterns:
          - include: '#declaration-clause'
          - include: '#namespace-separators'
          - match: *entity-name
            name: entity.name.query.ruko
      - applyEndPatternLast: true
        begin: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(object)\b\s*
        end: (?=)|$
        beginCaptures:
          1: { name: storage.type.object.ruko }
        patterns:
          - include: '#declaration-clause'
          - include: '#namespace-separators'
          - match: *entity-name
            name: entity.name.object.ruko
      - applyEndPatternLast: true
        begin: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(trait)\b\s*
        end: (?=)|$
        beginCaptures:
          1: { name: storage.type.trait.ruko }
        patterns:
          - include: '#declaration-clause'
          - include: '#namespace-separators'
          - match: *entity-name
            name: entity.name.trait.ruko
      - applyEndPatternLast: true
        begin: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(realm)\b\s*
        end: (?=)|$
        beginCaptures:
          1: { name: storage.type.realm.ruko }
        patterns:
          - include: '#declaration-clause'
          - include: '#namespace-separators'
          - match: *entity-name
            name: entity.name.realm.ruko
      - applyEndPatternLast: true
        begin: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(union)\b\s*
        end: (?=)|$
        beginCaptures:
          1: { name: storage.type.union.ruko }
        patterns:
          - include: '#declaration-clause'
          - match: *entity-name
            name: entity.name.union.ruko
      - applyEndPatternLast: true
        begin: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(struct)\b\s*
        end: (?=)|$
        beginCaptures:
          1: { name: storage.type.struct.ruko }
        patterns:
          - include: '#declaration-clause'
          - include: '#namespace-separators'
          - match: *entity-name
            name: entity.name.struct.ruko
      - applyEndPatternLast: true
        begin: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(record)\b\s*
        end: (?=)|$
        beginCaptures:
          1: { name: storage.type.record.ruko }
        patterns:
          - include: '#declaration-clause'
          - include: '#namespace-separators'
          - match: *entity-name
            name: entity.name.record.ruko

  declaration-clause:
    name: meta.declaration.ruko
    patterns:
      - include: '#line-continuation'
      - match: \b([\p{Pc}\p{L}]\w*)\b(?=::|\.|->|\\)
        name: entity.name.namespace.ruko
      - include: '#type-square-brackets'
      - include: '#type-signature'
      - include: '#decorators'
      - include: '#embedded-verbatim'
      - include: '#type-keywords'
      - match: \s*(?<!\*)\*(?!\*)\s*
        name: keyword.generator.asterisk.ruko
      - include: '#type-operators'
      - include: '#comments'
      - include: '#comma'
      - include: '#line-continuation'
      - begin: (\()\s*
        end: \s*(\))
        captures:
          1: { name: punctuation.definition.parameters.ruko }
        patterns:
          - include: '#binding-pattern'
          - include: $self
      - begin: (\#{)\s*
        end: \s*(})
        name: meta.brace.curly.ruko
        captures:
          1: { name: punctuation.section.class.ruko }
        patterns:
          - include: $self
      - begin: ({)\s*
        end: \s*(})
        name: meta.brace.curly.ruko
        captures:
          1: { name: punctuation.definition.block.ruko }
        patterns:
          - include: '#modifier-clause'
          - include: $self
      - include: '#embedded-expressions'
      - include: '#embedded-formatting'
      - include: '#embedded-arguments'
      - include: '#brackets'
      - include: '#literals'
      - match: ::|\.|->|\\
        name: punctuation.separator.namespace.ruko
      - match: \s+
        name: meta.block.ruko

  modifier-clause:
    comment: Modifiers for declarations in classes, objects, traits, etc.
    patterns:
      - match: |-
          (?x)
          ^\s*\b(
            (?:
              # ignore all keywords
              (?!
                (?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b
                (?: # keywords
                  # wordlike operators
                  [io]n|off?|[ai]s|has|new|old|del|(?:de)?ref|to
                  |(?:un)?[gs]et|n?and|x?n?or|c?n?imply|not|by

                  # declaration keywords
                  |va[rl]|dyn|mut|let|const
                  |func|pro[pc]|type|class|actor|trait|enum|in?ter
                  |module|schema|struct|record|object|union|macro
                  |query|quote|style|script|entity|temp|oper|realm

                  # control flow keywords
                  |if|else|[tw]hen|guard|with|unless
                  |for|while|loop|goto|break|skip|redo|until
                  |try|switch|[cm]atch|case|def|throw|raise|error
                  |return|yield|await|move|goto|pass|defer
                  |[gd]o|from|where|(?:im|ex)(?:port|tern)

                  # miscellaneous keywords
                  |debug|assert|check|decl
                  |use|echo|eval|expr|scope
                  |begin|end|prev|next
                )
                \b
              )
              \b[\p{Pc}\p{L}]\w*\b # identifier
              \s*
            )+
          )
          (:)\s*
        captures:
          1:
            name: storage.modifier.specifier.ruko
            patterns: [include: '#modifiers']
          2: { name: punctuation.separator.section.ruko }

  function-clause:
    patterns:
      - comment: Function def before function keyword; x = def()
        match: |-
          (?x)
          \s*
          (?<=[?!:]:|\b\.|[?!]\.) # lookbehind for valid assignment
          \s*
          \b([\p{Pc}\p{L}]\w*)\b\s+ # label
          (:?=)\s+ # assignment operator

          ( # modifiers
            (?:
              (?:
              \s*
                (?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b
                [\p{Pc}\p{L}]\w*
              )
              \b\s*
            )*
          )

          \s*
          (?=
            \b
            (?: # declaration keywords
              func|pro[pc]|type|class|actor|trait|enum|in?ter
              |module|schema|struct|record|object|union|macro
              |query|quote|style|script|entity|temp|oper|realm
            )
            \b
          )
        name: meta.function.declaration.ruko
        captures:
          1: { name: entity.name.method.ruko }
          2: { name: keyword.operator.assignment.ruko }
          3: { patterns: [include: '#modifiers'] }
      - begin: |-
          (?x)
          \s*
          (?<=[?!:]:|\b\.|[?!]\.) # lookbehind for valid assignment
          \s*
          \b([\p{Pc}\p{L}]\w*)\b\s+ # label
          (:?=)\s+ # assignment operator

          ( # modifiers
            (?:
              (?:
              \s*
                (?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b
                [\p{Pc}\p{L}]\w*
              )
              \b\s*
            )*
          )

          \s*
          (\|) (?=
            (?: \#?[(\[{] )? # opening bracket
            (?: [;,] \s* )* # optional separators
            (?:
              ((?:[*&%@^!~?\\\-+]|\.{3})*) # any sigils
              (\b[\p{Pc}\p{L}]\w*\b) # identifier
              ([!?]*) # optional sigils
              \s*
            )+ (?: [)\]}] )? # closing bracket
          )
        end: (?<!\|)(\|)(?!\|)
        name: meta.function.declaration.ruko
        captures:
          1: { name: entity.name.method.ruko }
          2: { name: keyword.operator.assignment.ruko }
          3: { patterns: [include: '#modifiers'] }
          4: { name: punctuation.separator.arguments.ruko }
        endCaptures:
          1: { name: punctuation.separator.arguments.ruko }
        patterns: [include: '#argument-list-content']
      - comment: 'Function def before function keyword; x = func()'
        match: |-
          (?x)
          \s*
          \b([\p{Pc}\p{L}]\w*)\b\s+ # Label
          (:?=)\s+ # Assignment operator

          ( # modifiers
            (?:
              (?:
              \s*
                (?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b
                [\p{Pc}\p{L}]\w*
              )
              \b\s*
            )*
          )

          \s*
          (?=
            \b
            (?: # declaration keywords
              func|pro[pc]|type|class|actor|trait|enum|in?ter
              |module|schema|struct|record|object|union|macro
              |query|quote|style|script|entity|temp|oper|realm
            )
            \b
          )
        name: meta.function.declaration.ruko
        captures:
          1: { name: entity.name.ruko }
          2: { name: keyword.operator.assignment.ruko }
          3: { patterns: [include: '#modifiers'] }
      - comment: 'Function def with function keyword; x = fn |args| { }'
        begin: |-
          (?x)

          \s*
          \b([\p{Pc}\p{L}]\w*)\b\s+ # Label
          (:?=)\s+ # Assignment operator
          \s*

          ( # modifiers
            (?:
              (?:
              \s*
                (?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b
                [\p{Pc}\p{L}]\w*
              )
              \b\s*
            )*
          )

          \s*
          (\|) (?=
            (?: \#?[(\[{] )? # opening bracket
            (?: [;,] \s* )* # optional separators
            (?:
              ((?:[*&%@^!~?\\\-+]|\.{3})*) # any sigils
              (\b[\p{Pc}\p{L}]\w*\b) # identifier
              ([!?]*) # optional sigils
              \s*
            )+ (?: [)\]}] )? # closing bracket
          )
        end: (?<!\|)(\|)(?!\|)
        name: meta.function.declaration.ruko
        captures:
          1: { name: entity.name.ruko }
          2: { name: keyword.operator.assignment.ruko }
          3: { patterns: [include: '#modifiers'] }
          4: { name: punctuation.separator.arguments.ruko }
        endCaptures:
          1: { name: punctuation.separator.arguments.ruko }
        patterns: [include: '#argument-list-content']

  argument-list:
    comment: Function argument list starting and ending with |
    name: meta.function.arguments.ruko
    begin: |-
      (?x)
      (?<=
        (?:
            ^ # beginning of line
          | [,;] # separator
          | \#? [({\[] # opening bracket
          | [\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]+ \s # postfix or infix operator
          | (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            [\p{Pc}\p{L}]\w*  # keyword or identifier
        ) \s*
      ) \s*
      (\|) (?=
        (?: \#?[(\[{] )? # opening bracket
        (?: [;,] \s* )* # optional separators
        (?:
          ((?:[*&%@^!~?\\\-+]|\.{3})*) # any sigils
          (\b[\p{Pc}\p{L}]\w*\b) # identifier
          ([!?]*) # optional sigils
          \s*
        )+ (?: [)\]}] )? # closing bracket
      )
    captures:
      1: { name: punctuation.separator.arguments.ruko }
    end: (?<!\|)(\|)(?!\|)
    patterns: [include: '#argument-list-content']

  argument-list-content:
    name: meta.function.arguments.content.ruko
    patterns:
      - match: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(as)\b\s*
        name: keyword.operator.expression.as.ruko
      - match: (?<=[\w\s][(|])\.
        name: punctuation.definition.metadata.ruko
      - match: ','
        name: punctuation.separator.arguments.ruko
      - include: '#binding-pattern'

  clauses:
    patterns:
      - include: '#do-clause'
      - include: '#for-clause'
      - include: '#if-clause'
      - include: '#match-clause'
      - include: '#switch-clause'
      - include: '#catch-clause'
      - include: '#with-clause'
      - include: '#try-clause'
      - include: '#type-clause'
      - include: '#new-clause'

  new-clause:
    applyEndPatternLast: true
    begin: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(old|new)\b
    end: (?=)|$
    beginCaptures:
      1: { name: keyword.operator.expression.$1.ruko }
    patterns:
      - match: *entity-name
        name: entity.name.instance.ruko
      - include: '#type-clause'
      - include: '#type-keywords'
      - include: '#type-square-brackets'
      - include: '#parameter-brackets'
      - include: '#namespace-separators'
      - include: '#round-brackets'

  do-clause:
    match: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(do)\b\s*
    name: keyword.control.do.ruko

  type-clause:
    patterns:
      - applyEndPatternLast: true
        begin: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(as)\b\s*
        end: (?=)|$
        beginCaptures:
          1: { name: keyword.operator.expression.as.ruko }
        patterns: [include: '#types']
      - applyEndPatternLast: true
        begin: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(is\s+not|is|has\s+not|has|has\s+not|has)\b\s*
        end: (?=)|$
        beginCaptures:
          1: { name: keyword.operator.expression.is.ruko }
        patterns: [include: '#types']
      - applyEndPatternLast: true
        begin: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(type)\b\s*
        end: (?=)|$
        captures:
          1: { name: keyword.other.typedef.ruko }
        patterns:
          - include: '#types'
          - match: \s*([!#-&*+\-./:;<>?@\\^|~¡-¨«¬­¯°±´¶·¸»¿×÷]?=)\s*
            captures:
              1: { name: keyword.operator.assignment.ruko }

  try-clause:
    begin: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(try|then|raise)\b\s*
    end: \s*(:)(?=(?:[,;'"`)}\]\w\s]|\#?[(\[{]|\\.))|(?=[,;)}\]])|$
    name: meta.try.ruko
    beginCaptures:
      1: { name: keyword.control.error.ruko }
    endCaptures:
      1: { name: punctuation.terminator.colon.ruko }
    patterns:
      - match: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b([io]n|of|as|await)\b\s*
        name: keyword.control.error.ruko
      - include: $self

  catch-clause:
    begin: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(catch|error)\b\s*
    end: \s*(?=[,;)}\]])|$
    name: meta.catch.ruko
    beginCaptures:
      1: { name: keyword.control.error.ruko }
    patterns:
      - match: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(as)\b\s*
        name: keyword.control.error.ruko
      - begin: \s*({)\s*
        end: \s*(})\s*
        captures:
          1: { name: punctuation.definition.block.ruko }
        patterns:
          - include: '#catch-case-clause'
          - include: $self
      - include: $self

  catch-case-clause:
    patterns:
      - match: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(def|else)\b\s*(:)
        captures:
          1: { name: keyword.control.error.ruko }
          2: { name: punctuation.definition.case-statement.ruko }
      - begin: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(case)\b\s*
        end: \s*(:)(?=(?:[,;'"`)}\]\w\s]|\#?[(\[{]|\\.))|$
        beginCaptures:
          1: { name: keyword.control.error.ruko }
        endCaptures:
          1: { name: punctuation.definition.case-statement.ruko }
        patterns:
          - include: '#argument-list'
          - applyEndPatternLast: true
            begin: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(is\s+not|is|has\s+not|has)\b\s*
            end: (?=)|$
            beginCaptures:
              1: { name: keyword.control.error.ruko }
            patterns: [include: '#types']
          - match: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b((?:if|when|unless)(?:\s+not)?|as)\b\s*
            name: keyword.control.error.ruko
          - include: '#type-keywords'
          - include: $self

  for-clause:
    begin: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(for(?:ever|\s+each)?|(?:while|until)(?:\s+not)?|loop)\b\s*
    end: \s*(:)(?=(?:[,;'"`)}\]\w\s]|\#?[(\[{]|\\.))|(?=[,;)}\]])|$
    name: meta.for.ruko
    beginCaptures:
      1: { name: keyword.control.loop.ruko }
    endCaptures:
      1: { name: punctuation.terminator.colon.ruko }
    patterns:
      - match: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b([io]n|of|as|await)\b\s*
        name: keyword.control.loop.ruko
      - include: $self

  if-clause:
    begin: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b((?:if|when|unless)(?:\s+not)?|guard)\b\s*
    end: \s*(:)(?=(?:[,;'"`)}\]\w\s]|\#?[(\[{]|\\.))|(?=[,;)}\]])|$
    name: meta.if.ruko
    beginCaptures:
      1: { name: keyword.control.conditional.ruko }
    endCaptures:
      1: { name: punctuation.terminator.colon.ruko }
    patterns:
      - match: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(await)\b\s*
        name: keyword.control.conditional.ruko
      - include: $self

  match-clause:
    begin: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(match)\b\s*
    end: \s*(?=[,;)}\]])|$
    name: meta.match.ruko
    beginCaptures:
      1: { name: keyword.control.match.ruko }
    patterns:
      - match: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(await)\b\s*
        name: keyword.control.match.ruko
      - begin: \s*({)\s*
        end: \s*(})\s*
        captures:
          1: { name: punctuation.definition.block.ruko }
        patterns:
          - include: '#match-case-clause'
          - include: $self
      - include: $self

  match-case-clause:
    patterns:
      - match: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(def|else)\b\s*(:)
        captures:
          1: { name: keyword.control.match.ruko }
          2: { name: punctuation.definition.case-statement.ruko }
      - begin: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(case)\b\s*
        end: \s*(:)(?=(?:[,;'"`)}\]\w\s]|\#?[(\[{]|\\.))|$
        beginCaptures:
          1: { name: keyword.control.match.ruko }
        endCaptures:
          1: { name: punctuation.definition.case-statement.ruko }
        patterns:
          - include: '#argument-list'
          - applyEndPatternLast: true
            begin: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(is\s+not|is|has\s+not|has)\b\s*
            end: (?=)|$
            beginCaptures:
              1: { name: keyword.control.match.ruko }
            patterns: [include: '#types']
          - match: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b((?:if|when|unless)(?:\s+not)?|as)\b\s*
            name: keyword.control.match.ruko
          - include: '#type-keywords'
          - include: $self

  switch-clause:
    begin: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(switch)\b\s*
    end: \s*(:)(?=(?:[,;'"`)}\]\w\s]|\#?[(\[{]|\\.))|(?=[,;)}\]])|$
    name: meta.switch.ruko
    beginCaptures:
      1: { name: keyword.control.switch.ruko }
    patterns:
      - match: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(await)\b\s*
        name: keyword.control.switch.ruko
      - begin: \s*({)\s*
        end: \s*(})\s*
        captures:
          1: { name: punctuation.definition.block.ruko }
        patterns:
          - include: '#switch-case-clause'
          - include: $self
      - include: $self

  switch-case-clause:
    patterns:
      - match: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(def|else)\b\s*(:)
        captures:
          1: { name: keyword.control.switch.ruko }
          2: { name: punctuation.definition.case-statement.ruko }
      - begin: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(case)\b\s*
        end: \s*(:)(?=(?:[,;'"`)}\]\w\s]|\#?[(\[{]|\\.))|$
        beginCaptures:
          1: { name: keyword.control.switch.ruko }
        endCaptures:
          1: { name: punctuation.definition.case-statement.ruko }
        patterns:
          - include: '#argument-list'
          - applyEndPatternLast: true
            begin: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(is\s+not|is|has\s+not|has)\b\s*
            end: (?=)|$
            beginCaptures:
              1: { name: keyword.control.switch.ruko }
            patterns: [include: '#types']
          - match: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b((?:if|when|unless)(?:\s+not)?|as)\b\s*
            name: keyword.control.switch.ruko
          - include: '#type-keywords'
          - include: $self

  with-clause:
    begin: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(with)\b\s*
    end: \s*(:)(?=(?:[,;'"`)}\]\w\s]|\#?[(\[{]|\\.))|(?=[,;)}\]])|$
    name: meta.if.ruko
    beginCaptures:
      1: { name: keyword.control.with.ruko }
    endCaptures:
      1: { name: punctuation.terminator.colon.ruko }
    patterns:
      - match: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(await)\b\s*
        name: keyword.control.with.ruko
      - include: $self

  # Binding patterns

  object-key:
    begin: (?<=(?:^|[,;]|\#?[(\[{])\s*)
    end: \s*(?=[,;)\]}]|$)|\s*(:)
    name: meta.object-key.ruko
    endCaptures:
      1: { name: punctuation.separator.key-value.ruko }
    patterns:
      - include: '#literals'
      - include: '#embedded-expressions'
      - include: '#brackets'
      - match: (?<=(?:^|[,;]|\#?[(\[{])\s*)\b[\p{Pc}\p{L}]\w*\b\s*(?=[,;)\]}:]|$)
        name: constant.other.object.key.ruko
      - include: '#space'
      - include: '#comments'
      - include: '#line-continuation'
      - include: $self

  object-value:
    patterns:
      - match: (?<=(?:^|[,;(\[{])\s*)\b[\p{Pc}\p{L}]\w*\b(?=\s*(?:[,;)\]}]|=(?:['"`\w\s]|\#?[(\[{])|$))
        name: variable.other.constant.ruko
      - match: (?<=(?:^|[,;]|\#?[(\[{])\s*)\b[\p{Pc}\p{L}]\w*\b\s*(?=[,;)\]}]|=(?:['"`\w\s]|\#?[(\[{])|$)
        name: variable.other.constant.ruko

  object-argument:
    patterns:
      - match: (?<=(?:^|[,;(\[{])\s*)\b[\p{Pc}\p{L}]\w*\b(?=\s*(?:[,;)\]}]|=(?:['"`\w\s]|\#?[(\[{])|$))
        name: variable.parameter.ruko
      - match: (?<=(?:^|[,;]|\#?[(\[{])\s*)\b[\p{Pc}\p{L}]\w*\b\s*(?=[,;)\]}]|=(?:['"`\w\s]|\#?[(\[{])|$)
        name: variable.parameter.ruko

  as-keyword:
    match: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(as)\b\s*
    name: keyword.operator.expression.as.ruko

  given-using-keyword:
    match: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(given|using)\b\s*
    name: keyword.operator.expression.$1.ruko

  binding-pattern-object:
    begin: (\#?{)\s*
    end: \s*(})
    name: meta.brace.curly.ruko
    captures:
      1: { name: punctuation.definition.binding-pattern.object.ruko }
    patterns:
      - include: '#object-argument'
      - include: '#object-labels'
      - include: '#object-key'
      - match: '[;,]'
        name: punctuation.separator.mapping.ruko
      - include: '#binding-pattern'
      - include: '#illegal'

  binding-pattern-tuple:
    begin: (\#?\()\s*
    end: \s*(\))
    name: meta.brace.curly.ruko
    captures:
      1: { name: punctuation.definition.binding-pattern.tuple.ruko }
    patterns:
      - include: '#object-labels'
      - match: '[;,]'
        name: punctuation.separator.arguments.ruko
      - include: '#binding-pattern'
      - include: '#illegal'

  binding-pattern-array:
    begin: (\#?\[)\s*
    end: \s*(])
    name: meta.brace.curly.ruko
    captures:
      1: { name: punctuation.definition.binding-pattern.array.ruko }
    patterns:
      - include: '#object-labels'
      - match: '[;,]'
        name: punctuation.separator.sequence.ruko
      - include: '#binding-pattern'
      - include: '#illegal'

  default-value:
    begin: (?<=^|[\s({\[])(\=)(?=$|[)}\]\s])|(?<=['"`)}\]\w]|\\.)(\=)(?=(?:['"`\w]|\#?[(\[{]))
    captures:
      1: { name: keyword.operator.assignment.ruko }
      2: { name: keyword.operator.assignment.ruko }
    end: (?=\|(?:$|[^|])|[,;)}\]])
    patterns: [include: $self]

  binding-pattern:
    patterns:
      - include: '#default-value'
      - include: '#as-keyword'
      - include: '#given-using-keyword'
      - include: '#binding-pattern-object'
      - include: '#binding-pattern-tuple'
      - include: '#binding-pattern-array'
      - include: '#call-arguments'
      - include: '#type-operators'
      - include: '#type-signature'
      - include: '#space'
      - include: '#comments'
      - include: '#function-calls'
      - include: '#literals'
      - include: '#embedded-expressions'
      - include: '#brackets'

  # Object labels

  object-labels:
    patterns:
      - comment: 'Function def before function keyword: x = def()'
        match: |-
          (?x)
          (?<=(?:^|[,;]|\#?[(\[{])\s*)

          (\b[\w\p{Pd}]+\b) # label
          (:) # key value separator
          \s*\b

          ( # modifiers
            (?:
              (?:
              \s*
                (?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b
                [\p{Pc}\p{L}]\w*
              )
              \b\s*
            )*
          )

          \s*
          (?=
            \b
            (?: # declaration keywords
              func|pro[pc]|type|class|actor|trait|enum|in?ter
              |module|schema|struct|record|object|union|macro
              |query|quote|style|script|entity|temp|oper|realm
            )
            \b
          )
        name: meta.object-literal.key.ruko
        captures:
          1: { name: entity.name.ruko }
          2: { name: punctuation.separator.key-value.ruko }
          3: { patterns: [include: '#modifiers'] }
      - begin: |-
          (?x)
          (?<=(?:^|[,;]|\#?[(\[{])\s*)

          (\b[\w\p{Pd}]+\b) # label
          (:) # key value separator
          \s*\b

          ( # modifiers
            (?:
              (?:
              \s*
                (?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b
                [\p{Pc}\p{L}]\w*
              )
              \b\s*
            )*
          )

          \s*
          (\|) (?=
            (?: \#?[(\[{] )? # opening bracket
            (?: [;,] \s* )* # optional separators
            (?:
              ((?:[*&%@^!~?\\\-+]|\.{3})*) # any sigils
              (\b[\p{Pc}\p{L}]\w*\b) # identifier
              ([!?]*) # optional sigils
              \s*
            )+ (?: [)\]}] )? # closing bracket
          )
        end: (?<!\|)(\|)(?!\|)
        name: meta.object-literal.key.ruko
        beginCaptures:
          1: { name: entity.name.ruko }
          2: { name: punctuation.separator.key-value.ruko }
          3: { patterns: [include: '#modifiers'] }
          4: { name: punctuation.separator.arguments.ruko }
        endCaptures:
          1: { name: punctuation.separator.arguments.ruko }
        patterns: [include: '#argument-list-content']
      - match: |-
          (?x)
          (?<=(?:^|[,;]|\#?[(\[{])\s*)
          (\b[\w\p{Pd}]+\b) # Label
          (:) # Key value separator
        name: meta.object-literal.key.ruko
        captures:
          1:
            name: constant.other.object.key.ruko
            patterns:
              - include: '#constants'
              - include: '#numbers'
              - include: '#symbols'
              - include: '#escapes-embedded'
          2: { name: punctuation.separator.key-value.ruko }

  # Slicing syntax

  slice-syntax:
    patterns:
      - match: (?<=[:'"`\w\s]|\\.)(:)(?=[:'"`\w\s]|\#?[(\[{]|$)
        name: keyword.operator.slice.ruko
      - include: '#numbers'
      - include: '#space'
      - include: '#comments'
      - include: '#line-continuation'

  # Objective-C-style messages

  message-passing:
    applyEndPatternLast: true
    begin: |-
      (?x)
      (?<= # literal
        (?:
            ^ # start of line
          | [\w'"`)}\]] # literals and closing brackets
          | \\. # escape sequences
          | [?!:]:\b[\p{Pc}\p{L}]\w*\b # identifiers
          | [?!]\b[\p{Pc}\p{L}]\w*\b # identifiers
          | ; # argument list terminator
        )
        \s*
      )

      \b\s*

      ([?!][:>]?=?|[:>])? # message access operator
      ( # Message name
        \b
        # ignore all keywords
        (?!
          (?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b
          (?: # keywords
            # wordlike operators
            [io]n|off?|[ai]s|has|new|old|del|(?:de)?ref|to
            |(?:un)?[gs]et|n?and|x?n?or|c?n?imply|not|by

            # declaration keywords
            |va[rl]|dyn|mut|let|const
            |func|pro[pc]|type|class|actor|trait|enum|in?ter
            |module|schema|struct|record|object|union|macro
            |query|quote|style|script|entity|temp|oper|realm

            # control flow keywords
            |if|else|[tw]hen|guard|with|unless
            |for|while|loop|goto|break|skip|redo|until
            |try|switch|[cm]atch|case|def|throw|raise|error
            |return|yield|await|move|goto|pass|defer
            |[gd]o|from|where|(?:im|ex)(?:port|tern)

            # miscellaneous keywords
            |debug|assert|check|decl
            |use|echo|eval|expr|scope
            |begin|end|prev|next
          )
          \b
        )
        \b[\p{Pc}\p{L}]\w*\b # identifier
      )
      (?=:(?:\s*(?:[,;'"`)}\]\w\s]|\#?[(\[{]|\\.)|$))
    end: (?=)|$
    name: meta.message.ruko
    beginCaptures:
      1:
        patterns:
          - &message-accessor-operators
            match: |-
              (?x)
              (?:
                (\?[:>]?=?) | # 1: optional access/unwrap
                (![:>]?=?) | # 2: assert/unwrap operator
                ([:>]?=? ) # 3: access operator
              )
            captures:
              1: { name: keyword.operator.optional.ruko }
              2: { name: keyword.operator.unwrap.ruko }
              3: { name: keyword.operator.accessor.ruko }
      2:
        patterns:
          - match: |-
              (?x)
              (?: # Regular variables
                  (\p{Pc}+\w*(?!\p{Pc}+)\b) # Leading underscore
                | ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*) # Screaming snake case
                | ((?:[\p{Pc}\p{L}&&\P{Ll}][\w&&\P{Lu}]*)+) # Pascal case
                | ([\p{Pc}\p{L}]\w*) # Camel or snake case
              )
            captures:
              1:
                name: entity.name.tag.directive.ruko
                patterns: *builtin-names
              2:
                name: entity.name.function.tagged-template.ruko
                patterns: *builtin-names
              3:
                name: entity.name.function.method.ruko
                patterns: *builtin-names
              4:
                name: entity.name.function.member.ruko
                patterns: *builtin-names
    patterns:
      - include: '#brackets'
      - match: (:)(?=\s*(?:[,;'"`)}\]\w\s]|\#?[(\[{]|\\.)|$)
        name: punctuation.separator.key-value.ruko

  # Punctuation

  punctuation:
    patterns:
      - include: '#line-continuation'
      - include: '#comma'
      - include: '#double-semicolon'
      - include: '#semicolon'

  line-continuation:
    begin: \s*(\\)\s*(?=/[/*](?![\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]+)|$)
    end: ^\s*(?=\S)
    captures:
      1: { name: punctuation.separator.continuation.line.ruko }
    patterns: [include: '#comments']

  comma:
    match: \s*(,)\s*
    captures:
      1: { name: punctuation.separator.expression.ruko }
  double-semicolon:
    match: \s*(;;)\s*
    captures:
      1: { name: punctuation.terminator.statement.ruko }
  semicolon:
    match: \s*(;)\s*
    captures:
      1: { name: punctuation.terminator.expression.ruko }

  brackets:
    patterns:
      - include: '#angle-brackets'
      - include: '#curly-brackets'
      - include: '#square-brackets'
      - include: '#round-brackets'

  generics: &generics
    patterns:
      - comment: <> empty generics
        match: (?<=^|['"`)}\]>\w\s]|(?:[?!]\.|[?!:]:|[?!-]>)=?)(<)(>)(?=[!~]?(?:['"`\w<]|\#?[(\[{]))
        captures:
          1: { name: punctuation.type.arguments.ruko }
          2: { name: punctuation.type.arguments.ruko }
      - comment: <...> generics
        name: meta.type-arguments.ruko
        begin: (?<=^|['"`)}\]>\w\s]|(?:[?!]\.|[?!:]:|[?!-]>)=?)(<)(?=[!@#$%^&*\-+|\\/~:.?<]*(?:['"`\w]|\#?[(\[{]))
        end: (?<=^|['"`)}\]>\w])(>)(?:(!)|(~))?
        beginCaptures:
          1: { name: punctuation.type.arguments.ruko }
        endCaptures:
          1: { name: punctuation.type.arguments.ruko }
          2: { name: keyword.operator.macro.ruko }
          3: { name: keyword.operator.destructor.ruko }
        patterns:
          - include: '#punctuation'
          - include: '#brackets'
          - include: '#types'
          - include: '#type-signature'
          - include: '#embedded-expressions'
          - include: '#embedded-formatting'
          - include: '#embedded-arguments'

  accessor-operators:
    name: punctuation.type.arguments.ruko
    match: |-
      (?x)
      (?<=\b|>)
      (?:
        ( \?[.:>]=? ) | # 1: optional access/unwrap
        ( ![.:>]=? ) | # 2: assert/unwrap operator
        ( (?:::|\.|->)=? ) # 3: standard accessor
      )
      (?=\b|<)
    captures:
      1: { name: keyword.operator.optional.ruko }
      2: { name: keyword.operator.unwrap.ruko }
      3: { name: keyword.operator.accessor.ruko }

  angle-brackets: *generics

  curly-brackets:
    repository:
      punctuation:
        patterns:
          - match: ','
            name: punctuation.separator.mapping.ruko
          - match: (?<=(?:['"`)}\]\w]|\\.)[\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]*):(?=(?:['"`\w\s]|\#?[(\[{])|$)
            name: punctuation.separator.key-value.ruko

    patterns:
      - begin: |-
          (?x)
          (?<=
            (?:
                (?:^|[\s\p{P}\p{S}]):\|\s*\| # beside a lambda pipe
              | (?:^|[,;'"`)}\]\w\s]|\\.)\|
              | ^\s*\|
            )
          )
          \s*
          (\#{)
          \s*
        end: \s*(})
        name: meta.brace.curly.ruko
        captures:
          1: { name: punctuation.section.class.ruko }
        patterns: [include: $self]
      - begin: |-
          (?x)
          (?<=
            (?:
                (?:^|[\s\p{P}\p{S}]):\|\s*\| # beside a lambda pipe
              | (?:^|[,;'"`)}\]\w\s]|\\.)\|
              | ^\s*\|
            )
          )
          \s*
          ({)
          \s*
        end: \s*(})
        name: meta.brace.curly.ruko
        captures:
          1: { name: punctuation.definition.block.ruko }
        patterns: [include: $self]
      - begin: |-
          (?x)
          (?<=
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \b
              (?: # destructuring keywords
                va[rl]|dyn|mut|let|const
                |case
              )
            \b
            (?:$|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \s*
          )
          (\#?\{)\s*
        end: \s*(})
        name: meta.brace.curly.ruko
        captures:
          1: { name: punctuation.definition.binding-pattern.object.ruko }
        patterns:
          - include: '#object-labels'
          - include: '#punctuation'
          - include: '#object-value'
          - include: '#object-key'
          - include: '#as-keyword'
          - include: $self
      - begin: |-
          (?x)
          (?<=
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \b
              (?: # wordlike operators
                [io]n|off?|[ai]s|has|new|old|del|(?:de)?ref|to
                |(?:un)?[gs]et|n?and|x?n?or|c?n?imply|not|by
              )
            \b
            (?:$|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \s*
          )
          (\#{)\s*
        end: \s*(})
        name: meta.brace.curly.ruko
        captures:
          1: { name: punctuation.definition.mapping.ruko }
        patterns:
          - include: '#object-labels'
          - include: '#punctuation'
          - include: '#object-value'
          - include: '#object-key'
          - include: $self
      - begin: |-
          (?x)
          (?<=
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \b
              (?: # wordlike operators
                [io]n|off?|[ai]s|has|new|old|del|(?:de)?ref|to
                |(?:un)?[gs]et|n?and|x?n?or|c?n?imply|not|by
              )
            \b
            (?:$|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \s*
          )
          ({)\s*
        end: \s*(})
        name: meta.brace.curly.ruko
        captures:
          1: { name: punctuation.definition.dictionary.ruko }
        patterns:
          - include: '#object-labels'
          - include: '#punctuation'
          - include: '#object-value'
          - include: '#object-key'
          - include: $self
      - begin: |-
          (?x)
          (?<=
            (?:
                [,;({\[]
              | (?:^|[,;({\[)}\]\w'"`]|\\.):\s*
              | [\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]+
            )
            \s*
          )
          (\#{)\s*
        end: \s*(})
        name: meta.brace.curly.ruko
        captures:
          1: { name: punctuation.definition.mapping.ruko }
        patterns:
          - include: '#object-labels'
          - include: '#punctuation'
          - include: '#object-value'
          - include: '#object-key'
          - include: $self
      - begin: |-
          (?x)
          (?<=
            (?:
                [,;({\[]
              | (?:^|[,;({\[)}\]\w'"`]|\\.):\s*
              | [\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]+
            )
            \s*
          )
          ({)\s*
        end: \s*(})
        name: meta.brace.curly.ruko
        captures:
          1: { name: punctuation.definition.dictionary.ruko }
        patterns:
          - include: '#object-labels'
          - include: '#punctuation'
          - include: '#object-value'
          - include: '#object-key'
          - include: $self
      - begin: (\#{)\s*
        end: \s*(})
        name: meta.brace.curly.ruko
        captures:
          1: { name: punctuation.section.class.ruko }
        patterns: [include: $self]
      - begin: ({)\s*
        end: \s*(})
        name: meta.brace.curly.ruko
        captures:
          1: { name: punctuation.definition.block.ruko }
        patterns: [include: $self]

  round-brackets:
    repository:
      punctuation:
        patterns:
          - match: ','
            name: punctuation.separator.arguments.ruko
          - match: \s*(?<!\b\.)(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>))(?<!\b(?:[^\s.]\.|[:!?]:|[-!?]>)=)\b(as)\b\s*
            name: keyword.operator.expression.as.ruko
          - match: (?<=[\w\s][(|])\.
            name: punctuation.definition.metadata.ruko

    patterns:
      - begin: |-
          (?x)
          (?<=
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \b
              (?: # destructuring keywords
                va[rl]|dyn|mut|let|const
                |case
              )
            \b
            (?:$|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \s*
          )
          (\#?\()\s*
        end: \s*(\))
        name: meta.brace.round.ruko
        captures:
          1: { name: punctuation.definition.binding-pattern.tuple.ruko }
        patterns:
          - include: '#as-keyword'
          - include: '#punctuation'
          - include: $self
      - begin: |-
          (?x)
          (?<= # literal
              (?: [\w'"`)}\]] | \\.) >* !?
            | [^\s.]\.=?|[?!:]:=?
          )
          (\#?\()\s*
        end: \s*(\))
        name: meta.brace.round.ruko
        captures:
          1: { name: punctuation.definition.parameters.ruko }
        patterns:
          - include: '#call-parameters'
          - include: $self
      - begin: (\#\()\s*
        end: \s*(\))
        name: meta.brace.round.ruko
        captures:
          1: { name: punctuation.definition.tuple.ruko }
        patterns: [include: $self]
      - begin: (\()\s*
        end: \s*(\))
        name: meta.brace.round.ruko
        captures:
          1: { name: punctuation.definition.expression.ruko }
        patterns: [include: $self]

  square-brackets:
    repository:
      punctuation:
        patterns:
          - match: ','
            name: punctuation.separator.sequence.ruko

    patterns:
      - begin: |-
          (?x)
          (?<=
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \b
              (?: # destructuring keywords
                va[rl]|dyn|mut|let|const
                |case
              )
            \b
            (?:$|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \s*
          )
          (\#?\[)\s*
        end: \s*(\])
        name: meta.brace.square.ruko
        captures:
          1: { name: punctuation.definition.binding-pattern.array.ruko }
        patterns:
          - include: '#punctuation'
          - include: '#as-keyword'
          - include: $self
      - begin: |-
          (?x)
          (?<=
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \b
              (?: # destructuring keywords
                [io]n|of|[ai]s|by|has|old|new|del
                |unset|ref|deref|n?and|x?n?or|c?n?imply|not
              )
            \b
            (?:$|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \s*
          )
          (\[)\s*
        end: \s*(\])
        name: meta.brace.square.ruko
        captures:
          1: { name: punctuation.definition.sequence.ruko }
        patterns:
          - include: '#message-passing'
          - include: '#punctuation'
          - include: $self
      - begin: |-
          (?x)
          (?<=
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \b
              (?: # destructuring keywords
                [io]n|of|[ai]s|by|has|old|new|del
                |unset|ref|deref|n?and|x?n?or|c?n?imply|not
              )
            \b
            (?:$|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \s*
          )
          (\[)\s*
        end: \s*(\])
        name: meta.brace.square.ruko
        captures:
          1: { name: punctuation.definition.array.ruko }
        patterns:
          - include: '#message-passing'
          - include: '#punctuation'
          - include: $self
      - begin: |-
          (?x)
          (?<= # literal
              (?: [\w'"`)}\]] | \\.)
            | [^\s.]\.=?|[?!:]:=?
          )
          (\#?\[)\s*
        end: \s*(\])
        name: meta.brace.square.ruko
        captures:
          1: { name: punctuation.definition.attribute-selector.ruko }
        patterns:
          - include: '#slice-syntax'
          - include: '#punctuation'
          - include: $self
      - begin: (\#\[)\s*
        end: \s*(\])
        name: meta.brace.square.ruko
        captures:
          1: { name: punctuation.definition.sequence.ruko }
        patterns:
          - include: '#message-passing'
          - include: '#punctuation'
          - include: $self
      - begin: (\[)\s*
        end: \s*(\])
        name: meta.brace.square.ruko
        captures:
          1: { name: punctuation.definition.array.ruko }
        patterns:
          - include: '#message-passing'
          - include: '#punctuation'
          - include: $self

  # Support

  css-property-keys:
    patterns:
      - match: |-
          (?x)\b(
            accent-color|additive-symbols|align-content|align-items|align-self|all|animation|animation-delay|animation-direction|animation-duration
            |animation-fill-mode|animation-iteration-count|animation-name|animation-play-state|animation-timing-function|aspect-ratio|backdrop-filter
            |backface-visibility|background|background-attachment|background-blend-mode|background-clip|background-color|background-image
            |background-origin|background-position|background-position-[xy]|background-repeat|background-size|bleed|block-size|border
            |border-block-end|border-block-end-color|border-block-end-style|border-block-end-width|border-block-start|border-block-start-color
            |border-block-start-style|border-block-start-width|border-bottom|border-bottom-color|border-bottom-left-radius|border-bottom-right-radius
            |border-bottom-style|border-bottom-width|border-collapse|border-color|border-end-end-radius|border-end-start-radius|border-image
            |border-image-outset|border-image-repeat|border-image-slice|border-image-source|border-image-width|border-inline-end
            |border-inline-end-color|border-inline-end-style|border-inline-end-width|border-inline-start|border-inline-start-color
            |border-inline-start-style|border-inline-start-width|border-left|border-left-color|border-left-style|border-left-width
            |border-radius|border-right|border-right-color|border-right-style|border-right-width|border-spacing|border-start-end-radius
            |border-start-start-radius|border-style|border-top|border-top-color|border-top-left-radius|border-top-right-radius|border-top-style
            |border-top-width|border-width|bottom|box-decoration-break|box-shadow|box-sizing|break-after|break-before|break-inside|caption-side
            |caret-color|clear|clip|clip-path|clip-rule|color|color-adjust|color-interpolation-filters|color-scheme|column-count|column-fill|column-gap
            |column-rule|column-rule-color|column-rule-style|column-rule-width|column-span|column-width|columns|contain|container|container-name|container-type|content|counter-increment
            |counter-reset|cursor|direction|display|empty-cells|enable-background|fallback|fill|fill-opacity|fill-rule|filter|flex|flex-basis
            |flex-direction|flex-flow|flex-grow|flex-shrink|flex-wrap|float|flood-color|flood-opacity|font|font-display|font-family
            |font-feature-settings|font-kerning|font-language-override|font-optical-sizing|font-size|font-size-adjust|font-stretch
            |font-style|font-synthesis|font-variant|font-variant-alternates|font-variant-caps|font-variant-east-asian|font-variant-ligatures
            |font-variant-numeric|font-variant-position|font-variation-settings|font-weight|gap|glyph-orientation-horizontal|glyph-orientation-vertical
            |grid|grid-area|grid-auto-columns|grid-auto-flow|grid-auto-rows|grid-column|grid-column-end|grid-column-gap|grid-column-start
            |grid-gap|grid-row|grid-row-end|grid-row-gap|grid-row-start|grid-template|grid-template-areas|grid-template-columns|grid-template-rows
            |hanging-punctuation|height|hyphens|image-orientation|image-rendering|image-resolution|ime-mode|initial-letter|initial-letter-align
            |inline-size|inset|inset-block|inset-block-end|inset-block-start|inset-inline|inset-inline-end|inset-inline-start|isolation
            |justify-content|justify-items|justify-self|kerning|left|letter-spacing|lighting-color|line-break|line-clamp|line-height|list-style
            |list-style-image|list-style-position|list-style-type|margin|margin-block|margin-block-end|margin-block-start|margin-bottom|margin-inline|margin-inline-end|margin-inline-start
            |margin-left|margin-right|margin-top|marker-end|marker-mid|marker-start|marks|mask|mask-border|mask-border-mode|mask-border-outset
            |mask-border-repeat|mask-border-slice|mask-border-source|mask-border-width|mask-clip|mask-composite|mask-image|mask-mode
            |mask-origin|mask-position|mask-repeat|mask-size|mask-type|max-block-size|max-height|max-inline-size|max-lines|max-width
            |max-zoom|min-block-size|min-height|min-inline-size|min-width|min-zoom|mix-blend-mode|negative|object-fit|object-position
            |offset|offset-anchor|offset-distance|offset-path|offset-position|offset-rotation|opacity|order|orientation|orphans
            |outline|outline-color|outline-offset|outline-style|outline-width|overflow|overflow-anchor|overflow-block|overflow-inline
            |overflow-wrap|overflow-[xy]|overscroll-behavior|overscroll-behavior-block|overscroll-behavior-inline|overscroll-behavior-[xy]
            |pad|padding|padding-block|padding-block-end|padding-block-start|padding-bottom|padding-inline|padding-inline-end|padding-inline-start|padding-left
            |padding-right|padding-top|page-break-after|page-break-before|page-break-inside|paint-order|perspective|perspective-origin
            |place-content|place-items|place-self|pointer-events|position|prefix|quotes|range|resize|right|rotate|row-gap|ruby-align
            |ruby-merge|ruby-position|scale|scroll-behavior|scroll-margin|scroll-margin-block|scroll-margin-block-end|scroll-margin-block-start
            |scroll-margin-bottom|scroll-margin-inline|scroll-margin-inline-end|scroll-margin-inline-start|scroll-margin-left|scroll-margin-right
            |scroll-margin-top|scroll-padding|scroll-padding-block|scroll-padding-block-end|scroll-padding-block-start|scroll-padding-bottom
            |scroll-padding-inline|scroll-padding-inline-end|scroll-padding-inline-start|scroll-padding-left|scroll-padding-right
            |scroll-padding-top|scroll-snap-align|scroll-snap-coordinate|scroll-snap-destination|scroll-snap-stop|scroll-snap-type
            |scrollbar-color|scrollbar-gutter|scrollbar-width|shape-image-threshold|shape-margin|shape-outside|shape-rendering|size
            |speak-as|src|stop-color|stop-opacity|stroke|stroke-dasharray|stroke-dashoffset|stroke-linecap|stroke-linejoin|stroke-miterlimit
            |stroke-opacity|stroke-width|suffix|symbols|system|tab-size|table-layout|text-align|text-align-last|text-anchor|text-combine-upright
            |text-decoration|text-decoration-color|text-decoration-line|text-decoration-skip|text-decoration-skip-ink|text-decoration-style|text-decoration-thickness
            |text-emphasis|text-emphasis-color|text-emphasis-position|text-emphasis-style|text-indent|text-justify|text-orientation
            |text-overflow|text-rendering|text-shadow|text-size-adjust|text-transform|text-underline-offset|text-underline-position|top|touch-action|transform
            |transform-box|transform-origin|transform-style|transition|transition-delay|transition-duration|transition-property|transition-timing-function
            |translate|unicode-bidi|unicode-range|user-select|user-zoom|vertical-align|visibility|white-space|widows|width|will-change
            |word-break|word-spacing|word-wrap|writing-mode|z-index|zoom

            # SVG attributes
            |alignment-baseline|baseline-shift|clip-rule|color-interpolation|color-interpolation-filters|color-profile
            |color-rendering|cx|cy|dominant-baseline|enable-background|fill|fill-opacity|fill-rule|flood-color|flood-opacity
            |glyph-orientation-horizontal|glyph-orientation-vertical|height|kerning|lighting-color|marker-end|marker-mid
            |marker-start|r|rx|ry|shape-rendering|stop-color|stop-opacity|stroke|stroke-dasharray|stroke-dashoffset|stroke-linecap
            |stroke-linejoin|stroke-miterlimit|stroke-opacity|stroke-width|text-anchor|width|x|y

            # Not listed on MDN; presumably deprecated
            |adjust|after|align|align-last|alignment|alignment-adjust|appearance|attachment|azimuth|background-break
            |balance|baseline|before|bidi|binding|bookmark|bookmark-label|bookmark-level|bookmark-target|border-length
            |bottom-color|bottom-left-radius|bottom-right-radius|bottom-style|bottom-width|box|box-align|box-direction
            |box-flex|box-flex-group|box-lines|box-ordinal-group|box-orient|box-pack|break|character|collapse|column
            |column-break-after|column-break-before|count|counter|crop|cue|cue-after|cue-before|decoration|decoration-break
            |delay|display-model|display-role|down|drop|drop-initial-after-adjust|drop-initial-after-align|drop-initial-before-adjust
            |drop-initial-before-align|drop-initial-size|drop-initial-value|duration|elevation|emphasis|family|fit|fit-position
            |flex-group|float-offset|gap|grid-columns|grid-rows|hanging-punctuation|header|hyphenate|hyphenate-after|hyphenate-before
            |hyphenate-character|hyphenate-lines|hyphenate-resource|icon|image|increment|indent|index|initial-after-adjust
            |initial-after-align|initial-before-adjust|initial-before-align|initial-size|initial-value|inline-box-align|iteration-count
            |justify|label|left-color|left-style|left-width|length|level|line|line-stacking|line-stacking-ruby|line-stacking-shift
            |line-stacking-strategy|lines|list|mark|mark-after|mark-before|marks|marquee|marquee-direction|marquee-play-count|marquee-speed
            |marquee-style|max|min|model|move-to|name|nav|nav-down|nav-index|nav-left|nav-right|nav-up|new|numeral|offset|ordinal-group
            |orient|origin|overflow-style|overhang|pack|page|page-policy|pause|pause-after|pause-before|phonemes|pitch|pitch-range
            |play-count|play-during|play-state|point|presentation|presentation-level|profile|property|punctuation|punctuation-trim
            |radius|rate|rendering-intent|repeat|replace|reset|resolution|resource|respond-to|rest|rest-after|rest-before|richness
            |right-color|right-style|right-width|role|rotation|rotation-point|rows|ruby|ruby-overhang|ruby-span|rule|rule-color
            |rule-style|rule-width|shadow|size|size-adjust|sizing|space|space-collapse|spacing|span|speak|speak-header|speak-numeral
            |speak-punctuation|speech|speech-rate|speed|stacking|stacking-ruby|stacking-shift|stacking-strategy|stress|stretch
            |string-set|style|style-image|style-position|style-type|target|target-name|target-new|target-position|text|text-height
            |text-justify|text-outline|text-replace|text-wrap|timing-function|top-color|top-left-radius|top-right-radius|top-style
            |top-width|trim|unicode|up|user-select|variant|voice|voice-balance|voice-duration|voice-family|voice-pitch|voice-pitch-range
            |voice-rate|voice-stress|voice-volume|volume|weight|white|white-space-collapse|word|wrap

            # in PascalCase
            |accentColor|additiveSymbols|alignContent|alignItems|alignSelf|all|animation|animationDelay|animationDirection|animationDuration
            |animationFillMode|animationIterationCount|animationName|animationPlayState|animationTimingFunction|aspectRatio|backdropFilter
            |backfaceVisibility|background|backgroundAttachment|backgroundBlendMode|backgroundClip|backgroundColor|backgroundImage
            |backgroundOrigin|backgroundPosition|backgroundPosition[xy]|backgroundRepeat|backgroundSize|bleed|blockSize|border
            |borderBlockEnd|borderBlockEndColor|borderBlockEndStyle|borderBlockEndWidth|borderBlockStart|borderBlockStartColor
            |borderBlockStartStyle|borderBlockStartWidth|borderBottom|borderBottomColor|borderBottomLeftRadius|borderBottomRightRadius
            |borderBottomStyle|borderBottomWidth|borderCollapse|borderColor|borderEndEndRadius|borderEndStartRadius|borderImage
            |borderImageOutset|borderImageRepeat|borderImageSlice|borderImageSource|borderImageWidth|borderInlineEnd
            |borderInlineEndColor|borderInlineEndStyle|borderInlineEndWidth|borderInlineStart|borderInlineStartColor
            |borderInlineStartStyle|borderInlineStartWidth|borderLeft|borderLeftColor|borderLeftStyle|borderLeftWidth
            |borderRadius|borderRight|borderRightColor|borderRightStyle|borderRightWidth|borderSpacing|borderStartEndRadius
            |borderStartStartRadius|borderStyle|borderTop|borderTopColor|borderTopLeftRadius|borderTopRightRadius|borderTopStyle
            |borderTopWidth|borderWidth|bottom|boxDecorationBreak|boxShadow|boxSizing|breakAfter|breakBefore|breakInside|captionSide
            |caretColor|clear|clip|clipPath|clipRule|color|colorAdjust|colorInterpolationFilters|colorScheme|columnCount|columnFill|columnGap
            |columnRule|columnRuleColor|columnRuleStyle|columnRuleWidth|columnSpan|columnWidth|columns|contain|container|containerName|containerType|content|counterIncrement
            |counterReset|cursor|direction|display|emptyCells|enableBackground|fallback|fill|fillOpacity|fillRule|filter|flex|flexBasis
            |flexDirection|flexFlow|flexGrow|flexShrink|flexWrap|float|floodColor|floodOpacity|font|fontDisplay|fontFamily
            |fontFeatureSettings|fontKerning|fontLanguageOverride|fontOpticalSizing|fontSize|fontSizeAdjust|fontStretch
            |fontStyle|fontSynthesis|fontVariant|fontVariantAlternates|fontVariantCaps|fontVariantEastAsian|fontVariantLigatures
            |fontVariantNumeric|fontVariantPosition|fontVariationSettings|fontWeight|gap|glyphOrientationHorizontal|glyphOrientationVertical
            |grid|gridArea|gridAutoColumns|gridAutoFlow|gridAutoRows|gridColumn|gridColumnEnd|gridColumnGap|gridColumnStart
            |gridGap|gridRow|gridRowEnd|gridRowGap|gridRowStart|gridTemplate|gridTemplateAreas|gridTemplateColumns|gridTemplateRows
            |hangingPunctuation|height|hyphens|imageOrientation|imageRendering|imageResolution|imeMode|initialLetter|initialLetterAlign
            |inlineSize|inset|insetBlock|insetBlockEnd|insetBlockStart|insetInline|insetInlineEnd|insetInlineStart|isolation
            |justifyContent|justifyItems|justifySelf|kerning|left|letterSpacing|lightingColor|lineBreak|lineClamp|lineHeight|listStyle
            |listStyleImage|listStylePosition|listStyleType|margin|marginBlock|marginBlockEnd|marginBlockStart|marginBottom|marginInline|marginInlineEnd|marginInlineStart
            |marginLeft|marginRight|marginTop|markerEnd|markerMid|markerStart|marks|mask|maskBorder|maskBorderMode|maskBorderOutset
            |maskBorderRepeat|maskBorderSlice|maskBorderSource|maskBorderWidth|maskClip|maskComposite|maskImage|maskMode
            |maskOrigin|maskPosition|maskRepeat|maskSize|maskType|maxBlockSize|maxHeight|maxInlineSize|maxLines|maxWidth
            |maxZoom|minBlockSize|minHeight|minInlineSize|minWidth|minZoom|mixBlendMode|negative|objectFit|objectPosition
            |offset|offsetAnchor|offsetDistance|offsetPath|offsetPosition|offsetRotation|opacity|order|orientation|orphans
            |outline|outlineColor|outlineOffset|outlineStyle|outlineWidth|overflow|overflowAnchor|overflowBlock|overflowInline
            |overflowWrap|overflow[xy]|overscrollBehavior|overscrollBehaviorBlock|overscrollBehaviorInline|overscrollBehavior[xy]
            |pad|padding|paddingBlock|paddingBlockEnd|paddingBlockStart|paddingBottom|paddingInline|paddingInlineEnd|paddingInlineStart|paddingLeft
            |paddingRight|paddingTop|pageBreakAfter|pageBreakBefore|pageBreakInside|paintOrder|perspective|perspectiveOrigin
            |placeContent|placeItems|placeSelf|pointerEvents|position|prefix|quotes|range|resize|right|rotate|rowGap|rubyAlign
            |rubyMerge|rubyPosition|scale|scrollBehavior|scrollMargin|scrollMarginBlock|scrollMarginBlockEnd|scrollMarginBlockStart
            |scrollMarginBottom|scrollMarginInline|scrollMarginInlineEnd|scrollMarginInlineStart|scrollMarginLeft|scrollMarginRight
            |scrollMarginTop|scrollPadding|scrollPaddingBlock|scrollPaddingBlockEnd|scrollPaddingBlockStart|scrollPaddingBottom
            |scrollPaddingInline|scrollPaddingInlineEnd|scrollPaddingInlineStart|scrollPaddingLeft|scrollPaddingRight
            |scrollPaddingTop|scrollSnapAlign|scrollSnapCoordinate|scrollSnapDestination|scrollSnapStop|scrollSnapType
            |scrollbarColor|scrollbarGutter|scrollbarWidth|shapeImageThreshold|shapeMargin|shapeOutside|shapeRendering|size
            |speakAs|src|stopColor|stopOpacity|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit
            |strokeOpacity|strokeWidth|suffix|symbols|system|tabSize|tableLayout|textAlign|textAlignLast|textAnchor|textCombineUpright
            |textDecoration|textDecorationColor|textDecorationLine|textDecorationSkip|textDecorationSkipInk|textDecorationStyle|textDecorationThickness
            |textEmphasis|textEmphasisColor|textEmphasisPosition|textEmphasisStyle|textIndent|textJustify|textOrientation
            |textOverflow|textRendering|textShadow|textSizeAdjust|textTransform|textUnderlineOffset|textUnderlinePosition|top|touchAction|transform
            |transformBox|transformOrigin|transformStyle|transition|transitionDelay|transitionDuration|transitionProperty|transitionTimingFunction
            |translate|unicodeBidi|unicodeRange|userSelect|userZoom|verticalAlign|visibility|whiteSpace|widows|width|willChange
            |wordBreak|wordSpacing|wordWrap|writingMode|zIndex|zoom
            |alignmentBaseline|baselineShift|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile
            |colorRendering|cx|cy|dominantBaseline|enableBackground|fill|fillOpacity|fillRule|floodColor|floodOpacity
            |glyphOrientationHorizontal|glyphOrientationVertical|height|kerning|lightingColor|markerEnd|markerMid
            |markerStart|r|rx|ry|shapeRendering|stopColor|stopOpacity|stroke|strokeDasharray|strokeDashoffset|strokeLinecap
            |strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|textAnchor|width|x|y
            |adjust|after|align|alignLast|alignment|alignmentAdjust|appearance|attachment|azimuth|backgroundBreak
            |balance|baseline|before|bidi|binding|bookmark|bookmarkLabel|bookmarkLevel|bookmarkTarget|borderLength
            |bottomColor|bottomLeftRadius|bottomRightRadius|bottomStyle|bottomWidth|box|boxAlign|boxDirection
            |boxFlex|boxFlexGroup|boxLines|boxOrdinalGroup|boxOrient|boxPack|break|character|collapse|column
            |columnBreakAfter|columnBreakBefore|count|counter|crop|cue|cueAfter|cueBefore|decoration|decorationBreak
            |delay|displayModel|displayRole|down|drop|dropInitialAfterAdjust|dropInitialAfterAlign|dropInitialBeforeAdjust
            |dropInitialBeforeAlign|dropInitialSize|dropInitialValue|duration|elevation|emphasis|family|fit|fitPosition
            |flexGroup|floatOffset|gap|gridColumns|gridRows|hangingPunctuation|header|hyphenate|hyphenateAfter|hyphenateBefore
            |hyphenateCharacter|hyphenateLines|hyphenateResource|icon|image|increment|indent|index|initialAfterAdjust
            |initialAfterAlign|initialBeforeAdjust|initialBeforeAlign|initialSize|initialValue|inlineBoxAlign|iterationCount
            |justify|label|leftColor|leftStyle|leftWidth|length|level|line|lineStacking|lineStackingRuby|lineStackingShift
            |lineStackingStrategy|lines|list|mark|markAfter|markBefore|marks|marquee|marqueeDirection|marqueePlayCount|marqueeSpeed
            |marqueeStyle|max|min|model|moveTo|name|nav|navDown|navIndex|navLeft|navRight|navUp|new|numeral|offset|ordinalGroup
            |orient|origin|overflowStyle|overhang|pack|page|pagePolicy|pause|pauseAfter|pauseBefore|phonemes|pitch|pitchRange
            |playCount|playDuring|playState|point|presentation|presentationLevel|profile|property|punctuation|punctuationTrim
            |radius|rate|renderingIntent|repeat|replace|reset|resolution|resource|respondTo|rest|restAfter|restBefore|richness
            |rightColor|rightStyle|rightWidth|role|rotation|rotationPoint|rows|ruby|rubyOverhang|rubySpan|rule|ruleColor
            |ruleStyle|ruleWidth|shadow|size|sizeAdjust|sizing|space|spaceCollapse|spacing|span|speak|speakHeader|speakNumeral
            |speakPunctuation|speech|speechRate|speed|stacking|stackingRuby|stackingShift|stackingStrategy|stress|stretch
            |stringSet|style|styleImage|stylePosition|styleType|target|targetName|targetNew|targetPosition|text|textHeight
            |textJustify|textOutline|textReplace|textWrap|timingFunction|topColor|topLeftRadius|topRightRadius|topStyle
            |topWidth|trim|unicode|up|userSelect|variant|voice|voiceBalance|voiceDuration|voiceFamily|voicePitch|voicePitchRange
            |voiceRate|voiceStress|voiceVolume|volume|weight|white|whiteSpaceCollapse|word|wrap
          )\b
        name: support.type.property-name.css.ruko
      - match: (?x)\b(?:ah|apple|atsc|epub|hp|khtml|moz|ms|o|rim|ro|tc|wap|webkit|xv|mso|prince)(?:[\p{Pc}\p{L}&&\P{Ll}][\w&&\P{Lu}]*)+\b
        name: support.type.vendored.property-name.css.ruko

  css-property-values:
    comment: TODO
    patterns:
      - match: |-
          (?x)\b(
            aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow
          )\b
        name: support.constant.color.w3c-standard-color-name.css.ruko
      - match: |-
          (?x)\b(aliceblue|antiquewhite|aquamarine|azure|beige|bisque|blanchedalmond|blueviolet|brown|burlywood|cadetblue|chartreuse|chocolate|coral|cornflowerblue|cornsilk|crimson|cyan|darkblue|darkcyan|darkgoldenrod|darkgray|darkgreen|darkgrey|darkkhaki|darkmagenta|darkolivegreen|darkorange|darkorchid|darkred|darksalmon|darkseagreen|darkslateblue|darkslategray|darkslategrey|darkturquoise|darkviolet|deeppink|deepskyblue|dimgray|dimgrey|dodgerblue|firebrick|floralwhite|forestgreen|gainsboro|ghostwhite|gold|goldenrod|greenyellow|grey|honeydew|hotpink|indianred|indigo|ivory|khaki|lavender|lavenderblush|lawngreen|lemonchiffon|lightblue|lightcoral|lightcyan|lightgoldenrodyellow|lightgray|lightgreen|lightgrey|lightpink|lightsalmon|lightseagreen|lightskyblue|lightslategray|lightslategrey|lightsteelblue|lightyellow|limegreen|linen|magenta|mediumaquamarine|mediumblue|mediumorchid|mediumpurple|mediumseagreen|mediumslateblue|mediumspringgreen|mediumturquoise|mediumvioletred|midnightblue|mintcream|mistyrose|moccasin|navajowhite|oldlace|olivedrab|orangered|orchid|palegoldenrod|palegreen|paleturquoise|palevioletred|papayawhip|peachpuff|peru|pink|plum|powderblue|rebeccapurple|rosybrown|royalblue|saddlebrown|salmon|sandybrown|seagreen|seashell|sienna|skyblue|slateblue|slategray|slategrey|snow|springgreen|steelblue|tan|thistle|tomato|transparent|turquoise|violet|wheat|whitesmoke|yellowgreen)\b
        name: support.constant.color.w3c-extended-color-name.css.ruko
      - match: (?x)\b(currentColor)\b
        name: support.constant.color.current.css.ruko
      - match: |-
          (?x)\b(
            ActiveBorder|ActiveCaption|AppWorkspace|Background|ButtonFace|ButtonHighlight|ButtonShadow|ButtonText|CaptionText|GrayText|Highlight|HighlightText|InactiveBorder|InactiveCaption|InactiveCaptionText|InfoBackground|InfoText|Menu|MenuText|Scrollbar|ThreeDDarkShadow|ThreeDFace|ThreeDHighlight|ThreeDLightShadow|ThreeDShadow|Window|WindowFrame|WindowText
          )\b
        name: support.constant.color.system.css.ruko
      - match: |-
          (?x)\b(
            above|absolute|active|add|additive|after-edge|alias|all|all-petite-caps|all-scroll|all-small-caps|alpha|alphabetic|alternate|alternate-reverse
            |always|antialiased|auto|auto-fill|auto-fit|auto-pos|available|avoid|avoid-column|avoid-page|avoid-region|backwards|balance|baseline|before-edge|below|bevel
            |bidi-override|blink|block|block-axis|block-start|block-end|bold|bolder|border|border-box|both|bottom|bottom-outside|break-all|break-word|bullets
            |butt|capitalize|caption|cell|center|central|char|circle|clip|clone|close-quote|closest-corner|closest-side|col-resize|collapse|color|color-burn
            |color-dodge|column|column-reverse|common-ligatures|compact|condensed|contain|content|content-box|contents|context-menu|contextual|copy|cover
            |crisp-edges|crispEdges|crosshair|cyclic|dark|darken|dashed|decimal|default|dense|diagonal-fractions|difference|digits|disabled|disc|discretionary-ligatures
            |distribute|distribute-all-lines|distribute-letter|distribute-space|dot|dotted|double|double-circle|downleft|downright|e-resize|each-line|ease|ease-in
            |ease-in-out|ease-out|economy|ellipse|ellipsis|embed|end|evenodd|ew-resize|exact|exclude|exclusion|expanded|extends|extra-condensed|extra-expanded
            |fallback|farthest-corner|farthest-side|fill|fill-available|fill-box|filled|fit-content|fixed|flat|flex|flex-end|flex-start|flip|flow-root|forwards|freeze
            |from-image|full-width|geometricPrecision|georgian|grab|grabbing|grayscale|grid|groove|hand|hanging|hard-light|help|hidden|hide
            |historical-forms|historical-ligatures|horizontal|horizontal-tb|hue|icon|ideograph-alpha|ideograph-numeric|ideograph-parenthesis|ideograph-space
            |ideographic|inactive|infinite|inherit|initial|inline|inline-axis|inline-block|inline-end|inline-flex|inline-grid|inline-list-item|inline-start
            |inline-table|inset|inside|inter-character|inter-ideograph|inter-word|intersect|invert|isolate|isolate-override|italic|jis04|jis78|jis83
            |jis90|justify|justify-all|kannada|keep-all|landscape|large|larger|left|light|lighten|lighter|line|line-edge|line-through|linear|linearRGB
            |lining-nums|list-item|local|loose|lowercase|lr|lr-tb|ltr|luminance|luminosity|main-size|mandatory|manipulation|manual|margin-box|match-parent
            |match-source|mathematical|max-content|medium|menu|message-box|middle|min-content|miter|mixed|move|multiply|n-resize|narrower|ne-resize
            |nearest-neighbor|nesw-resize|newspaper|no-change|no-clip|no-close-quote|no-common-ligatures|no-contextual|no-discretionary-ligatures
            |no-drop|no-historical-ligatures|no-open-quote|no-repeat|none|nonzero|normal|not-allowed|nowrap|ns-resize|numbers|numeric|nw-resize|nwse-resize
            |oblique|oldstyle-nums|open|open-quote|optimizeLegibility|optimizeQuality|optimizeSpeed|optional|ordinal|outset|outside|over|overlay|overline|padding
            |padding-box|page|painted|pan-down|pan-left|pan-right|pan-up|pan-x|pan-y|paused|petite-caps|pixelated|plaintext|pointer|portrait|pre|pre-line
            |pre-wrap|preserve-3d|progress|progressive|proportional-nums|proportional-width|proximity|radial|recto|region|relative|remove|repeat|repeat-[xy]
            |reset-size|reverse|revert|ridge|right|rl|rl-tb|round|row|row-resize|row-reverse|row-severse|rtl|ruby|ruby-base|ruby-base-container|ruby-text
            |ruby-text-container|run-in|running|s-resize|saturation|scale-down|screen|scroll|scroll-position|se-resize|semi-condensed|semi-expanded|separate
            |sesame|show|sideways|sideways-left|sideways-lr|sideways-right|sideways-rl|simplified|slashed-zero|slice|small|small-caps|small-caption|smaller
            |smooth|soft-light|solid|space|space-around|space-between|space-evenly|spell-out|square|sRGB|stacked-fractions|start|static|status-bar|swap
            |step-end|step-start|sticky|stretch|strict|stroke|stroke-box|style|sub|subgrid|subpixel-antialiased|subtract|super|sw-resize|symbolic|table
            |table-caption|table-cell|table-column|table-column-group|table-footer-group|table-header-group|table-row|table-row-group|tabular-nums|tb|tb-rl
            |text|text-after-edge|text-before-edge|text-bottom|text-top|thick|thin|titling-caps|top|top-outside|touch|traditional|transparent|triangle
            |ultra-condensed|ultra-expanded|under|underline|unicase|unset|upleft|uppercase|upright|use-glyph-orientation|use-script|verso|vertical
            |vertical-ideographic|vertical-lr|vertical-rl|vertical-text|view-box|visible|visibleFill|visiblePainted|visibleStroke|w-resize|wait|wavy
            |weight|whitespace|wider|words|wrap|wrap-reverse|x|x-large|x-small|xx-large|xx-small|y|zero|zoom-in|zoom-out
            |above|absolute|active|add|additive|afterEdge|alias|all|allPetiteCaps|allScroll|allSmallCaps|alpha|alphabetic|alternate|alternateReverse
            |always|antialiased|auto|autoFill|autoFit|autoPos|available|avoid|avoidColumn|avoidPage|avoidRegion|backwards|balance|baseline|beforeEdge|below|bevel
            |bidiOverride|blink|block|blockAxis|blockStart|blockEnd|bold|bolder|border|borderBox|both|bottom|bottomOutside|breakAll|breakWord|bullets
            |butt|capitalize|caption|cell|center|central|char|circle|clip|clone|closeQuote|closestCorner|closestSide|colResize|collapse|color|colorBurn
            |colorDodge|column|columnReverse|commonLigatures|compact|condensed|contain|content|contentBox|contents|contextMenu|contextual|copy|cover
            |crispEdges|crispEdges|crosshair|cyclic|dark|darken|dashed|decimal|default|dense|diagonalFractions|difference|digits|disabled|disc|discretionaryLigatures
            |distribute|distributeAllLines|distributeLetter|distributeSpace|dot|dotted|double|doubleCircle|downleft|downright|eResize|eachLine|ease|easeIn
            |easeInOut|easeOut|economy|ellipse|ellipsis|embed|end|evenodd|ewResize|exact|exclude|exclusion|expanded|extends|extraCondensed|extraExpanded
            |fallback|farthestCorner|farthestSide|fill|fillAvailable|fillBox|filled|fitContent|fixed|flat|flex|flexEnd|flexStart|flip|flowRoot|forwards|freeze
            |fromImage|fullWidth|geometricPrecision|georgian|grab|grabbing|grayscale|grid|groove|hand|hanging|hardLight|help|hidden|hide
            |historicalForms|historicalLigatures|horizontal|horizontalTb|hue|icon|ideographAlpha|ideographNumeric|ideographParenthesis|ideographSpace
            |ideographic|inactive|infinite|inherit|initial|inline|inlineAxis|inlineBlock|inlineEnd|inlineFlex|inlineGrid|inlineListItem|inlineStart
            |inlineTable|inset|inside|interCharacter|interIdeograph|interWord|intersect|invert|isolate|isolateOverride|italic|jis04|jis78|jis83
            |jis90|justify|justifyAll|kannada|keepAll|landscape|large|larger|left|light|lighten|lighter|line|lineEdge|lineThrough|linear|linearRGB
            |liningNums|listItem|local|loose|lowercase|lr|lrTb|ltr|luminance|luminosity|mainSize|mandatory|manipulation|manual|marginBox|matchParent
            |matchSource|mathematical|maxContent|medium|menu|messageBox|middle|minContent|miter|mixed|move|multiply|nResize|narrower|neResize
            |nearestNeighbor|neswResize|newspaper|noChange|noClip|noCloseQuote|noCommonLigatures|noContextual|noDiscretionaryLigatures
            |noDrop|noHistoricalLigatures|noOpenQuote|noRepeat|none|nonzero|normal|notAllowed|nowrap|nsResize|numbers|numeric|nwResize|nwseResize
            |oblique|oldstyleNums|open|openQuote|optimizeLegibility|optimizeQuality|optimizeSpeed|optional|ordinal|outset|outside|over|overlay|overline|padding
            |paddingBox|page|painted|panDown|panLeft|panRight|panUp|panX|panY|paused|petiteCaps|pixelated|plaintext|pointer|portrait|pre|preLine
            |preWrap|preserve3d|progress|progressive|proportionalNums|proportionalWidth|proximity|radial|recto|region|relative|remove|repeat|repeat[xy]
            |resetSize|reverse|revert|ridge|right|rl|rlTb|round|row|rowResize|rowReverse|rowSeverse|rtl|ruby|rubyBase|rubyBaseContainer|rubyText
            |rubyTextContainer|runIn|running|sResize|saturation|scaleDown|screen|scroll|scrollPosition|seResize|semiCondensed|semiExpanded|separate
            |sesame|show|sideways|sidewaysLeft|sidewaysLr|sidewaysRight|sidewaysRl|simplified|slashedZero|slice|small|smallCaps|smallCaption|smaller
            |smooth|softLight|solid|space|spaceAround|spaceBetween|spaceEvenly|spellOut|square|sRGB|stackedFractions|start|static|statusBar|swap
            |stepEnd|stepStart|sticky|stretch|strict|stroke|strokeBox|style|sub|subgrid|subpixelAntialiased|subtract|super|swResize|symbolic|table
            |tableCaption|tableCell|tableColumn|tableColumnGroup|tableFooterGroup|tableHeaderGroup|tableRow|tableRowGroup|tabularNums|tb|tbRl
            |text|textAfterEdge|textBeforeEdge|textBottom|textTop|thick|thin|titlingCaps|top|topOutside|touch|traditional|transparent|triangle
            |ultraCondensed|ultraExpanded|under|underline|unicase|unset|upleft|uppercase|upright|useGlyphOrientation|useScript|verso|vertical
            |verticalIdeographic|verticalLr|verticalRl|verticalText|viewBox|visible|visibleFill|visiblePainted|visibleStroke|wResize|wait|wavy
            |weight|whitespace|wider|words|wrap|wrapReverse|x|xLarge|xSmall|xxLarge|xxSmall|y|zero|zoomIn|zoomOut
          )\b
        name: support.constant.property-value.css.ruko
      - match: |-
          (?x)\b(
             arabicIndic|armenian|bengali|cambodian|circle|cjkDecimal|cjkEarthlyBranch|cjkHeavenlyStem|cjkIdeographic
            |decimal|decimalLeadingZero|devanagari|disc|disclosureClosed|disclosureOpen|ethiopicHalehameAm
            |ethiopicHalehameTiE[rt]|ethiopicNumeric|georgian|gujarati|gurmukhi|hangul|hangulConsonant|hebrew
            |hiragana|hiraganaIroha|japaneseFormal|japaneseInformal|kannada|katakana|katakanaIroha|khmer
            |koreanHangulFormal|koreanHanjaFormal|koreanHanjaInformal|lao|lowerAlpha|lowerArmenian|lowerGreek
            |lowerLatin|lowerRoman|malayalam|mongolian|myanmar|oriya|persian|simpChineseFormal|simpChineseInformal
            |square|tamil|telugu|thai|tibetan|tradChineseFormal|tradChineseInformal|upperAlpha|upperArmenian
            |upperLatin|upperRoman|urdu
            arabic-indic|armenian|bengali|cambodian|circle|cjk-decimal|cjk-earthly-branch|cjk-heavenly-stem|cjk-ideographic
            |decimal|decimal-leading-zero|devanagari|disc|disclosure-closed|disclosure-open|ethiopic-halehame-am
            |ethiopic-halehame-ti-e[rt]|ethiopic-numeric|georgian|gujarati|gurmukhi|hangul|hangul-consonant|hebrew
            |hiragana|hiragana-iroha|japanese-formal|japanese-informal|kannada|katakana|katakana-iroha|khmer
            |korean-hangul-formal|korean-hanja-formal|korean-hanja-informal|lao|lower-alpha|lower-armenian|lower-greek
            |lower-latin|lower-roman|malayalam|mongolian|myanmar|oriya|persian|simp-chinese-formal|simp-chinese-informal
            |square|tamil|telugu|thai|tibetan|trad-chinese-formal|trad-chinese-informal|upper-alpha|upper-armenian
            |upper-latin|upper-roman|urdu
          )\b
        name: support.constant.property-value.list-style-type.css.ruko
      - match: |-
          (?x)\b(arial|century|comic|courier|garamond|georgia|helvetica|impact|lucida|symbol|system-ui|system|tahoma|times|trebuchet|ui-monospace|ui-rounded|ui-sans-serif|ui-serif|utopia|verdana|webdings|sans-serif|serif|monospace|arial|century|comic|courier|garamond|georgia|helvetica|impact|lucida|symbol|systemUi|system|tahoma|times|trebuchet|uiMonospace|uiRounded|uiSansSerif|uiSerif|utopia|verdana|webdings|sansSerif|serif|monospace)\b
        name: support.constant.font-name.css.ruko

  html-tag-names:
    patterns:
      - match: (?x)\b(all|print|screen|speech|aural|braille|embossed|handheld|projection|tty|tv)\b
        name: support.constant.media.css.ruko
      - match: |-
          (?x)\b(
            a|abbr|acronym|address|altGlyph|altGlyphDef|altGlyphItem|animate|animateColor|animateMotion|animateTransform|annotation|annotationXml|applet|area|article|aside|audio|b|base|basefont|bdi|bdo|bgsound|big|blink|blockquote|body|br|button|canvas|caption|center|circle|cite|clipPath|code|col|colgroup|colorProfile|command|content|cursor|data|datalist|dd|defs|del|desc|details|dfn|dialog|dir|discard|div|dl|dt|elem|ellipse|em|embed|feBlend|feColorMatrix|feComponentTransfer|feComposite|feConvolveMatrix|feDiffuseLighting|feDisplacementMap|feDistantLight|feDropShadow|feFlood|feFuncA|feFuncB|feFuncG|feFuncR|feGaussianBlur|feImage|feMerge|feMergeNode|feMorphology|feOffset|fePointLight|feSpecularLighting|feSpotLight|feTile|feTurbulence|fieldset|figcaption|figure|filter|font|fontFace|fontFaceFormat|fontFaceName|fontFaceSrc|fontFaceUri|footer|foreignObject|form|frame|frameset|g|glyph|glyphRef|hatch|hatchpath|hd|head|header|hgroup|hkern|hr|html|h[1-6]|i|iframe|image|img|input|ins|isindex|kbd|keygen|label|legend|li|line|linearGradient|link|listing|maction|main|maligngroup|malignmark|map|mark|marker|marquee|mask|math|menclose|menu|menuitem|merror|mesh|meshgradient|meshpatch|meshrow|meta|metadata|meter|mfenced|mfrac|mglyph|mi|missingGlyph|mlabeledtr|mlongdiv|mmultiscripts|mn|mo|mover|mpadded|mpath|mphantom|mroot|mrow|ms|mscarries|mscarry|msgroup|msline|mspace|msqrt|msrow|mstack|mstyle|msub|msubsup|msup|mtable|mtd|mtext|mtr|multicol|munder|munderover|nav|nextid|nobr|noembed|noframes|noscript|object|ol|optgroup|option|output|p|param|path|pattern|picture|plaintext|polygon|polyline|pre|progress|q|radialGradient|rb|rect|rp|rt|rtc|ruby|s|samp|script|section|select|semantics|set|shadow|slot|small|solidcolor|source|spacer|span|stop|strike|strong|style|sub|summary|sup|svg|switch|symbol|table|tbody|td|template|text|textarea|textPath|tfoot|th|thead|time|title|tr|track|tref|tspan|tt|u|ul|use|var|video|view|vkern|wbr|xmp
          )\b
        name: entity.name.tag.css.ruko

  entities:
    patterns:
      - include: '#constants'
      - include: '#function-names'
      - include: '#type-names'
      - include: '#variables'

  type-names:
    comment: Names for built-in types
    patterns:
      - comment: Primitive classes
        match: |-
          (?x)\s*(?<![?!]?\.|[?!:]:)\b(
            # upper flat case
            Bool|Char|Rune|Str|Sym|Text|Buf
            |(Big)?(Num|Nat|U?Int|Float|Frac|Real|Imag|Complex)
            # lower flat case
            |bool|char|rune|str|sym|text|buf
            |(big)?(num|nat|u?int|float|frac|real|imag|complex)
            # suffixed numeric types
            # i: signed integer
            # u: unsigned integer
            # f: floating point
            # j: imaginary float
            # c: complex float (real+imaginary)
            |(?i:[iufjc]\d+)
          )\b
        name: support.type.builtin.primitive.ruko
      - comment: Data query classes
        match: |-
          (?x)\s*(?<![?!]?\.|[?!:]:)\b(
            Array|Tuple|Set|Map|Object|Seq|Record|Dict
            |Proc|Range|Stack|Heap|Queue|Tree|Trie|Graph
            |Future|Stream|RegExp|Func|Buffer|FSe[tq]
            # lower flat case
            |array|tuple|set|map|object|seq|record|dict
            |proc|range|stack|heap|queue|tree|trie|graph
            |future|stream|regexp|func|buffer|fse[tq]
          )\b
        name: support.type.builtin.ruko
      - comment: Constant/algebraic classes
        match: |-
          (?x)\s*(?<![?!]?\.|[?!:]:)\b(
            True|False|Null|Void|NaN|Inf|Empty|Unit
            |Any|Mixed|Just|Some|None|Never|(Im)?pure|Const|Undef
            # lower flat case
            |true|false|null|void|nan|inf|empty|unit
            |any|mixed|just|some|none|never|(im)?pure|const|undef
          )\b
        name: support.type.primitive.ruko
      - comment: Error classes | BaseError, etc
        match: \s*\b((\p{Lu}[\w&&\P{Lu}]*)+)?(Error|Exception)\b
        name: support.class.error.ruko
      - comment: Interface classes | IEnumerable, etc
        match: \s*\bI((\p{Lu}[\w&&\P{Lu}]*)+)\b
        name: entity.name.interface.ruko
      - comment: Namespace classes | NSString, etc
        match: \s*\bNS((\p{Lu}[\w&&\P{Lu}]*)+)\b
        name: entity.name.namespace.ruko
      - comment: Trait classes | Serializable, Loggable etc
        match: \s*\b((\p{Lu}[\w&&\P{Lu}]*)+)able\b
        name: support.class.trait.ruko
      - comment: Algebraic data types
        match: \s*\b(Some|None|Just|Ok|Err|Left|Right)\b\s*
        name: support.class.algebraic.ruko
      - include: '#support-classes'

  support-classes:
    comment: Ruko probably won't have a large set of built-in classes,
      so we include common built-in types from major languages
      to improve recognition of cross-language codebases
    patterns:
      - include: source.python#builtin-exceptions
      - include: source.php#class-builtin
      - include: source.swift#builtin-types
      - include: source.swift#builtin-types-builtin-protocol-type
      - include: source.swift#builtin-types-builtin-struct-type
      - include: source.swift#builtin-types-builtin-enum-type
      - include: source.swift#builtin-types-builtin-class-type

      # ShaderLab
      - name: support.type.basic.shaderlab
        match: \b(Range|Float|Int|Color|Vector|2D|3D|Cube|Any)\b
      - include: '#numbers'
      - name: storage.type.structure.shaderlab
        match: \b(Shader|Properties|SubShader|Pass|Category)\b
      - name: support.type.propertyname.shaderlab
        match: \b(Name|Tags|Fallback|CustomEditor|Cull|ZWrite|ZTest|Offset|Blend|BlendOp|ColorMask|AlphaToMask|LOD|Lighting|Stencil|Ref|ReadMask|WriteMask|Comp|CompBack|CompFront|Fail|ZFail|UsePass|GrabPass|Dependency|Material|Diffuse|Ambient|Shininess|Specular|Emission|Fog|Mode|Density|SeparateSpecular|SetTexture|Combine|ConstantColor|Matrix|AlphaTest|ColorMaterial|BindChannels|Bind)\b
      - name: support.type.property-value.shaderlab
        match: \b(Back|Front|On|Off|[RGBA]{1,3}|AmbientAndDiffuse|Emission)\b
      - name: support.type.property-value.comparisonfunction.shaderlab
        match: \b(Less|Greater|LEqual|GEqual|Equal|NotEqual|Always|Never)\b
      - name: support.type.property-value.stenciloperation.shaderlab
        match: \b(Keep|Zero|Replace|IncrSat|DecrSat|Invert|IncrWrap|DecrWrap)\b
      - name: support.type.property-value.texturecombiners.shaderlab
        match: \b(Previous|Primary|Texture|Constant|Lerp|Double|Quad|Alpha)\b
      - name: support.type.property-value.fog.shaderlab
        match: \b(Global|Linear|Exp2|Exp)\b
      - name: support.type.property-value.bindchannels.shaderlab
        match: \b(Vertex|Normal|Tangent|TexCoord0|TexCoord1)\b
      - name: support.type.property-value.blendoperations.shaderlab
        match: \b(Add|Sub|RevSub|Min|Max|LogicalClear|LogicalSet|LogicalCopyInverted|LogicalCopy|LogicalNoop|LogicalInvert|LogicalAnd|LogicalNand|LogicalOr|LogicalNor|LogicalXor|LogicalEquiv|LogicalAndReverse|LogicalAndInverted|LogicalOrReverse|LogicalOrInverted)\b
      - name: support.type.property-value.blendfactors.shaderlab
        match: \b(One|Zero|SrcColor|SrcAlpha|DstColor|DstAlpha|OneMinusSrcColor|OneMinusSrcAlpha|OneMinusDstColor|OneMinusDstAlpha)\b

      # HLSL
      - name: support.type.basic.hlsl
        match: \b(bool([1-4](x[1-4])?)?|double([1-4](x[1-4])?)?|dword|float([1-4](x[1-4])?)?|half([1-4](x[1-4])?)?|int([1-4](x[1-4])?)?|matrix|min10float([1-4](x[1-4])?)?|min12int([1-4](x[1-4])?)?|min16float([1-4](x[1-4])?)?|min16int([1-4](x[1-4])?)?|min16uint([1-4](x[1-4])?)?|unsigned|uint([1-4](x[1-4])?)?|vector|void)\b
      - name: support.type.hlsl
        match: \b(column_major|const|export|extern|globallycoherent|groupshared|inline|inout|in|out|precise|row_major|shared|static|uniform|volatile)\b
      - name: support.type.float.hlsl
        match: \b(snorm|unorm)\b
      - name: support.type.postfix.hlsl
        match: \b(packoffset|register)\b
      - name: support.type.interpolation.hlsl
        match: \b(centroid|linear|nointerpolation|noperspective|sample)\b
      - name: support.type.geometryshader.hlsl
        match: \b(lineadj|line|point|triangle|triangleadj)\b
      - name: support.type.other.hlsl
        match: \b(string)\b
      - name: support.type.object.hlsl
        match: \b(AppendStructuredBuffer|Buffer|ByteAddressBuffer|ConstantBuffer|ConsumeStructuredBuffer|InputPatch|OutputPatch)\b
      - name: support.type.object.rasterizerordered.hlsl
        match: \b(RasterizerOrderedBuffer|RasterizerOrderedByteAddressBuffer|RasterizerOrderedStructuredBuffer|RasterizerOrderedTexture1D|RasterizerOrderedTexture1DArray|RasterizerOrderedTexture2D|RasterizerOrderedTexture2DArray|RasterizerOrderedTexture3D)\b
      - name: support.type.object.rw.hlsl
        match: \b(RWBuffer|RWByteAddressBuffer|RWStructuredBuffer|RWTexture1D|RWTexture1DArray|RWTexture2D|RWTexture2DArray|RWTexture3D)\b
      - name: support.type.object.geometryshader.hlsl
        match: \b(LineStream|PointStream|TriangleStream)\b
      - name: support.type.sampler.legacy.hlsl
        match: \b(sampler|sampler1D|sampler2D|sampler3D|samplerCUBE|sampler_state)\b
      - name: support.type.sampler.hlsl
        match: \b(SamplerState|SamplerComparisonState)\b
      - name: support.type.texture.legacy.hlsl
        match: \b(texture2D|textureCUBE)\b
      - name: support.type.texture.hlsl
        match: \b(Texture1D|Texture1DArray|Texture2D|Texture2DArray|Texture2DMS|Texture2DMSArray|Texture3D|TextureCube|TextureCubeArray)\b
      - name: support.type.structured.hlsl
        match: \b(cbuffer|class|interface|namespace|struct|tbuffer)\b
      - name: support.type.fx.hlsl
        match: \b(BlendState|DepthStencilState|RasterizerState)\b
      - name: support.type.fx.technique.hlsl
        match: \b(pass|technique|technique10|technique11)\b
      - name: support.type.semantic.sm4.hlsl
        match: \b(?i:SV_ClipDistance[0-9]*|SV_CullDistance[0-9]*|SV_Coverage|SV_Depth|SV_DepthGreaterEqual[0-9]*|SV_DepthLessEqual[0-9]*|SV_InstanceID|SV_IsFrontFace|SV_Position|SV_RenderTargetArrayIndex|SV_SampleIndex|SV_StencilRef|SV_Target[0-7]?|SV_VertexID|SV_ViewportArrayIndex)\b
      - name: support.type.semantic.sm5.hlsl
        match: \b(?i:SV_DispatchThreadID|SV_DomainLocation|SV_GroupID|SV_GroupIndex|SV_GroupThreadID|SV_GSInstanceID|SV_InsideTessFactor|SV_OutputControlPointID|SV_TessFactor)\b

      # Perl
      - match: \b(Object|Any|Junction|Whatever|Capture|MatchSignature|Proxy|Matcher|Package|Module|ClassGrammar|Scalar|Array|Hash|KeyHash|KeySet|KeyBagPair|List|Seq|Range|Set|Bag|Mapping|Void|UndefFailure|Exception|Code|Block|Routine|Sub|MacroMethod|Submethod|Regex|Str|str|Blob|Char|ByteCodepoint|Grapheme|StrPos|StrLen|Version|NumComplex|num|complex|Bit|bit|bool|True|FalseIncreasing|Decreasing|Ordered|Callable|AnyCharPositional|Associative|Ordering|KeyExtractorComparator|OrderingPair|IO|KitchenSink|RoleInt|int|int1|int2|int4|int8|int16|int32|int64Rat|rat|rat1|rat2|rat4|rat8|rat16|rat32|rat64Buf|buf|buf1|buf2|buf4|buf8|buf16|buf32|buf64UInt|uint|uint1|uint2|uint4|uint8|uint16|uint32uint64|Abstraction|utf8|utf16|utf32)\b
        name: support.type.perl

      # Objective-C
      - include: source.objc#anonymous_pattern_17
      - include: source.objc#anonymous_pattern_18
      - include: source.objc#anonymous_pattern_19
      - include: source.objc#anonymous_pattern_20
      - include: source.objc#anonymous_pattern_21
      - include: source.objc#anonymous_pattern_22
      - include: source.objc#anonymous_pattern_23
      - include: source.objc#anonymous_pattern_24
      - include: source.objc#anonymous_pattern_25

      # Objective-C++
      - include: source.objcpp#anonymous_pattern_17
      - include: source.objcpp#anonymous_pattern_18
      - include: source.objcpp#anonymous_pattern_19
      - include: source.objcpp#anonymous_pattern_20
      - include: source.objcpp#anonymous_pattern_21
      - include: source.objcpp#anonymous_pattern_22
      - include: source.objcpp#anonymous_pattern_23
      - include: source.objcpp#anonymous_pattern_24
      - include: source.objcpp#anonymous_pattern_25

  support-functions:
    comment: Names for general support functions in Ruko standard library
      organized by naming conventions for maintainability
    patterns:
      - comment: predicate functions
        match: \s*\b(i|ha)s(\p{Lu}[\w&&\P{Lu}]*)+\b\s*
        name: support.function.predicate.ruko
      - comment: conversion functions
        match: \s*\b(to|from)(\p{Lu}[\w&&\P{Lu}]*)+\b\s*
        name: support.function.type.ruko
      - comment: magic functions like __init__, __str__, etc
        match: \s*\b\p{Pc}+([\p{Pc}\p{L}]\w*)+\p{Pc}+\b\s*
        name: support.function.magic.ruko
      - match: \s*\b[gs]et(\p{Lu}[\w&&\P{Lu}]*)+\b\s*
        name: support.function.accessor.ruko
      - include: '#support-functions-core'

  support-functions-core:
    comment: Core built-in functions from major languages,
      to improve recognition of cross-language codebases
    patterns:
      - include: source.objcpp#c_functions
      - include: source.objc#c_functions
      - include: '#html-builtins'

      # Batchfile
      - match: \b(adprep|append|arp|assoc|at|atmadm|attrib|auditpol|autochk|autoconv|autofmt|bcdboot|bcdedit|bdehdcfg|bitsadmin|bootcfg|brea|cacls|cd|certreq|certutil|change|chcp|chdir|chglogon|chgport|chgusr|chkdsk|chkntfs|choice|cipher|clip|cls|clscluadmin|cluster|cmd|cmdkey|cmstp|color|comp|compact|convert|copy|cprofile|cscript|csvde|date|dcdiag|dcgpofix|dcpromo|defra|del|dfscmd|dfsdiag|dfsrmig|diantz|dir|dirquota|diskcomp|diskcopy|diskpart|diskperf|diskraid|diskshadow|dispdiag|doin|dnscmd|doskey|driverquery|dsacls|dsadd|dsamain|dsdbutil|dsget|dsmgmt|dsmod|dsmove|dsquery|dsrm|edit|endlocal|eraseesentutl|eventcreate|eventquery|eventtriggers|evntcmd|expand|extract|fc|filescrn|find|findstr|finger|flattemp|fonde|forfiles|format|freedisk|fsutil|ftp|ftype|fveupdate|getmac|gettype|gpfixup|gpresult|gpupdate|graftabl|hashgen|hep|helpctr|hostname|icacls|iisreset|inuse|ipconfig|ipxroute|irftp|ismserv|jetpack|klist|ksetup|ktmutil|ktpass|label|ldifd|ldp|lodctr|logman|logoff|lpq|lpr|macfile|makecab|manage-bde|mapadmin|md|mkdir|mklink|mmc|mode|more|mount|mountvol|move|mqbup|mqsvc|mqtgsvc|msdt|msg|msiexec|msinfo32|mstsc|nbtstat|net_computer|net_group|net_localgroup|net_print|net_session|net_share|net_start|net_stop|net_use|net_user|net_view|net|netcfg|netdiag|netdom|netsh|netstat|nfsadmin|nfsshare|nfsstat|nlb|nlbmgr|nltest|nslookup|ntackup|ntcmdprompt|ntdsutil|ntfrsutl|openfiles|pagefileconfig|path|pathping|pause|pbadmin|pentnt|perfmon|ping|pnpunatten|pnputil|popd|powercfg|powershell|powershell_ise|print|prncnfg|prndrvr|prnjobs|prnmngr|prnport|prnqctl|prompt|pubprn|pushd|pushprinterconnections|pwlauncher|qappsrv|qprocess|query|quser|qwinsta|rasdial|rcp|rd|rdpsign|regentc|recover|redircmp|redirusr|reg|regini|regsvr32|relog|ren|rename|rendom|repadmin|repair-bde|replace|reset session|rxec|risetup|rmdir|robocopy|route|rpcinfo|rpcping|rsh|runas|rundll32|rwinsta|sc|schtasks|scp|scwcmd|secedit|serverceipoptin|servrmanagercmd|serverweroptin|setspn|setx|sfc|sftp|shadow|shift|showmount|shutdown|sort|ssh|ssh-add|ssh-agent|ssh-keygen|ssh-keyscan|start|storrept|subst|sxstrace|ysocmgr|systeminfo|takeown|tapicfg|taskkill|tasklist|tcmsetup|telnet|tftp|time|timeout|title|tlntadmn|tpmvscmgr|tpmvscmgr|tacerpt|tracert|tree|tscon|tsdiscon|tsecimp|tskill|tsprof|type|typeperf|tzutil|uddiconfig|umount|unlodctr|ver|verifier|verif|vol|vssadmin|w32tm|waitfor|wbadmin|wdsutil|wecutil|wevtutil|where|whoami|winnt|winnt32|winpop|winrm|winrs|winsat|wlbs|wmic|wscript|wsl|xcopy)\b
        name: support.function.batchfile.ruko

      # Perl
      - match: \b(ARGV|DATA|ENV|SIG|STDERR|STDIN|STDOUT|atan2|bind|binmode|bless|caller|chdir|chmod|chomp|chop|chown|chr|chroot|close|closedir|cmp|connect|cos|crypt|dbmclose|dbmopen|defined|delete|dump|each|endgrent|endhostent|endnetent|endprotoent|endpwent|endservent|eof|eq|eval|exec|exists|exp|fcntl|fileno|flock|fork|formline|ge|getc|getgrent|getgrgid|getgrnam|gethostbyaddr|gethostbyname|gethostent|getlogin|getnetbyaddr|getnetbyname|getnetent|getpeername|getpgrp|getppid|getpriority|getprotobyname|getprotobynumber|getprotoent|getpwent|getpwnam|getpwuid|getservbyname|getservbyport|getservent|getsockname|getsockopt|glob|gmtime|grep|gt|hex|import|index|int|ioctl|join|keys|kill|lc|lcfirst|le|length|link|listen|local|localtime|log|lstat|lt|m|map|mkdir|msgctl|msgget|msgrcv|msgsnd|ne|no|oct|open|opendir|ord|pack|pipe|pop|pos|print|printf|push|quotemeta|rand|read|readdir|readlink|recv|ref|rename|reset|reverse|rewinddir|rindex|rmdir|s|say|scalar|seek|seekdir|semctl|semget|semop|send|setgrent|sethostent|setnetent|setpgrp|setpriority|setprotoent|setpwent|setservent|setsockopt|shift|shmctl|shmget|shmread|shmwrite|shutdown|sin|sleep|socket|socketpair|sort|splice|split|sprintf|sqrt|srand|stat|study|substr|symlink|syscall|sysopen|sysread|system|syswrite|tell|telldir|tie|tied|time|times|tr|truncate|uc|ucfirst|umask|undef|unlink|unpack|unshift|untie|utime|values|vec|waitpid|wantarray|warn|write|y|eager|hyper|substr|index|rindex|grep|map|sort|join|lines|hints|chmod|split|reduce|min|max|reverse|truncate|zip|cat|roundrobin|classify|first|sum|keys|values|pairs|defined|delete|exists|elems|end|kv|any|all|one|wrap|shape|key|value|name|pop|push|shift|splice|unshift|floor|ceiling|abs|exp|log|log10|rand|sign|sqrt|sin|cos|tan|round|strand|roots|cis|unpolar|polar|atan2|pick|chop|p5chop|chomp|p5chomp|lc|lcfirst|uc|ucfirst|capitalize|normalize|pack|unpack|quotemeta|comb|samecase|sameaccent|chars|nfd|nfc|nfkd|nfkc|printf|sprintf|caller|evalfile|run|runinstead|nothing|want|bless|chr|ord|gmtime|time|eof|localtime|gethost|getpw|chroot|getlogin|getpeername|kill|fork|wait|perl|graphs|codes|bytes|clone|print|open|read|write|readline|say|seek|close|opendir|readdir|slurp|spurt|shell|run|pos|fmt|vec|link|unlink|symlink|uniq|pair|asin|atan|sec|cosec|cotan|asec|acosec|acotan|sinh|cosh|tanh|asinh|done|acos|acosh|atanh|sech|cosech|cotanh|sech|acosech|acotanh|asech|ok|nok|plan_ok|dies_ok|lives_ok|skip|todo|pass|flunk|force_todo|use_ok|isa_ok|diag|is_deeply|isnt|like|skip_rest|unlike|cmp_ok|eval_dies_ok|nok_error|eval_lives_ok|approx|is_approx|throws_ok|version_lt|plan|EVAL|succ|pred|times|nonce|once|signature|new|connect|operator|undef|undefine|sleep|from|to|infix|postfix|prefix|circumfix|postcircumfix|minmax|lazy|count|unwrap|getc|pi|e|context|void|quasi|body|each|contains|rewinddir|subst|can|isa|flush|arity|assuming|rewind|callwith|callsame|nextwith|nextsame|attr|eval_elsewhere|none|srand|trim|trim_start|trim_end|lastcall|WHAT|WHERE|HOW|WHICH|VAR|WHO|WHENCE|ACCEPTS|REJECTS|not|true|iterator|by|re|im|invert|flip|gist|flat|tree|is_prime|throws_like|trans)\b
        name: support.function.base.perl

      # Ruby
      - match: \b(abort|at_exit|autoload|binding|callcc|caller|caller_locations|chomp|chop|eval|exec|exit|fork|format|gets|global_variables|gsub|lambda|load|local_variables|open|p|print|printf|proc|putc|puts|rand|readline|readlines|select|set_trace_func|sleep|spawn|sprintf|srand|sub|syscall|system|test|trace_var|trap|untrace_var|warn|autoload|exit)\b
        name: support.function.kernel.ruby

      # Lua
      - match: \b(assert|collectgarbage|dofile|error|getfenv|getmetatable|ipairs|load|loadfile|loadstring|module|next|pairs|pcall|print|rawequal|rawget|rawlen|rawset|require|select|setfenv|setmetatable|tonumber|tostring|type|unpack|xpcall)\b
        name: support.function.lua
      - match: \b(coroutine_(create|isyieldable|close|resume|running|status|wrap|yield)|string_(byte|char|dump|find|format|gmatch|gsub|len|lower|match|pack|packsize|rep|reverse|sub|unpack|upper)|table_(concat|insert|maxn|move|pack|remove|sort|unpack)|math_(abs|acos|asin|atan2?|ceil|cosh?|deg|exp|floor|fmod|frexp|ldexp|log|log10|max|min|modf|pow|rad|random|randomseed|sinh?|sqrt|tanh?|tointeger|type)|io_(close|flush|input|lines|open|output|popen|read|tmpfile|type|write)|os_(clock|date|difftime|execute|exit|getenv|remove|rename|setlocale|time|tmpname)|package_(loadlib|seeall|searchpath)|debug_(debug|[gs]etfenv|[gs]ethook|getinfo|[gs]etlocal|[gs]etmetatable|getregistry|[gs]etupvalue|[gs]etuservalue|set[Cc]stacklimit|traceback|upvalueid|upvaluejoin)|bit32_(arshift|band|bnot|bor|btest|bxor|extract|replace|lrotate|lshift|rrotate|rshift)|utf8_(char|codes|codepoint|len|offset))\b
        name: support.function.library.lua

      # PHP (correct as of PHP 8.2)
      - match: (?x)\bapc_(store|sma_info|compile_file|clear_cache|cas|cache_info|inc|dec|define_constants|delete(_file)?|exists|fetch|load_constants|add|bin_(dump|load)(file)?)\b
        name: support.function.apc.php
      - match: (?x)\b(compact|count|current|end|extract|in_array|key(_exists)?|list|nat(case)?sort|next|pos|prev|range|reset|shuffle|sizeof|[ak]?r?sort|u[ak]?sort|array_(all|any|change_key_case|chunk|column|combine|count_values|fill(_keys)?|filter|find(_key)?|flip|is_list|key_(exists|first|last)|keys|map|multisort|pad|pop|product|push|rand|reduce|reverse|search|shift|slice|splice|sum|unique|unshift|values|u?(diff|intersect)(_u?(key|assoc))?|(walk|replace|merge)(_recursive)?))\b
        name: support.function.array.php
      - match: (?x)\b(connection_(aborted|status)|constant|defined?|die|eval|exit|get_browser|__halt_compiler|highlight_(file|string)|hrtime|ignore_user_abort|pack|php_strip_whitespace|show_source|u?sleep|sys_getloadavg|time_(nanosleep|sleep_until)|uniqid|unpack)\b
        name: support.function.basic_functions.php
      - match: \bbc(add|ceil|comp|(div|pow)(mod)?|floor|mod|mul|round|scale|sqrt|sub)\b
        name: support.function.bcmath.php
      - match: \bblenc_encrypt\b
        name: support.function.blenc.php
      - match: \bbz(compress|close|open|decompress|errstr|errno|error|flush|write|read)\b
        name: support.function.bz2.php
      - match: (?x)\b((French|Gregorian|Jewish|Julian)ToJD|cal_(to_jd|info|days_in_month|from_jd)|unixtojd|jdto(unix|jewish)|easter_(date|days)|JD(MonthName|To(Gregorian|Julian|French)|DayOfWeek))\b
        name: support.function.calendar.php
      - match: (?x)\b(__autoload|class_alias|(class|interface|method|property|trait|enum)_exists|is_(a|subclass_of)|get_(class(_(vars|methods))?|(called|parent)_class|(mangled_)?object_vars|declared_(classes|interfaces|traits)))\b
        name: support.function.classobj.php
      - match: (?x)\b(com_(create_guid|print_typeinfo|event_sink|load_typelib|get_active_object|message_pump)|variant_(sub|set(_type)?|not|neg|cast|cat|cmp|int|idiv|imp|or|div|date_(from|to)_timestamp|pow|eqv|fix|and|add|abs|round|get_type|xor|mod|mul))\b
        name: support.function.com.php
      - match: \b(isset|unset|eval|empty|list)\b
        name: support.function.construct.php
      - match: \b(print|echo)\b
        name: support.function.construct.output.php
      - match: \bctype_(space|cntrl|digit|upper|punct|print|lower|alnum|alpha|graph|xdigit)\b
        name: support.function.ctype.php
      - match: (?x)\bcurl_(close|copy_handle|errno|error|escape|exec|getinfo|init|pause|reset|setopt(_array)?|strerror|unescape|upkeep|version|multi_((add|remove)_handle|close|errno|exec|getcontent|info_read|init|select|setopt|strerror)|share_(close|errno|init(_persistent)?|setopt|strerror))\b
        name: support.function.curl.php
      - match: (?x)\b(strtotime|str[fp]time|checkdate|time|timezone_name_(from_abbr|get)|idate|timezone_((location|offset|transitions|version)_get|(abbreviations|identifiers)_list|open)|date(_(sun(rise|set)|sun_info|sub|create(_immutable)?(_from_format)?|timestamp_[gs]et|timezone_[gs]et|time_set|isodate_set|interval_(create_from_date_string|format)|offset_get|diff|default_timezone_[gs]et|date_set|parse(_from_format)?|format|add|get_last_errors|modify))?|localtime|get(date|timeofday)|gm(strftime|date|mktime)|microtime|mktime)\b
        name: support.function.datetime.php
      - match: \bdba_(sync|handlers|nextkey|close|insert|optimize|open|delete|popen|exists|key_split|firstkey|fetch|list|replace)\b
        name: support.function.dba.php
      - match: \bdbx_(sort|connect|compare|close|escape_string|error|query|fetch_row)\b
        name: support.function.dbx.php
      - match: \b(scandir|chdir|chroot|closedir|opendir|dir|rewinddir|readdir|getcwd)\b
        name: support.function.dir.php
      - match: (?x)\beio_(sync(fs)?|sync_file_range|symlink|stat(vfs)?|sendfile|set_min_parallel|set_max_(idle|poll_(reqs|time)|parallel)|seek|n(threads|op|pending|reqs|ready)|chown|chmod|custom|close|cancel|truncate|init|open|dup2|unlink|utime|poll|event_loop|f(sync|stat(vfs)?|chown|chmod|truncate|datasync|utime|allocate)|write|lstat|link|rename|realpath|read(ahead|dir|link)?|rmdir|get_(event_stream|last_error)|grp(_(add|cancel|limit))?|mknod|mkdir|busy)\b
        name: support.function.eio.php
      - match: (?x)\benchant_(dict_(store_replacement|suggest|check|is_in_session|describe|quick_check|add_to_(personal|session)|get_error)|broker_(set_ordering|init|dict_exists|describe|free(_dict)?|list_dicts|request_(pwl_)?dict|get_error))\b
        name: support.function.enchant.php
      - match: \b(split(i)?|sql_regcase|ereg(i)?(_replace)?)\b
        name: support.function.ereg.php
      - match: \b((restore|set)_(error|exception)_handler|trigger_error|debug_(print_)?backtrace|user_error|error_(log|reporting|(clear|get)_last))\b
        name: support.function.errorfunc.php
      - match: \b(shell_exec|system|passthru|proc_(nice|close|terminate|open|get_status)|escapeshell(arg|cmd)|exec)\b
        name: support.function.exec.php
      - match: \b(exif_(thumbnail|tagname|imagetype|read_data)|read_exif_data)\b
        name: support.function.exif.php
      - match: (?x)\bfann_((duplicate|length|merge|shuffle|subset)_train_data|scale_(train(_data)?|(input|output)(_train_data)?)|set_(scaling_params|sarprop_(step_error_(shift|threshold_factor)|temperature|weight_decay_shift)|cascade_(num_candidate_groups|candidate_(change_fraction|limit|stagnation_epochs)|output_(change_fraction|stagnation_epochs)|weight_multiplier|activation_(functions|steepnesses)|(max|min)_(cand|out)_epochs)|callback|training_algorithm|train_(error|stop)_function|(input|output)_scaling_params|error_log|quickprop_(decay|mu)|weight(_array)?|learning_(momentum|rate)|bit_fail_limit|activation_(function|steepness)(_(hidden|layer|output))?|rprop_((decrease|increase)_factor|delta_(max|min|zero)))|save(_train)?|num_(input|output)_train_data|copy|clear_scaling_params|cascadetrain_on_(file|data)|create_((sparse|shortcut|standard)(_array)?|train(_from_callback)?|from_file)|test(_data)?|train(_(on_(file|data)|epoch))?|init_weights|descale_(input|output|train)|destroy(_train)?|print_error|run|reset_(MSE|err(no|str))|read_train_from_file|randomize_weights|get_(sarprop_(step_error_(shift|threshold_factor)|temperature|weight_decay_shift)|num_(input|output|layers)|network_type|MSE|connection_(array|rate)|bias_array|bit_fail(_limit)?|cascade_(num_(candidates|candidate_groups)|(candidate|output)_(change_fraction|limit|stagnation_epochs)|weight_multiplier|activation_(functions|steepnesses)(_count)?|(max|min)_(cand|out)_epochs)|total_(connections|neurons)|training_algorithm|train_(error|stop)_function|err(no|str)|quickprop_(decay|mu)|learning_(momentum|rate)|layer_array|activation_(function|steepness)|rprop_((decrease|increase)_factor|delta_(max|min|zero))))\b
        name: support.function.fann.php
      - match: (?x)\b(symlink|stat|set_file_buffer|chown|chgrp|chmod|copy|clearstatcache|touch|tempnam|tmpfile|is_(dir|(uploaded_)?file|executable|link|readable|writ(e)?able)|disk_(free|total)_space|diskfreespace|dirname|delete|unlink|umask|pclose|popen|pathinfo|parse_ini_(file|string)|fscanf|fstat|fseek|fnmatch|fclose|ftell|ftruncate|file(size|[acm]time|type|inode|owner|perms|group)?|file_(exists|(get|put)_contents)|f(open|puts|putcsv|passthru|eof|flush|write|lock|read|gets(s)?|getc(sv)?)|lstat|lchown|lchgrp|link(info)?|rename|rewind|read(file|link)|realpath(_cache_(get|size))?|rmdir|glob|move_uploaded_file|mkdir|basename|f(data)?sync)\b
        name: support.function.file.php
      - match: \b(finfo_(set_flags|close|open|file|buffer)|mime_content_type)\b
        name: support.function.fileinfo.php
      - match: \bfilter_(has_var|input(_array)?|id|var(_array)?|list)\b
        name: support.function.filter.php
      - match: \b(fastcgi_finish_request|fpm_get_status)\b
        name: support.function.fpm.php
      - match: \b(call_user_(func|method)(_array)?|create_function|unregister_tick_function|forward_static_call(_array)?|function_exists|func_(num_args|get_arg(s)?)|register_(shutdown|tick)_function|get_defined_functions)\b
        name: support.function.funchand.php
      - match: \b((n)?gettext|textdomain|d((n)?gettext|c(n)?gettext)|bind(textdomain|_textdomain_codeset))\b
        name: support.function.gettext.php
      - match: (?x)\bgmp_(scan[01]|strval|sign|sub|setbit|sqrt(rem)?|hamdist|neg|nextprime|com|clrbit|cmp|testbit|intval|init|invert|import|or|div(exact)?|div_(q|qr|r)|jacobi|popcount|pow(m)?|perfect_(square|power)|prob_prime|export|fact|legendre|and|add|abs|root(rem)?|random(_(bits|range|seed))?|gcd(ext)?|xor|mod|mul|binomial|kronecker|lcm)\b
        name: support.function.gmp.php
      - match:
          (?x)\bhash(_(algos|copy|equals|file|final|hkdf|hmac(_(file|algos)?)?|init|pbkdf2|update(_(file|stream))?))?
          \b
        name: support.function.hash.php
      - match: (?x)\b(http_(support|send_(status|stream|content_(disposition|type)|data|file|last_modified)|head|negotiate_(charset|content_type|language)|chunked_decode|cache_(etag|last_modified)|throttle|inflate|deflate|date|post_(data|fields)|put_(data|file|stream)|persistent_handles_(count|clean|ident)|parse_(cookie|headers|message|params)|redirect|request(_(method_(exists|name|(un)?register)|body_encode))?|get(_request_(headers|body(_stream)?))?|match_(etag|modified|request_header)|build_(cookie|str|url))|ob_(etag|deflate|inflate)handler)\b
        name: support.function.http.php
      - match: \b(iconv(_(str(pos|len|rpos)|substr|[gs]et_encoding|mime_(decode(_headers)?|encode)))?|ob_iconv_handler)\b
        name: support.function.iconv.php
      - match: \biis_((start|stop)_(service|server)|set_(script_map|server_rights|dir_security|app_settings)|(add|remove)_server|get_(script_map|service_state|server_(rights|by_(comment|path))|dir_security))\b
        name: support.function.iisfunc.php
      - match: (?x)\b(iptc(embed|parse)|(jpeg|png)2wbmp|gd_info|getimagesize(fromstring)?|image(s[xy]|scale|(char|string)(up)?|set(clip|style|thickness|tile|interpolation|pixel|brush)|savealpha|convolution|copy(resampled|resized|merge(gray)?)?|colors(forindex|total)|color(set|closest(alpha|hwb)?|transparent|deallocate|(allocate|exact|resolve)(alpha)?|at|match)|crop(auto)?|create(truecolor|from(avif|bmp|string|jpeg|png|wbmp|webp|gif|gd(2(part)?)?|tga|xpm|xbm))?|types|ttf(bbox|text)|truecolortopalette|istruecolor|interlace|2wbmp|destroy|dashedline|jpeg|_type_to_(extension|mime_type)|ps(slantfont|text|(encode|extend|free|load)font|bbox)|png|polygon|palette(copy|totruecolor)|ellipse|ft(text|bbox)|filter|fill|filltoborder|filled(arc|ellipse|polygon|rectangle)|font(height|width)|flip|webp|wbmp|line|loadfont|layereffect|antialias|affine(matrix(concat|get))?|alphablending|arc|rotate|rectangle|gif|gd2?|gammacorrect|grab(screen|window)|xbm|resolution|openpolygon|get(clip|interpolation)|avif|bmp))\b
        name: support.function.image.php
      - match: (?x)\b(sys_get_temp_dir|set_(time_limit|include_path|magic_quotes_runtime)|cli_[gs]et_process_title|ini_(alter|get(_all)?|restore|set)|zend_(thread_id|version|logo_guid)|dl|php(credits|info|version)|php_(sapi_name|ini_(scanned_files|loaded_file)|uname|logo_guid)|putenv|extension_loaded|version_compare|assert(_options)?|restore_include_path|gc_(collect_cycles|disable|enable(d)?)|getopt|get_(cfg_var|current_user|defined_constants|extension_funcs|include_path|included_files|loaded_extensions|magic_quotes_(gpc|runtime)|required_files|resources)|get(env|lastmod|rusage|my(inode|[gup]id))|memory_get_(peak_)?usage|main|magic_quotes_runtime)\b
        name: support.function.info.php
      - match: (?x)\bibase_(set_event_handler|service_(attach|detach)|server_info|num_(fields|params)|name_result|connect|commit(_ret)?|close|trans|delete_user|drop_db|db_info|pconnect|param_info|prepare|err(code|msg)|execute|query|field_info|fetch_(assoc|object|row)|free_(event_handler|query|result)|wait_event|add_user|affected_rows|rollback(_ret)?|restore|gen_id|modify_user|maintain_db|backup|blob_(cancel|close|create|import|info|open|echo|add|get))\b
        name: support.function.interbase.php
      - match: (?x)\b(normalizer_(normalize|is_normalized)|idn_to_(unicode|utf8|ascii)|numfmt_(set_(symbol|(text_)?attribute|pattern)|create|(parse|format)(_currency)?|get_(symbol|(text_)?attribute|pattern|error_(code|message)|locale))|collator_(sort(_with_sort_keys)?|set_(attribute|strength)|compare|create|asort|get_(strength|sort_key|error_(code|message)|locale|attribute))|transliterator_(create(_(inverse|from_rules))?|transliterate|list_ids|get_error_(code|message))|intl(cal|tz)_get_error_(code|message)|intl_(is_failure|error_name|get_error_(code|message))|datefmt_(set_(calendar|lenient|pattern|timezone(_id)?)|create|is_lenient|parse|format(_object)?|localtime|get_(calendar(_object)?|time(type|zone(_id)?)|datetype|pattern|error_(code|message)|locale))|locale_(set_default|compose|canonicalize|parse|filter_matches|lookup|accept_from_http|get_(script|display_(script|name|variant|language|region)|default|primary_language|keywords|all_variants|region))|resourcebundle_(create|count|locales|get(_(error_(code|message)))?)|grapheme_(str(i?str|r?i?pos|len|_split)|substr|extract)|msgfmt_(set_pattern|create|(format|parse)(_message)?|get_(pattern|error_(code|message)|locale)))\b
        name: support.function.intl.php
      - match: \bjson_(decode|encode|last_error(_msg)?|validate)\b
        name: support.function.json.php
      - match: (?x)\bldap_(start|tls|sort|search|sasl_bind|set_(option|rebind_proc)|(first|next)_(attribute|entry|reference)|connect|control_paged_result(_response)?|count_entries|compare|close|t61_to_8859|8859_to_t61|dn2ufn|delete|unbind|parse_(reference|result)|escape|errno|err2str|error|explode_dn|bind|free_result|list|add|rename|read|get_(option|dn|entries|values(_len)?|attributes)|modify(_batch)?|mod_(add|del|replace))\b
        name: support.function.ldap.php
      - match: \blibxml_(set_(streams_context|external_entity_loader)|clear_errors|disable_entity_loader|use_internal_errors|get_(errors|last_error))\b
        name: support.function.libxml.php
      - match: \b(ezmlm_hash|mail)\b
        name: support.function.mail.php
      - match: (?x)\b(a?(cos|sin|tan)h?|sqrt|srand|hypot|hexdec|ceil|is_(nan|(in)?finite)|octdec|dec(hex|oct|bin)|deg2rad|pi|pow|exp(m1)?|floor|f(div|mod|pow)|lcg_value|log(1[p0])?|atan2|abs|round|rand|rad2deg|getrandmax|mt_(srand|rand|getrandmax)|max|min|bindec|base_convert|intdiv)\b
        name: support.function.math.php
      - match: (?x)\bmb_(str(cut|str|to(lower|upper)|istr|ipos|imwidth|pos|width|len|rchr|richr|ripos|rpos|_pad|_split)|substitute_character|substr(_count)?|split|send_mail|http_(input|output)|check_encoding|convert_(case|encoding|kana|variables)|internal_encoding|output_handler|decode_(numericentity|mimeheader)|detect_(encoding|order)|parse_str|preferred_mime_name|encoding_aliases|encode_(numericentity|mimeheader)|ereg(i(_replace)?)?|ereg_(search(_(get(pos|regs)|init|regs|(set)?pos))?|replace(_callback)?|match)|list_encodings|language|regex_(set_options|encoding)|get_info|[lr]?trim|[lu]cfirst|ord|chr|scrub)\b
        name: support.function.mbstring.php
      - match: (?x)\b(mcrypt_(cfb|create_iv|cbc|ofb|decrypt|encrypt|ecb|list_(algorithms|modes)|generic(_((de)?init|end))?|enc_(self_test|is_block_(algorithm|algorithm_mode|mode)|get_(supported_key_sizes|(block|iv|key)_size|(algorithms|modes)_name))|get_(cipher_name|(block|iv|key)_size)|module_(close|self_test|is_block_(algorithm|algorithm_mode|mode)|open|get_(supported_key_sizes|algo_(block|key)_size)))|mdecrypt_generic)\b
        name: support.function.mcrypt.php
      - match: \bmemcache_debug\b
        name: support.function.memcache.php
      - match: \bmhash(_(count|keygen_s2k|get_(hash_name|block_size)))?\b
        name: support.function.mhash.php
      - match: \b(log_(cmd_(insert|delete|update)|killcursor|write_batch|reply|getmore)|bson_(decode|encode))\b
        name: support.function.mongo.php
      - match: (?x)\bmysql_(stat|set_charset|select_db|num_(fields|rows)|connect|client_encoding|close|create_db|escape_string|thread_id|tablename|insert_id|info|data_seek|drop_db|db_(name|query)|unbuffered_query|pconnect|ping|errno|error|query|field_(seek|name|type|table|flags|len)|fetch_(object|field|lengths|assoc|array|row)|free_result|list_(tables|dbs|processes|fields)|affected_rows|result|real_escape_string|get_(client|host|proto|server)_info)\b
        name: support.function.mysql.php
      - match: (?x)\bmysqli_(ssl_set|store_result|stat|send_(query|long_data)|set_(charset|opt|local_infile_(default|handler))|stmt_(store_result|send_long_data|next_result|close|init|data_seek|prepare|execute|fetch|free_result|attr_[gs]et|result_metadata|reset|get_(result|warnings)|more_results|bind_(param|result))|select_db|slave_query|savepoint|next_result|change_user|character_set_name|connect|commit|client_encoding|close|thread_safe|init|options|(enable|disable)_(reads_from_master|rpl_parse)|dump_debug_info|debug|data_seek|use_result|ping|poll|param_count|prepare|escape_string|execute|embedded_server_(start|end)|kill|query|field_seek|free_result|autocommit|rollback|report|refresh|fetch(_(object|fields|field(_direct)?|assoc|all|array|row))?|rpl_(parse_enabled|probe|query_type)|release_savepoint|reap_async_query|real_(connect|escape_string|query)|more_results|multi_query|get_(charset|connection_stats|client_(stats|info|version)|cache_stats|warnings|links_stats|metadata)|master_query|bind_(param|result)|begin_transaction)\b
        name: support.function.mysqli.php
      - match: \bmysqlnd_memcache_(set|get_config)\b
        name: support.function.mysqlnd-memcache.php
      - match: \bmysqlnd_ms_(set_(user_pick_server|qos)|dump_servers|query_is_select|fabric_select_(shard|global)|get_(stats|last_(used_connection|gtid))|xa_(commit|rollback|gc|begin)|match_wild)\b
        name: support.function.mysqlnd-ms.php
      - match: \bmysqlnd_qc_(set_(storage_handler|cache_condition|is_select|user_handlers)|clear_cache|get_(normalized_query_trace_log|core_stats|cache_info|query_trace_log|available_handlers))\b
        name: support.function.mysqlnd-qc.php
      - match: \bmysqlnd_uh_(set_(statement|connection)_proxy|convert_to_mysqlnd)\b
        name: support.function.mysqlnd-uh.php
      - match: (?x)\b(syslog|socket_(set_(blocking|timeout)|get_status)|set(raw)?cookie|http_response_code|openlog|headers_(list|sent)|header(_(register_callback|remove))?|checkdnsrr|closelog|inet_(ntop|pton)|ip2long|openlog|dns_(check_record|get_(record|mx))|define_syslog_variables|(p)?fsockopen|long2ip|get(servby(name|port)|host(name|by(name(l)?|addr))|protoby(name|number)|mxrr)|http_(clear|get)_last_response_headers|net_get_interfaces|request_parse_body)\b
        name: support.function.network.php
      - match: \bnsapi_(virtual|response_headers|request_headers)\b
        name: support.function.nsapi.php
      - match: (?x)\b(oci(statementtype|setprefetch|serverversion|savelob(file)?|numcols|new(collection|cursor|descriptor)|nlogon|column(scale|size|name|type(raw)?|isnull|precision)|coll(size|trim|assign(entity)?|append|getelem|max)|commit|closelob|cancel|internaldebug|definebyname|plogon|parse|error|execute|fetch(statement|into)?|free(statement|collection|cursor|desc)|write(temporarylob|lobtofile)|loadlob|log(on|off)|rowcount|rollback|result|bindbyname)|oci_(statement_type|set_(client_(info|identifier)|prefetch|edition|action|module_name)|server_version|num_(fields|rows)|new_(connect|collection|cursor|descriptor)|connect|commit|client_version|close|cancel|internal_debug|define_by_name|pconnect|password_change|parse|error|execute|bind_(array_)?by_name|field_(scale|size|name|type(_raw)?|is_null|precision)|fetch(_(object|assoc|all|array|row))?|free_(statement|descriptor)|lob_(copy|is_equal)|rollback|result|get_implicit_resultset))\b
        name: support.function.oci8.php
      - match: \bopcache_(compile_file|invalidate|is_script_cached|reset|get_(status|configuration))\b
        name: support.function.opcache.php
      - match: (?x)\bopenssl_(sign|spki_(new|export(_challenge)?|verify)|seal|csr_(sign|new|export(_to_file)?|get_(subject|public_key))|cipher_(iv|key)_length|open|dh_compute_key|digest|decrypt|public_(decrypt|encrypt)|encrypt|error_string|pkcs12_(export(_to_file)?|read)|(cms|pkcs7)_(sign|decrypt|encrypt|verify|read)|verify|free_key|random_pseudo_bytes|pkey_(derive|new|export(_to_file)?|free|get_(details|public|private))|private_(decrypt|encrypt)|pbkdf2|get_((cipher|md)_methods|cert_locations|curve_names|(public|private)key)|x509_(check_private_key|checkpurpose|parse|export(_to_file)?|fingerprint|free|read|verify))\b
        name: support.function.openssl.php
      - match: (?x)\b(output_(add_rewrite_var|reset_rewrite_vars)|flush|ob_(start|clean|implicit_flush|end_(clean|flush)|flush|list_handlers|gzhandler|get_(status|contents|clean|flush|length|level)))\b
        name: support.function.output.php
      - match: \bpassword_(algos|hash|needs_rehash|verify|get_info)\b
        name: support.function.password.php
      - match: (?x)\bpcntl_(alarm|async_signals|errno|exec|r?fork|get_last_error|[gs]et(cpuaffinity|priority)|signal(_(dispatch|get_handler))?|sig(procmask|timedwait|waitinfo)|strerror|unshare|wait(p?id)?|wexitstatus|wif(exited|signaled|stopped)|w(stop|term)sig)\b
        name: support.function.pcntl.php
      - match: (?x)\bpg_(socket|send_(prepare|execute|query(_params)?)|set_(client_encoding|error_verbosity)|select|host|num_(fields|rows)|consume_input|connection_(status|reset|busy)|connect(_poll)?|convert|copy_(from|to)|client_encoding|close|cancel_query|tty|transaction_status|trace|insert|options|delete|dbname|untrace|unescape_bytea|update|pconnect|ping|port|put_line|parameter_status|prepare|version|query(_params)?|escape_(string|identifier|literal|bytea)|end_copy|execute|flush|free_result|last_(notice|error|oid)|field_(size|num|name|type(_oid)?|table|is_null|prtlen)|affected_rows|result_(status|seek|error(_field)?)|fetch_(object|assoc|all(_columns)?|array|row|result)|get_(notify|pid|result)|meta_data|lo_(seek|close|create|tell|truncate|import|open|unlink|export|write|read(_all)?)|)\b
        name: support.function.pgsql.php
      - match: \b(virtual|getallheaders|apache_([gs]etenv|note|child_terminate|lookup_uri|response_headers|reset_timeout|request_headers|get_(version|modules)))\b
        name: support.function.php_apache.php
      - match: \bdom_import_simplexml\b
        name: support.function.php_dom.php
      - match: (?x)\bftp_(ssl_connect|systype|site|size|set_option|nlist|nb_(continue|f?(put|get))|ch(dir|mod)|connect|cdup|close|delete|put|pwd|pasv|exec|quit|f(put|get)|login|alloc|rename|raw(list)?|rmdir|get(_option)?|mdtm|mkdir)\b
        name: support.function.php_ftp.php
      - match: (?x)\bimap_((create|delete|list|rename|scan)(mailbox)?|status|sort|subscribe|set_quota|set(flag_full|acl)|search|savebody|num_(recent|msg)|check|close|clearflag_full|thread|timeout|open|header(info)?|headers|append|alerts|reopen|8bit|unsubscribe|undelete|utf7_(decode|encode)|utf8|uid|ping|errors|expunge|qprint|gc|fetch(structure|header|text|mime|body)|fetch_overview|lsub|list(scan|subscribed)|last_error|rfc822_(parse_(headers|adrlist)|write_address)|get(subscribed|acl|mailboxes)|get_quota(root)?|msgno|mime_header_decode|mail_(copy|compose|move)|mail|mailboxmsginfo|binary|body(struct)?|base64)\b
        name: support.function.php_imap.php
      - match: (?x)\bmssql_(select_db|num_(fields|rows)|next_result|connect|close|init|data_seek|pconnect|execute|query|field_(seek|name|type|length)|fetch_(object|field|assoc|array|row|batch)|free_(statement|result)|rows_affected|result|guid_string|get_last_message|min_(error|message)_severity|bind)\b
        name: support.function.php_mssql.php
      - match: (?x)\bodbc_(statistics|specialcolumns|setoption|num_(fields|rows)|next_result|connect|columns|columnprivileges|commit|cursor|close(_all)?|tables|tableprivileges|do|data_source|pconnect|primarykeys|procedures|procedurecolumns|prepare|error(msg)?|exec(ute)?|field_(scale|num|name|type|precision|len)|foreignkeys|free_result|fetch_(into|object|array|row)|longreadlen|autocommit|rollback|result(_all)?|gettypeinfo|binmode)\b
        name: support.function.php_odbc.php
      - match: \bpreg_(split|quote|filter|last_error(_msg)?|replace(_callback(_array)?)?|grep|match(_all)?)\b
        name: support.function.php_pcre.php
      - match: \b(spl_(classes|object_hash|autoload(_(call|unregister|extensions|functions|register))?)|class_(implements|uses|parents)|iterator_(count|to_array|apply))\b
        name: support.function.php_spl.php
      - match: \bzip_(close|open|entry_(name|compressionmethod|compressedsize|close|open|filesize|read)|read)\b
        name: support.function.php_zip.php
      - match: (?x)\bposix_(strerror|set(s|e?u|[ep]?g)id|ctermid|ttyname|times|isatty|initgroups|uname|errno|kill|e?access|get(sid|cwd|uid|pid|ppid|pwnam|pwuid|pgid|pgrp|euid|egid|login|rlimit|gid|grnam|groups|grgid)|get_last_error|mknod|mkfifo|(sys|f?path)conf|setrlimit)\b
        name: support.function.posix.php
      - match: \bset(thread|proc)title\b
        name: support.function.proctitle.php
      - match: (?x)\bpspell_(store_replacement|suggest|save_wordlist|new(_(config|personal))?|check|clear_session|config_(save_repl|create|ignore|(data|dict)_dir|personal|runtogether|repl|mode)|add_to_(session|personal))\b
        name: support.function.pspell.php
      - match: \breadline(_(completion_function|clear_history|callback_(handler_(install|remove)|read_char)|info|on_new_line|write_history|list_history|add_history|redisplay|read_history))?\b
        name: support.function.readline.php
      - match: \brecode(_(string|file))?\b
        name: support.function.recode.php
      - match: \brrd(c_disconnect|_(create|tune|info|update|error|version|first|fetch|last(update)?|restore|graph|xport))\b
        name: support.function.rrd.php
      - match: (?x)\b(shm_((get|has|remove|put)_var|detach|attach|remove)|sem_(acquire|release|remove|get)|ftok|msg_((get|remove|set|stat)_queue|send|queue_exists|receive))\b
        name: support.function.sem.php
      - match: (?x)\bsession_(status|start|set_(save_handler|cookie_params)|save_path|name|commit|cache_(expire|limiter)|is_registered|id|destroy|decode|unset|unregister|encode|write_close|abort|reset|register(_shutdown)?|(regenerate|create)_id|get_cookie_params|module_name|gc)\b
        name: support.function.session.php
      - match: \bshmop_(size|close|open|delete|write|read)\b
        name: support.function.shmop.php
      - match: \bsimplexml_(import_dom|load_(string|file))\b
        name: support.function.simplexml.php
      - match: (?x)\b(snmp(walk(oid)?|realwalk|get(next)?|set)|snmp_(set_(valueretrieval|quick_print|enum_print|oid_(numeric_print|output_format))|read_mib|get_(valueretrieval|quick_print))|snmp[23]_(set|walk|real_walk|get(next)?))\b
        name: support.function.snmp.php
      - match: \b(is_soap_fault|use_soap_error_handler)\b
        name: support.function.soap.php
      - match: (?x)\bsocket_(accept|addrinfo_(bind|connect|explain|lookup)|atmark|bind|(clear|last)_error|close|cmsg_space|connect|create(_(listen|pair))?|(ex|im)port_stream|[gs]et_option|[gs]etopt|get(peer|sock)name|listen|read|recv(from|msg)?|select|send(msg|to)?|set_(non)?block|shutdown|strerror|write|wsaprotocol_info_(export|import|release))\b
        name: support.function.sockets.php
      - match: (?x)\bsqlite_(single_query|seek|has_(more|prev)|num_(fields|rows)|next|changes|column|current|close|create_(aggregate|function)|open|unbuffered_query|udf_(decode|encode)_binary|popen|prev|escape_string|error_string|exec|valid|key|query|field_name|factory|fetch_(string|single|column_types|object|all|array)|lib(encoding|version)|last_(insert_rowid|error)|array_query|rewind|busy_timeout)\b
        name: support.function.sqlite.php
      - match: (?x)\bsqlsrv_(send_stream_data|server_info|has_rows|num_(fields|rows)|next_result|connect|configure|commit|client_info|close|cancel|prepare|errors|execute|query|field_metadata|fetch(_(array|object))?|free_stmt|rows_affected|rollback|get_(config|field)|begin_transaction)\b
        name: support.function.sqlsrv.php
      - match: (?x)\bstats_(harmonic_mean|covariance|standard_deviation|skew|cdf_(noncentral_(chisquare|f)|negative_binomial|chisquare|cauchy|t|uniform|poisson|exponential|f|weibull|logistic|laplace|gamma|binomial|beta)|stat_(noncentral_t|correlation|innerproduct|independent_t|powersum|percentile|paired_t|gennch|binomial_coef)|dens_(normal|negative_binomial|chisquare|cauchy|t|pmf_(hypergeometric|poisson|binomial)|exponential|f|weibull|logistic|laplace|gamma|beta)|den_uniform|variance|kurtosis|absolute_deviation|rand_(setall|phrase_to_seeds|ranf|get_seeds|gen_(noncentral_[ft]|noncenral_chisquare|normal|chisquare|t|int|i(uniform|poisson|binomial(_negative)?)|exponential|f(uniform)?|gamma|beta)))\b
        name: support.function.stats.php
      - match: (?x)\bstream_(bucket_(new|prepend|append|make_writeable)|context_(create|[gs]et_(options?|default|params))|copy_to_stream|filter_((ap|pre)pend|register|remove)|get_(contents|filters|line|meta_data|transports|wrappers)|is(atty|_local)|notification_callback|register_wrapper|resolve_include_path|select|set_(blocking|chunk_size|(read|write)_buffer|timeout)|socket_(accept|client|enable_crypto|get_name|pair|recvfrom|sendto|server|shutdown)|supports_lock|wrapper_((un)?register|restore))\b
        name: support.function.streamsfuncs.php
      - match: (?x)\b(money_format|md5(_file)?|metaphone|bin2hex|sscanf|sha1(_file)?|str(str|c?spn|n(at)?(case)?cmp|chr|coll|(case)?cmp|to(upper|lower)|tok|tr|istr|pos|pbrk|len|rchr|ri?pos|rev)|str_(getcsv|i?replace|pad|repeat|rot13|shuffle|split|word_count|contains|(starts|ends)_with|(in|de)crement)|strip(c?slashes|os)|strip_tags|similar_text|soundex|substr(_(count|compare|replace))?|setlocale|html(specialchars(_decode)?|entities)|html_entity_decode|hex2bin|hebrev(c)?|number_format|nl2br|nl_langinfo|chop|chunk_split|chr|convert_(cyr_string|uu(decode|encode))|count_chars|crypt|crc32|trim|implode|ord|uc(first|words)|join|parse_str|print(f)?|echo|explode|v?[fs]?printf|quoted_printable_(decode|encode)|quotemeta|wordwrap|lcfirst|[lr]trim|localeconv|levenshtein|addc?slashes|get_html_translation_table)\b
        name: support.function.string.php
      - match: (?x)\bsybase_(set_message_handler|select_db|num_(fields|rows)|connect|close|deadlock_retry_count|data_seek|unbuffered_query|pconnect|query|field_seek|fetch_(object|field|assoc|array|row)|free_result|affected_rows|result|get_last_message|min_(client|error|message|server)_severity)\b
        name: support.function.sybase.php
      - match: \b(taint|is_tainted|untaint)\b
        name: support.function.taint.php
      - match: (?x)\b(tidy_([gs]etopt|set_encoding|save_config|config_count|clean_repair|is_(xhtml|xml)|diagnose|(access|error|warning)_count|load_config|reset_config|(parse|repair)_(string|file)|get_(status|html(_ver)?|head|config|output|opt_doc|root|release|body))|ob_tidyhandler)\b
        name: support.function.tidy.php
      - match: \btoken_(name|get_all)\b
        name: support.function.tokenizer.php
      - match: (?x)\btrader_(stoch(f|r|rsi)?|stddev|sin(h)?|sum|sub|set_(compat|unstable_period)|sqrt|sar(ext)?|sma|ht_(sine|trend(line|mode)|dc(period|phase)|phasor)|natr|cci|cos(h)?|correl|cdl(shootingstar|shortline|sticksandwich|stalledpattern|spinningtop|separatinglines|hikkake(mod)?|highwave|homingpigeon|hangingman|harami(cross)?|hammer|concealbabyswall|counterattack|closingmarubozu|thrusting|tasukigap|takuri|tristar|inneck|invertedhammer|identical3crows|2crows|onneck|doji(star)?|darkcloudcover|dragonflydoji|unique3river|upsidegap2crows|3(starsinsouth|inside|outside|whitesoldiers|linestrike|blackcrows)|piercing|engulfing|evening(doji)?star|kicking(bylength)?|longline|longleggeddoji|ladderbottom|advanceblock|abandonedbaby|risefall3methods|rickshawman|gapsidesidewhite|gravestonedoji|xsidegap3methods|morning(doji)?star|mathold|matchinglow|marubozu|belthold|breakaway)|ceil|cmo|tsf|typprice|t3|tema|tan(h)?|trix|trima|trange|obv|div|dema|dx|ultosc|ppo|plus_d[im]|errno|exp|ema|var|kama|floor|wclprice|willr|wma|ln|log10|bop|beta|bbands|linearreg(_(slope|intercept|angle))?|asin|acos|atan|atr|adosc|ad|add|adx(r)?|apo|avgprice|aroon(osc)?|rsi|roc|rocp|rocr(100)?|get_(compat|unstable_period)|min(index)?|minus_d[im]|minmax(index)?|mid(point|price)|mom|mult|medprice|mfi|macd(ext|fix)?|mavp|max(index)?|ma(ma)?)\b
        name: support.function.trader.php
      - match: \buopz_(copy|compose|implement|overload|delete|undefine|extend|function|flags|restore|rename|redefine|backup)\b
        name: support.function.uopz.php
      - match: \b(http_build_query|(raw)?url(decode|encode)|parse_url|get_(headers|meta_tags)|base64_(decode|encode))\b
        name: support.function.url.php
      - match: (?x)\b((bool|double|float|int|str)val|debug_zval_dump|empty|get_(debug_type|defined_vars|resource_(id|type))|[gs]ettype|is_(array|bool|callable|countable|double|float|int(eger)?|iterable|long|null|numeric|object|real|resource|scalar|string)|isset|print_r|(un)?serialize|unset|var_(dump|export))\b
        name: support.function.var.php
      - match: \bwddx_(serialize_(value|vars)|deserialize|packet_(start|end)|add_vars)\b
        name: support.function.wddx.php
      - match: \bxhprof_(sample_)?(disable|enable)\b
        name: support.function.xhprof.php
      - match: (?x)\b(utf8_(decode|encode)|xml_(set_((notation|(end|start)_namespace|unparsed_entity)_decl_handler|(character_data|default|element|external_entity_ref|processing_instruction)_handler|object)|parse(_into_struct)?|parser_([gs]et_option|create(_ns)?|free)|error_string|get_(current_((column|line)_number|byte_index)|error_code)))\b
        name: support.function.xml.php
      - match: (?x)\bxmlrpc_(server_(call_method|create|destroy|add_introspection_data|register_(introspection_callback|method))|is_fault|decode(_request)?|parse_method_descriptions|encode(_request)?|[gs]et_type)\b
        name: support.function.xmlrpc.php
      - match: (?x)\bxmlwriter_((end|start|write)_(comment|cdata|dtd(_(attlist|entity|element))?|document|pi|attribute|element)|(start|write)_(attribute|element)_ns|write_raw|set_indent(_string)?|text|output_memory|open_(memory|uri)|full_end_element|flush|)\b
        name: support.function.xmlwriter.php
      - match: (?x)\b(zlib_(decode|encode|get_coding_type)|readgzfile|gz(seek|compress|close|tell|inflate|open|decode|deflate|uncompress|puts|passthru|encode|eof|file|write|rewind|read|getc|getss?)|deflate_(add|init)|inflate_(add|get_(read_len|status)|init))\b
        name: support.function.zlib.php

      # Lua (correct as of Lua 5.4)
      - match: \b(assert|collectgarbage|dofile|error|getfenv|getmetatable|ipairs|load|loadfile|loadstring|module|next|pairs|pcall|print|rawequal|rawget|rawlen|rawset|require|select|setfenv|setmetatable|tonumber|tostring|type|unpack|xpcall)\b
        name: support.function.lua
      - match: \b(coroutine_(create|isyieldable|close|resume|running|status|wrap|yield)|string_(byte|char|dump|find|format|gmatch|gsub|len|lower|match|pack|packsize|rep|reverse|sub|unpack|upper)|table_(concat|insert|maxn|move|pack|remove|sort|unpack)|math_(abs|acos|asin|atan2?|ceil|cosh?|deg|exp|floor|fmod|frexp|ldexp|log|log10|max|min|modf|pow|rad|random|randomseed|sinh?|sqrt|tanh?|tointeger|type)|io_(close|flush|input|lines|open|output|popen|read|tmpfile|type|write)|os_(clock|date|difftime|execute|exit|getenv|remove|rename|setlocale|time|tmpname)|package_(loadlib|seeall|searchpath)|debug_(debug|[gs]etfenv|[gs]ethook|getinfo|[gs]etlocal|[gs]etmetatable|getregistry|[gs]etupvalue|[gs]etuservalue|set[Cc]stacklimit|traceback|upvalueid|upvaluejoin)|bit32_(arshift|band|bnot|bor|btest|bxor|extract|replace|lrotate|lshift|rrotate|rshift)|utf8_(char|codes|codepoint|len|offset))\b
        name: support.function.library.lua

      # Ruby (Kernel module)
      - match: \b(abort|at_exit|autoload|binding|callcc|caller|caller_locations|chomp|chop|eval|exec|exit|exit!|fork|format|gets|global_variables|gsub|lambda|load|local_variables|open|p|print|printf|proc|putc|puts|rand|readline|readlines|select|set_trace_func|sleep|spawn|sprintf|srand|sub|syscall|system|test|trace_var|trap|untrace_var|warn)\b
        name: support.function.kernel.ruby

      # SQL (T-SQL)
      - match: \b(approx_count_distinct|approx_percentile_cont|approx_percentile_disc|avg|checksum_agg|count|count_big|group|grouping|grouping_id|max|min|sum|stdev|stdevp|var|varp)\b
        name: support.function.aggregate.sql
      - match: \b(cume_dist|first_value|lag|last_value|lead|percent_rank|percentile_cont|percentile_disc)\b
        name: support.function.analytic.sql
      - match: \b(bit_count|get_bit|left_shift|right_shift|set_bit)\b
        name: support.function.bitmanipulation.sql
      - match: \b(cast|convert|parse|try_cast|try_convert|try_parse)\b
        name: support.function.conversion.sql
      - match: \b(collationproperty|tertiary_weights)\b
        name: support.function.collation.sql
      - match: \b(asymkey_id|asymkeyproperty|certproperty|cert_id|crypt_gen_random|decryptbyasymkey|decryptbycert|decryptbykey|decryptbykeyautoasymkey|decryptbykeyautocert|decryptbypassphrase|encryptbyasymkey|encryptbycert|encryptbykey|encryptbypassphrase|hashbytes|is_objectsigned|key_guid|key_id|key_name|signbyasymkey|signbycert|symkeyproperty|verifysignedbycert|verifysignedbyasymkey)\b
        name: support.function.cryptographic.sql
      - match: \b(cursor_status)\b
        name: support.function.cursor.sql
      - match: \b(sysdatetime|sysdatetimeoffset|sysutcdatetime|current_time(stamp)?|getdate|getutcdate|datename|datepart|day|month|year|datefromparts|datetime2fromparts|datetimefromparts|datetimeoffsetfromparts|smalldatetimefromparts|timefromparts|datediff|dateadd|datetrunc|eomonth|switchoffset|todatetimeoffset|isdate|date_bucket)\b
        name: support.function.datetime.sql
      - match: \b(datalength|ident_current|ident_incr|ident_seed|identity|sql_variant_property)\b
        name: support.function.datatype.sql
      - match: \b(coalesce|nullif)\b
        name: support.function.expression.sql
      - match: (?<!@)@@\b(cursor_rows|connections|cpu_busy|datefirst|dbts|error|fetch_status|identity|idle|io_busy|langid|language|lock_timeout|max_connections|max_precision|nestlevel|options|packet_errors|pack_received|pack_sent|procid|remserver|rowcount|servername|servicename|spid|textsize|timeticks|total_errors|total_read|total_write|trancount|version)\b
        name: support.function.globalvar.sql
      - match: \b(json|isjson|json_object|json_array|json_value|json_query|json_modify|json_path_exists)\b
        name: support.function.json.sql
      - match: \b(choose|iif|greatest|least)\b
        name: support.function.logical.sql
      - match: \b(abs|acos|asin|atan|atn2|ceiling|cos|cot|degrees|exp|floor|log|log10|pi|power|radians|rand|round|sign|sin|sqrt|square|tan)\b
        name: support.function.mathematical.sql
      - match: \b(app_name|applock_mode|applock_test|assemblyproperty|col_length|col_name|columnproperty|database_principal_id|databasepropertyex|db_id|db_name|file_id|file_idex|file_name|filegroup_id|filegroup_name|filegroupproperty|fileproperty|fulltextcatalogproperty|fulltextserviceproperty|index_col|indexkey_property|indexproperty|object_definition|object_id|object_name|object_schema_name|objectproperty|objectpropertyex|original_db_name|parsename|schema_id|schema_name|scope_identity|serverproperty|stats_date|type_id|type_name|typeproperty)\b
        name: support.function.metadata.sql
      - match: \b(rank|dense_rank|ntile|row_number)\b
        name: support.function.ranking.sql
      - match: \b(generate_series|opendatasource|openjson|openrowset|openquery|openxml|predict|string_split)\b
        name: support.function.rowset.sql
      - match: \b(certencoded|certprivatekey|current_user|database_principal_id|has_perms_by_name|is_member|is_rolemember|is_srvrolemember|original_login|permissions|pwdcompare|pwdencrypt|schema_id|schema_name|session_user|suser_id|suser_sid|suser_sname|system_user|suser_name|user_id|user_name)\b
        name: support.function.security.sql
      - match: \b(ascii|char|charindex|concat|difference|format|left|len|lower|ltrim|nchar|nodes|patindex|quotename|replace|replicate|reverse|right|rtrim|soundex|space|str|string_agg|string_escape|string_split|stuff|substring|translate|trim|unicode|upper)\b
        name: support.function.string.sql
      - match: \b(binary_checksum|checksum|compress|connectionproperty|context_info|current_request_id|current_transaction_id|decompress|error_line|error_message|error_number|error_procedure|error_severity|error_state|formatmessage|get_filestream_transaction_context|getansinull|host_id|host_name|isnull|isnumeric|min_active_rowversion|newid|newsequentialid|rowcount_big|session_context|session_id|xact_state)\b
        name: support.function.system.sql
      - match: \b(patindex|textptr|textvalid)\b
        name: support.function.textimage.sql
      - match: \b(vector_distance|vector_norm|vector_normalize)\b
        name: support.function.vector.sql
      - match: \b(xml_data_type|xml_exists|xml_modify|xml_namespaces|xml_schema_collection|xml_value|xmlquery|xmlexists|xmlparse|xmlserialize|xmltable)\b
        name: support.function.xml.sql
      - match: \b(backupsetproperty|dbcc|filegroupproperty|indexstats|loginfo|show_continuous_backup_history|show_filestream_catalog|show_statistics|tableproperty|transactionproperty)\b
        name: support.function.maintenance.sql
      - match: \b(archive|change_tracking_current_version|change_tracking_is_column_tracked|change_tracking_min_valid_version|fileproperty|fn_virtualfilestats|is_filestream_enabled|is_fulltext_enabled|is_honor_broker_priority_on|is_trustworthy_on|memory_object_address|memory_object_property|sys_fn_cdc_get_all_changes_table|sys_fn_cdc_get_net_changes_table)\b
        name: support.function.advanced.sql
      - match: \b(iif|choose|greatest|least)\b
        name: support.function.conditional.sql

      - match: \b(abort|abort_after_wait|absent|absolute|accent_sensitivity|acceptable_cursopt|acp|action|activation|add|address|admin|aes_128|aes_192|aes_256|affinity|after|aggregate|algorithm|all_constraints|all_errormsgs|all_indexes|all_levels|all_results|allow_connections|allow_dup_row|allow_encrypted_value_modifications|allow_page_locks|allow_row_locks|allow_snapshot_isolation|alter|altercolumn|always|anonymous|ansi_defaults|ansi_null_default|ansi_null_dflt_off|ansi_null_dflt_on|ansi_nulls|ansi_padding|ansi_warnings|appdomain|append|application|apply|arithabort|arithignore|array|assembly|asymmetric|asynchronous_commit|at|atan2|atomic|attach|attach_force_rebuild_log|attach_rebuild_log|audit|auth_realm|authentication|auto|auto_cleanup|auto_close|auto_create_statistics|auto_drop|auto_shrink|auto_update_statistics|auto_update_statistics_async|automated_backup_preference|automatic|autopilot|availability|availability_mode|backup|backup_priority|base64|basic|batches|batchsize|before|between|bigint|binary|binding|bit|block|blockers|blocksize|bmk|both|break|broker|broker_instance|bucket_count|buffer|buffercount|bulk_logged|by|call|caller|card|case|catalog|catch|cert|certificate|change_retention|change_tracking|change_tracking_context|changes|char|character|character_set|check_expiration|check_policy|checkconstraints|checkindex|checkpoint|checksum|cleanup_policy|clear|clear_port|close|clustered|codepage|collection|column_encryption_key|column_master_key|columnstore|columnstore_archive|colv_80_to_100|colv_100_to_80|commit_differential_base|committed|compatibility_level|compress_all_row_groups|compression|compression_delay|concat_null_yields_null|concatenate|configuration|connect|connection|containment|continue|continue_after_error|contract|contract_name|control|conversation|conversation_group_id|conversation_handle|copy|copy_only|count_rows|counter|create(_or_alter)?|credential|cross|cryptographic|cryptographic_provider|cube|cursor|cursor_close_on_commit|cursor_default|data|data_compression|data_flush_interval_seconds|data_mirroring|data_purity|data_source|database|database_name|database_snapshot|datafiletype|date_correlation_optimization|date|datefirst|dateformat|date_format|datetime|datetime2|datetimeoffset|day(s)?|db_chaining|dbid|dbidexec|dbo_only|deadlock_priority|deallocate|dec|decimal|declare|decrypt|decrypt_a|decryption|default_database|default_fulltext_language|default_language|default_logon_domain|default_schema|definition|delay|delayed_durability|delimitedtext|density_vector|dependent|des|description|desired_state|desx|differential|digest|disable|disable_broker|disable_def_cnst_chk|disabled|disk|distinct|distributed|distribution|drop|drop_existing|dts_buffers|dump|durability|dynamic|edition|elements|else|emergency|empty|enable|enable_broker|enabled|encoding|encrypted|encrypted_value|encryption|encryption_type|end|endpoint|endpoint_url|enhancedintegrity|entry|error_broker_conversations|errorfile|estimateonly|event|except|exec|executable|execute|exists|expand|expiredate|expiry_date|explicit|external|external_access|failover|failover_mode|failure_condition_level|fast|fast_forward|fastfirstrow|federated_service_account|fetch|field_terminator|fieldterminator|file|filelistonly|filegroup|filegrowth|filename|filestream|filestream_log|filestream_on|filetable|file_format|filter|first_row|fips_flagger|fire_triggers|first|firstrow|float|flush_interval_seconds|fmtonly|following|for|force|force_failover_allow_data_loss|force_service_allow_data_loss|forced|forceplan|formatfile|format_options|format_type|formsof|forward_only|free_cursors|free_exec_context|fullscan|fulltext|fulltextall|fulltextkey|function|generated|get|geography|geometry|global|go|goto|governor|guid|hadoop|hardening|hash|hashed|header_limit|headeronly|health_check_timeout|hidden|hierarchyid|histogram|histogram_steps|hits_cursors|hits_exec_context|hour(s)?|http|identity|identity_value|if|ifnull|ignore|ignore_constraints|ignore_dup_key|ignore_dup_row|ignore_triggers|image|immediate|implicit_transactions|include|include_null_values|incremental|index|inflectional|init|initiator|insensitive|insert|instead|int|integer|integrated|intersect|intermediate|interval_length_minutes|into|inuse_cursors|inuse_exec_context|io|is|isabout|iso_week|isolation|job_tracker_location|json|keep|keep_nulls|keep_replication|keepdefaults|keepfixed|keepidentity|keepnulls|kerberos|key|key_path|key_source|key_store_provider_name|keyset|kill|kilobytes_per_batch|labelonly|langid|language|last|lastrow|leading|legacy_cardinality_estimation|length|level|lifetime|lineage_80_to_100|lineage_100_to_80|listener_ip|listener_port|load|loadhistory|lob_compaction|local|local_service_name|locate|location|lock_escalation|lock_timeout|lockres|log|login|login_type|loop|manual|mark_in_use_for_removal|masked|master|match|matched|max_queue_readers|max_duration|max_outstanding_io_per_volume|maxdop|maxerrors|maxlength|maxtransfersize|max_plans_per_query|max_storage_size_mb|mediadescription|medianame|mediapassword|memogroup|memory_optimized|merge|message|message_forward_size|message_forwarding|microsecond|millisecond|minute(s)?|mirror_address|misses_cursors|misses_exec_context|mixed|modify|money|month|move|multi_user|must_change|name|namespace|nanosecond|native|native_compilation|nchar|ncharacter|nested_triggers|never|new_account|new_broker|newname|next|no|no_browsetable|no_checksum|no_compression|no_infomsgs|no_triggers|no_truncate|nocount|noexec|noexpand|noformat|noinit|nolock|nonatomic|nonclustered|nondurable|none|norecompute|norecovery|noreset|norewind|noskip|not|notification|nounload|now|nowait|ntext|ntlm|nulls|numeric|numeric_roundabort|nvarchar|object|objid|oem|offline|old_account|online|operation_mode|open|openjson|optimistic|option|orc|out|outer|output|over|override|owner|ownership|pad_index|page|page_checksum|page_verify|pagecount|paglock|param|parameter_sniffing|parameter_type_expansion|parameterization|parquet|parseonly|partial|partition|partner|password|path|pause|percentage|permission_set|persisted|period|physical_only|plan_forcing_mode|policy|pool|population|ports|preceding|precision|predicate|presume_abort|primary|primary_role|print|prior|priority |priority_level|private|proc(edure)?|procedure_name|profile|provider|quarter|query_capture_mode|query_governor_cost_limit|query_optimizer_hotfixes|query_store|queue|quoted_identifier|raiserror|range|raw|rcfile|rc2|rc4|rc4_128|rdbms|read_committed_snapshot|read|read_only|read_write|readcommitted|readcommittedlock|readonly|readpast|readuncommitted|readwrite|real|rebuild|receive|recmodel_70backcomp|recompile|reconfigure|recovery|recursive|recursive_triggers|redo_queue|reject_sample_value|reject_type|reject_value|relative|remote|remote_data_archive|remote_proc_transactions|remote_service_name|remove|removed_cursors|removed_exec_context|reorganize|repeat|repeatable|repeatableread|replace|replica|replicated|replnick_100_to_80|replnickarray_80_to_100|replnickarray_100_to_80|required|required_cursopt|resample|reset|resource|resource_manager_location|respect|restart|restore|restricted_user|resume|retaindays|retention|return|revert|rewind|rewindonly|returns|robust|role|rollup|root|round_robin|route|row|rowdump|rowguidcol|rowlock|row_terminator|rows|rows_per_batch|rowsets_only|rowterminator|rowversion|rsa_1024|rsa_2048|rsa_3072|rsa_4096|rsa_512|safe|safety|sample|save|scalar|schema|schemabinding|scoped|scroll|scroll_locks|sddl|second|secexpr|seconds|secondary|secondary_only|secondary_role|secret|security|securityaudit|selective|self|send|sent|sequence|serde_method|serializable|server|service|service_broker|service_name|service_objective|session_timeout|session|sessions|seterror|setopts|sets|shard_map_manager|shard_map_name|sharded|shared_memory|shortest_path|show_statistics|showplan_all|showplan_text|showplan_xml|showplan_xml_with_recompile|shrinkdb|shutdown|sid|signature|simple|single_blob|single_clob|single_nclob|single_user|singleton|site|size|size_based_cleanup_mode|skip|smalldatetime|smallint|smallmoney|snapshot|snapshot_import|snapshotrestorephase|soap|softnuma|sort_in_tempdb|sorted_data|sorted_data_reorg|spatial|sql|sql_bigint|sql_binary|sql_bit|sql_char|sql_date|sql_decimal|sql_double|sql_float|sql_guid|sql_handle|sql_longvarbinary|sql_longvarchar|sql_numeric|sql_real|sql_smallint|sql_time|sql_timestamp|sql_tinyint|sql_tsi_day|sql_tsi_frac_second|sql_tsi_hour|sql_tsi_minute|sql_tsi_month|sql_tsi_quarter|sql_tsi_second|sql_tsi_week|sql_tsi_year|sql_type_date|sql_type_time|sql_type_timestamp|sql_varbinary|sql_varchar|sql_variant|sql_wchar|sql_wlongvarchar|ssl|ssl_port|standard|standby|start|start_date|started|stat_header|state|statement|static|statistics|statistics_incremental|statistics_norecompute|statistics_only|statman|stats|stats_stream|status|stop|stop_on_error|stopat|stopatmark|stopbeforemark|stoplist|stopped|string_delimiter|subject|supplemental_logging|supported|suspend|symmetric|synchronous_commit|synonym|sysname|system|system_time|system_versioning|table|tableresults|tablock|tablockx|take|tape|target|target_index|target_partition|target_recovery_time|tcp|temporal_history_retention|text|textimage_on|then|thesaurus|throw|time|timeout|timestamp|tinyint|to|top|torn_page_detection|track_columns_updated|trailing|tran|transaction|transfer|transform_noise_words|triple_des|triple_des_3key|truncate|trustworthy|try|tsql|two_digit_year_cutoff|type|type_desc|type_warning|tzoffset|uid|unbounded|uncommitted|unique|uniqueidentifier|unlimited|unload|unlock|unsafe|updlock|url|use|useplan|useroptions|use_type_default|using|utcdatetime|valid_xml|validation|value|values|varbinary|varchar|vector|verbose|verifyonly|version|view_metadata|virtual_device|visiblity|wait_at_low_priority|waitfor|webmethod|week|weekday|weight|well_formed_xml|when|while|widechar|widechar_ansi|widenative|window|windows|with|within|within group|witness|without|without_array_wrapper|workload|wsdl|xact_abort|xlock|xml|xmlschema|xquery|xsinil|year|zone)\b
        name: support.function.legacy.sql

      # R (base package)
      - match: \b(abbreviate|abs|acos|acosh|activeBindingFunction|addNA|addTaskCallback|agrep|agrepl|alist|all|all_equal|all_equal_character|all_equal_default|all_equal_environment|all_equal_envRefClass|all_equal_factor|all_equal_formula|all_equal_function|all_equal_language|all_equal_list|all_equal_numeric|all_equal_POSIXt|all_equal_raw|all_names|all_vars|allowInterrupts|any|anyDuplicated|anyDuplicated_array|anyDuplicated_data_frame|anyDuplicated_default|anyDuplicated_matrix|anyNA|anyNA_data_frame|anyNA_numeric_version|anyNA_POSIXlt|aperm|aperm_default|aperm_table|append|apply|Arg|args|array|array2DF|arrayInd|as_array|as_array_default|as_call|as_character|as_character_condition|as_character_Date|as_character_default|as_character_error|as_character_factor|as_character_hexmode|as_character_numeric_version|as_character_octmode|as_character_POSIXt|as_character_srcref|as_complex|as_data_frame|as_data_frame_array|as_data_frame_AsIs|as_data_frame_character|as_data_frame_complex|as_data_frame_data_frame|as_data_frame_Date|as_data_frame_default|as_data_frame_difftime|as_data_frame_factor|as_data_frame_integer|as_data_frame_list|as_data_frame_logical|as_data_frame_matrix|as_data_frame_model_matrix|as_data_frame_noquote|as_data_frame_numeric|as_data_frame_numeric_version|as_data_frame_ordered|as_data_frame_POSIXct|as_data_frame_POSIXlt|as_data_frame_raw|as_data_frame_table|as_data_frame_ts|as_data_frame_vector|as_Date|as_Date_character|as_Date_default|as_Date_factor|as_Date_numeric|as_Date_POSIXct|as_Date_POSIXlt|as_difftime|as_double|as_double_difftime|as_double_POSIXlt|as_environment|as_expression|as_expression_default|as_factor|as_function|as_function_default|as_hexmode|as_integer|as_list|as_list_data_frame|as_list_Date|as_list_default|as_list_difftime|as_list_environment|as_list_factor|as_list_function|as_list_numeric_version|as_list_POSIXct|as_list_POSIXlt|as_logical|as_logical_factor|as_matrix|as_matrix_data_frame|as_matrix_default|as_matrix_noquote|as_matrix_POSIXlt|as_name|as_null|as_null_default|as_numeric|as_numeric_version|as_octmode|as_ordered|as_package_version|as_pairlist|as_POSIXct|as_POSIXct_Date|as_POSIXct_default|as_POSIXct_numeric|as_POSIXct_POSIXlt|as_POSIXlt|as_POSIXlt_character|as_POSIXlt_Date|as_POSIXlt_default|as_POSIXlt_factor|as_POSIXlt_numeric|as_POSIXlt_POSIXct|as_qr|as_raw|as_single|as_single_default|as_symbol|as_table|as_table_default|as_vector|as_vector_data_frame|as_vector_factor|as_vector_POSIXlt|asin|asinh|asNamespace|asplit|asS3|asS4|assign|atan|atan2|atanh|attach|attachNamespace|attr|attr_all_equal|attributes|autoload|autoloader|backsolve|balancePOSIXlt|baseenv|basename|besselI|besselJ|besselK|besselY|beta|bindingIsActive|bindingIsLocked|bindtextdomain|bitwAnd|bitwNot|bitwOr|bitwShiftL|bitwShiftR|bitwXor|body|bquote|break|browser|browserCondition|browserSetDebug|browserText|builtins|by|by_data_frame|by_default|bzfile|c|c_Date|c_difftime|c_factor|c_noquote|c_numeric_version|c_POSIXct|c_POSIXlt|c_warnings|call|callCC|capabilities|casefold|cat|cbind|cbind_data_frame|ceiling|char_expand|character|charmatch|charToRaw|chartr|chkDots|chol|chol_default|chol2inv|choose|chooseOpsMethod|chooseOpsMethod_default|class|clearPushBack|close|close_connection|close_srcfile|close_srcfilealias|closeAllConnections|col|colMeans|colnames|colSums|commandArgs|comment|complex|computeRestarts|conditionCall|conditionCall_condition|conditionMessage|conditionMessage_condition|conflictRules|conflicts|Conj|contributors|cos|cosh|cospi|crossprod|Cstack_info|cummax|cummin|cumprod|cumsum|curlGetHeaders|cut|cut_Date|cut_default|cut_POSIXt|data_class|data_frame|data_matrix|date|debug|debuggingState|debugonce|declare|default_stringsAsFactors|delayedAssign|deparse|deparse1|det|detach|determinant|determinant_matrix|dget|diag|diff|diff_Date|diff_default|diff_difftime|diff_POSIXt|difftime|digamma|dim|dim_data_frame|dimnames|dimnames_data_frame|dir|dir_create|dir_exists|dirname|do_call|dontCheck|double|dput|dQuote|drop|droplevels|droplevels_data_frame|droplevels_factor|dump|duplicated|duplicated_array|duplicated_data_frame|duplicated_default|duplicated_matrix|duplicated_numeric_version|duplicated_POSIXlt|duplicated_warnings|dyn_load|dyn_unload|dynGet|eapply|eigen|emptyenv|enc2native|enc2utf8|encodeString|Encoding|endsWith|enquote|env_profile|environment|environmentIsLocked|environmentName|errorCondition|eval|eval_parent|evalq|Exec|exists|exp|expand_grid|expm1|expression|extSoftVersion|factor|factorial|fifo|file|file_access|file_append|file_choose|file_copy|file_create|file_exists|file_info|file_link|file_mode|file_mtime|file_path|file_remove|file_rename|file_show|file_size|file_symlink|Filter|Find|find_package|findInterval|findPackageEnv|findRestart|floor|flush|flush_connection|for|force|forceAndCall|formals|format|format_AsIs|format_data_frame|format_Date|format_default|format_difftime|format_factor|format_hexmode|format_info|format_libraryIQR|format_numeric_version|format_octmode|format_packageInfo|format_POSIXct|format_POSIXlt|format_pval|format_summaryDefault|formatC|formatDL|forwardsolve|function|gamma|gc|gc_time|gcinfo|gctorture|gctorture2|get|get0|getAllConnections|getCallingDLL|getCallingDLLe|getConnection|getDLLRegisteredRoutines|getDLLRegisteredRoutines_character|getDLLRegisteredRoutines_DLLInfo|getElement|geterrmessage|getExportedValue|getHook|getLoadedDLLs|getNamespace|getNamespaceExports|getNamespaceImports|getNamespaceInfo|getNamespaceName|getNamespaceUsers|getNamespaceVersion|getNativeSymbolInfo|getOption|getRversion|getSrcLines|getTaskCallbackNames|gettext|gettextf|getwd|gl|globalCallingHandlers|globalenv|gregexec|gregexpr|grep|grepl|grepRaw|grepv|grouping|gsub|gzcon|gzfile|I|iconv|iconvlist|icuGetCollate|icuSetCollate|identical|identity|if|ifelse|Im|importIntoEnv|infoRDS|inherits|integer|interaction|interactive|intersect|intToBits|intToUtf8|inverse_rle|invisible|invokeRestart|invokeRestartInteractively|is_array|is_atomic|is_call|is_character|is_complex|is_data_frame|is_double|is_element|is_environment|is_expression|is_factor|is_finite|is_finite_POSIXlt|is_function|is_infinite|is_infinite_POSIXlt|is_integer|is_language|is_list|is_loaded|is_logical|is_matrix|is_na|is_na_data_frame|is_na_numeric_version|is_na_POSIXlt|is_name|is_nan|is_nan_POSIXlt|is_null|is_numeric|is_numeric_version|is_numeric_Date|is_numeric_difftime|is_numeric_POSIXt|is_object|is_ordered|is_package_version|is_pairlist|is_primitive|is_qr|is_R|is_raw|is_recursive|is_single|is_symbol|is_table|is_unsorted|is_vector|isa|isatty|isBaseNamespace|isdebugged|isFALSE|isIncomplete|isNamespace|isNamespaceLoaded|ISOdate|ISOdatetime|isOpen|isRestart|isS4|isSeekable|isSymmetric|isSymmetric_matrix|isTRUE|jitter|julian|julian_Date|julian_POSIXt|kappa|kappa_default|kappa_lm|kappa_qr|kronecker|l10n_info|La_library|La_version|La_svd|labels|labels_default|lapply|lazyLoad|lazyLoadDBexec|lazyLoadDBfetch|lbeta|lchoose|length|length_POSIXlt|lengths|levels|levels_default|lfactorial|lgamma|libcurlVersion|library|library_dynam|library_dynam_unload|licence|license|list|list_dirs|list_files|list2DF|list2env|load|loadedNamespaces|loadingNamespaceInfo|loadNamespace|local|lockBinding|lockEnvironment|log|log10|log1p|log2|logb|logical|lower_tri|ls|make_names|make_unique|makeActiveBinding|Map|mapply|margin_table|marginSums|mat_or_vec|match|match_arg|match_call|match_fun|Math_data_frame|Math_Date|Math_difftime|Math_factor|Math_POSIXt|matrix|max|max_col|mean|mean_Date|mean_default|mean_difftime|mean_POSIXct|mean_POSIXlt|mem_maxNSize|mem_maxVSize|memCompress|memDecompress|memory_profile|merge|merge_data_frame|merge_default|message|mget|min|missing|Mod|mode|months|months_Date|months_POSIXt|mtfrm|mtfrm_default|mtfrm_POSIXct|mtfrm_POSIXlt|nameOfClass|nameOfClass_default|names|names_POSIXlt|namespaceExport|namespaceImport|namespaceImportClasses|namespaceImportFrom|namespaceImportMethods|nargs|nchar|ncol|NCOL|Negate|new_env|next|NextMethod|ngettext|nlevels|noquote|norm|normalizePath|nrow|NROW|nullfile|numeric|numeric_version|numToBits|numToInts|nzchar|objects|oldClass|OlsonNames|on_exit|open|open_connection|open_srcfile|open_srcfilealias|open_srcfilecopy|Ops_data_frame|Ops_Date|Ops_difftime|Ops_factor|Ops_numeric_version|Ops_ordered|Ops_POSIXt|options|order|ordered|outer|package_version|packageEvent|packageHasNamespace|packageNotFoundError|packageStartupMessage|packBits|pairlist|parent_env|parent_frame|parse|parseNamespaceFile|paste|paste0|path_expand|path_package|pcre_config|pipe|plot|pmatch|pmax|pmax_int|pmin|pmin_int|polyroot|pos_to_env|Position|pretty|pretty_default|prettyNum|print|print_AsIs|print_by|print_condition|print_connection|print_data_frame|print_Date|print_default|print_difftime|print_Dlist|print_DLLInfo|print_DLLInfoList|print_DLLRegisteredRoutines|print_eigen|print_factor|print_function|print_hexmode|print_libraryIQR|print_listof|print_NativeRoutineList|print_noquote|print_numeric_version|print_octmode|print_packageInfo|print_POSIXct|print_POSIXlt|print_proc_time|print_restart|print_rle|print_simple_list|print_srcfile|print_srcref|print_summary_table|print_summary_warnings|print_summaryDefault|print_table|print_warnings|prmatrix|proc_time|prod|prop_table|proportions|provideDimnames|psigamma|pushBack|pushBackLength|q|qr|qr_coef|qr_default|qr_fitted|qr_Q|qr_qty|qr_qy|qr_R|qr_resid|qr_solve|qr_X|quarters|quarters_Date|quarters_POSIXt|quit|quote|R_compiled_by|R_system_version|R_home|R_Version|range|range_Date|range_default|range_POSIXct|rank|rapply|raw|rawConnection|rawConnectionValue|rawShift|rawToBits|rawToChar|rbind|rbind_data_frame|rcond|Re|read_dcf|readBin|readChar|readline|readLines|readRDS|readRenviron|Recall|Reduce|reg_finalizer|regexec|regexpr|registerS3method|registerS3methods|regmatches|remove|removeTaskCallback|rep|rep_len|rep_Date|rep_difftime|rep_factor|rep_int|rep_numeric_version|rep_POSIXct|rep_POSIXlt|repeat|replace|replicate|require|requireNamespace|restartDescription|restartFormals|retracemem|return|returnValue|rev|rev_default|rle|rm|RNGkind|RNGversion|round|round_Date|round_POSIXt|row|row_names|row_names_data_frame|row_names_default|rowMeans|rownames|rowsum|rowsum_data_frame|rowsum_default|rowSums|sample|sample_int|sapply|save|save_image|saveRDS|scale|scale_default|scan|search|searchpaths|seek|seek_connection|seq|seq_along|seq_len|seq_Date|seq_default|seq_int|seq_POSIXt|sequence|sequence_default|serialize|serverSocket|set_seed|setdiff|setequal|setHook|setNamespaceInfo|setSessionTimeLimit|setTimeLimit|setwd|showConnections|shQuote|sign|signalCondition|signif|simpleCondition|simpleError|simpleMessage|simpleWarning|simplify2array|sin|single|sinh|sink|sink_number|sinpi|slice_index|socketAccept|socketConnection|socketSelect|socketTimeout|solve|solve_default|solve_qr|sort|sort_by|sort_by_data_frame|sort_by_default|sort_default|sort_int|sort_list|sort_POSIXlt|source|split|split_data_frame|split_Date|split_default|split_POSIXct|sprintf|sqrt|sQuote|srcfile|srcfilealias|srcfilecopy|srcref|standardGeneric|startsWith|stderr|stdin|stdout|stop|stopifnot|storage_mode|str2expression|str2lang|strftime|strptime|strrep|strsplit|strtoi|strtrim|structure|strwrap|sub|subset|subset_data_frame|subset_default|subset_matrix|substitute|substr|substring|sum|summary|summary_connection|summary_data_frame|Summary_data_frame|summary_Date|Summary_Date|summary_default|summary_difftime|Summary_difftime|summary_factor|Summary_factor|summary_matrix|Summary_numeric_version|Summary_ordered|summary_POSIXct|Summary_POSIXct|summary_POSIXlt|Summary_POSIXlt|summary_proc_time|summary_srcfile|summary_srcref|summary_table|summary_warnings|suppressMessages|suppressPackageStartupMessages|suppressWarnings|suspendInterrupts|svd|sweep|switch|sys_call|sys_calls|Sys_chmod|Sys_Date|sys_frame|sys_frames|sys_function|Sys_getenv|Sys_getlocale|Sys_getpid|Sys_glob|Sys_info|sys_load_image|Sys_localeconv|sys_nframe|sys_on_exit|sys_parent|sys_parents|Sys_readlink|sys_save_image|Sys_setenv|Sys_setFileTime|Sys_setLanguage|Sys_setlocale|Sys_sleep|sys_source|sys_status|Sys_time|Sys_timezone|Sys_umask|Sys_unsetenv|Sys_which|system|system_file|system_time|system2|t|t_data_frame|t_default|table|tabulate|Tailcall|tan|tanh|tanpi|tapply|taskCallbackManager|tcrossprod|tempdir|tempfile|textConnection|textConnectionValue|tolower|topenv|toString|toString_default|toupper|trace|traceback|tracemem|tracingState|transform|transform_data_frame|transform_default|trigamma|trimws|trunc|trunc_Date|trunc_POSIXt|truncate|truncate_connection|try|tryCatch|tryInvokeRestart|typeof|unCfillPOSIXlt|unclass|undebug|union|unique|unique_array|unique_data_frame|unique_default|unique_matrix|unique_numeric_version|unique_POSIXlt|unique_warnings|units|units_difftime|unix_time|unlink|unlist|unloadNamespace|unlockBinding|unname|unserialize|unsplit|untrace|untracemem|unz|upper_tri|url|use|UseMethod|utf8ToInt|validEnc|validUTF8|vapply|vector|Vectorize|warning|warningCondition|warnings|weekdays|weekdays_Date|weekdays_POSIXt|which|which_max|which_min|while|with|with_default|withAutoprint|withCallingHandlers|within|within_data_frame|within_list|withRestarts|withVisible|write|write_dcf|writeBin|writeChar|writeLines|xor|xpdrows_data_frame|xtfrm|xtfrm_AsIs|xtfrm_data_frame|xtfrm_Date|xtfrm_default|xtfrm_difftime|xtfrm_factor|xtfrm_numeric_version|xtfrm_POSIXct|xtfrm_POSIXlt|xzfile|zapsmall|zstdfile)\b
        name: support.function.base.r
      - match: \b(abline|arrows|assocplot|axis|Axis|axis_Date|Axis_Date|Axis_default|axis_POSIXct|Axis_POSIXt|Axis_table|axTicks|barplot|barplot_default|barplot_formula|box|boxplot|boxplot_default|boxplot_formula|boxplot_matrix|bxp|cdplot|cdplot_default|cdplot_formula|clip|close_screen|co_intervals|contour|contour_default|coplot|curve|dotchart|erase_screen|extendDateTimeFormat|filled_contour|fourfoldplot|frame|grconvertX|grconvertY|grid|hist|hist_Date|hist_default|hist_POSIXt|identify|identify_default|image|image_default|layout|layout_show|lcm|legend|lines|lines_default|lines_formula|lines_histogram|lines_table|locator|matlines|matplot|matpoints|mosaicplot|mosaicplot_default|mosaicplot_formula|mtext|pairs|pairs_default|pairs_formula|panel_smooth|par|persp|persp_default|pie|piechart|plot_data_frame|plot_default|plot_design|plot_factor|plot_formula|plot_function|plot_histogram|plot_new|plot_raster|plot_table|plot_window|plot_xy|plotHclust|points|points_default|points_formula|points_table|polygon|polypath|rasterImage|rect|rug|screen|segments|smoothScatter|spineplot|spineplot_default|spineplot_formula|split_screen|stars|stem|strheight|stripchart|stripchart_default|stripchart_formula|strwidth|sunflowerplot|sunflowerplot_default|sunflowerplot_formula|symbols|text|text_default|text_formula|title|xinch|xspline|xyinch|yinch|zaxis)\b
        name: support.function.graphics.r
      - match: \b(adjustcolor|anyNA_raster|as_graphicsAnnot|as_matrix_raster|as_raster|as_raster_array|as_raster_character|as_raster_logical|as_raster_matrix|as_raster_numeric|as_raster_raster|as_raster_raw|axisTicks|bitmap|bmp|boxplot_stats|c2to3|cairo_pdf|cairo_ps|cairoFT|cairoSymbolFont|cairoVersion|check_gs_type|check_options|checkFont|checkFont_CIDFont|checkFont_default|checkFont_Type1Font|checkFontInUse|checkIntFormat|checkQuartzFont|checkSymbolFont|checkX11Font|chromaticAdaptation|chull|CIDFont|cm|cm_colors|col2rgb|colorConverter|colorRamp|colorRampPalette|colors|colours|comparePangoVersion|contourLines|convertColor|densCols|dev_capabilities|dev_capture|dev_control|dev_copy|dev_copy2eps|dev_copy2pdf|dev_cur|dev_displaylist|dev_flush|dev_hold|dev_interactive|dev_list|dev_new|dev_next|dev_off|dev_prev|dev_print|dev_set|dev_size|dev2bitmap|devAskNewPage|deviceIsInteractive|embedFonts|embedGlyphs|extendrange|getGraphicsEvent|getGraphicsEventEnv|glyphAnchor|glyphFont|glyphFontList|glyphHeight|glyphHeightBottom|glyphInfo|glyphJust|glyphJust_character|glyphJust_GlyphJust|glyphJust_numeric|glyphWidth|glyphWidthLeft|graphics_off|gray|gray_colors|grey|grey_colors|grSoftVersion|guessEncoding|hcl|hcl_colors|hcl_pals|heat_colors|hsv|initPSandPDFfonts|invertStyle|is_na_raster|is_raster|isPDF|jpeg|make_rgb|mapCharWeight|mapStyle|mapWeight|matchEncoding|matchEncoding_CIDFont|matchEncoding_Type1Font|matchFont|n2mfrow|nclass_FD|nclass_scott|nclass_Sturges|Ops_raster|optionSymbolFont|palette|palette_colors|palette_match|palette_pals|pangoVersion|pattern|pdf|pdf_options|pdfFonts|pictex|png|postscript|postscriptFonts|pow3|prettyDate|print_colorConverter|print_raster|print_recordedplot|print_RGBcolorConverter|print_RGlyphFont|printFont|printFont_CIDFont|printFont_Type1Font|printFonts|ps_options|quartz|quartz_options|quartz_save|quartzFont|quartzFonts|rainbow|recordGraphics|recordPalette|recordPlot|replayPlot|restoreRecordedPlot|rgb|rgb2hsv|RGBcolorConverter|savePlot|seqDtime|setEPS|setFonts|setGraphicsEventEnv|setGraphicsEventHandlers|setPS|setQuartzFonts|setX11Fonts|svg|symbolfamilyDefault|symbolType1support|terrain_colors|tiff|topo_colors|trans3d|trunc_POSIXt|Type1Font|vectorizeConverter|warnLogCoords|x11|X11|X11_options|X11Font|X11FontError|X11Fonts|xfig|xy_coords|xyTable|xyz_coords)\b
        name: support.function.graphics.ext.r
      - match: \b(addNextMethod|allNames|Arith|as|asMethodDefinition|assignClassDef|assignMethodsMetaData|balanceMethodsList|bind_activation|cacheGenericsMetaData|cacheMetaData|cacheMethod|cacheOnAssign|callGeneric|callNextMethod|canCoerce|cbind|cbind2|checkAtAssignment|checkSlotAssignment|classesToAM|classGeneratorFunction|classLabel|classMetaName|className|coerce|Compare|completeClassDefinition|completeExtends|completeSubclasses|Complex|conformMethod|defaultDumpName|defaultPrototype|dispatchIsInternal|doPrimitiveMethod|dumpMethod|dumpMethods|el|elNamed|empty_dump|emptyMethodsList|envRefInferField|envRefSetField|evalOnLoad|evalqOnLoad|evalSource|existsFunction|existsMethod|extends|externalRefMethod|finalDefaultMethod|findClass|findFunction|findMethod|findMethods|findMethodSignatures|findUnique|fixPre1_8|formalArgs|fromNextMethod|functionBody|generic_skeleton|genericForBasic|getAllSuperClasses|getClass|getClassDef|getClasses|getDataPart|getFunction|getGeneric|getGenericFromCall|getGenerics|getGroup|getGroupMembers|getLoadActions|getMethod|getMethods|getMethodsAndAccessors|getMethodsForDispatch|getMethodsMetaData|getPackageName|getRefClass|getRefSuperClasses|getSlots|getValidity|hasArg|hasLoadAction|hasMethod|hasMethods|implicitGeneric|inBasicFuns|inferProperties|inheritedSlotNames|inheritedSubMethodLists|initFieldArgs|initialize|initMethodDispatch|initRefFields|insertClassMethods|insertMethod|insertMethodInEmptyList|insertSource|installClassMethod|is|isBaseFun|isClass|isClassDef|isClassUnion|isGeneric|isGrammarSymbol|isGroup|isMixin|isRematched|isS3Generic|isSealedClass|isSealedMethod|isVirtualClass|isXS3Class|kronecker|languageEl|listFromMethods|loadMethod|Logic|makeClassMethod|makeClassRepresentation|makeEnvRefMethods|makeExtends|makeGeneric|makeMethodsList|makePrototypeFromClassDef|makeStandardGeneric|matchDefaults|matchSignature|Math|Math2|matrixOps|mergeMethods|metaNameUndo|method_skeleton|MethodAddCoerce|methodSignatureMatrix|MethodsList|MethodsListSelect|methodsPackageMetaName|missingArg|multipleClasses|new|newBasic|newClassRepresentation|newEmptyObject|Ops|outerLabels|packageSlot|possibleExtends|printClassRepresentation|printPropertiesList|prohibitGeneric|promptClass|promptMethods|prototype|Quote|rbind|rbind2|reconcilePropertiesAndPrototype|refClassFields|refClassInformation|refClassMethods|refClassPrompt|refObjectClass|registerImplicitGenerics|rematchDefinition|removeClass|removeGeneric|removeMethod|removeMethods|representation|requireMethods|resetClass|resetGeneric|S3Class|S3forS4Methods|S3Part|sealClass|selectMethod|selectSuperClasses|setAs|setCacheOnAssign|setClass|setClassUnion|setDataPart|setGeneric|setGenericImplicit|setGroupGeneric|setIs|setLoadAction|setLoadActions|setMethod|setNames|setOldClass|setPackageName|setPackageSlot|setPrimitiveMethods|setRefClass|setReplaceMethod|setValidity|show|showClass|showClassMethod|showDefault|showExtends|showExtraSlots|showMethods|showRefClassDef|signature|SignatureMethod|sigToEnv|slot|slotNames|slotsFromS3|substituteDirect|substituteFunctionArgs|Summary|superClassDepth|superClassMethodName|tableNames|testInheritedMethods|testVirtual|tryNew|unRematchDefinition|useMTable|validObject|validSlotNames)\b
        name: support.function.method.r
      - match: \b(acf|acf2AR|add_scope|add1|add1_default|add1_glm|add1_lm|add1_mlm|addmargins|aggregate|aggregate_data_frame|aggregate_default|aggregate_formula|aggregate_ts|AIC|AIC_default|AIC_logLik|alias|alias_formula|alias_lm|anova|anova_glm|anova_glmlist|anova_lm|anova_lmlist|anova_loess|anova_mlm|anova_mlmlist|anova_nls|anovalist_nls|ansari_test|ansari_test_default|ansari_test_formula|aov|approx|approxfun|ar|ar_burg|ar_burg_default|ar_burg_mts|ar_mle|ar_ols|ar_yw|ar_yw_default|ar_yw_mts|arima|arima_sim|arima0|arima0_diag|ARMAacf|ARMAtoMA|as_data_frame_aovproj|as_data_frame_ftable|as_data_frame_logLik|as_dendrogram|as_dendrogram_dendrogram|as_dendrogram_hclust|as_dist|as_dist_default|as_formula|as_hclust|as_hclust_default|as_hclust_dendrogram|as_hclust_twins|as_matrix_dist|as_matrix_ftable|as_stepfun|as_stepfun_default|as_stepfun_isoreg|as_table_ftable|as_ts|as_ts_default|asOneSidedFormula|assert_NULL_or_prob|ave|bandwidth_kernel|bartlett_test|bartlett_test_default|bartlett_test_formula|BIC|BIC_default|BIC_logLik|binom_test|binomial|binomInitialize|biplot|biplot_default|biplot_prcomp|biplot_princomp|Box_test|bw_pair_cnts|bw_bcv|bw_nrd|bw_nrd0|bw_SJ|bw_ucv|C|cancor|case_names|case_names_default|case_names_lm|cbind_ts|ccf|check_exact|chisq_test|cmdscale|coef|coef_aov|coef_Arima|coef_default|coef_listof|coef_maov|coef_nls|coefficients|complete_cases|confint|confint_default|confint_glm|confint_lm|confint_nls|confint_profile_glm|confint_profile_nls|constrOptim|contr_helmert|contr_poly|contr_SAS|contr_sum|contr_treatment|contrasts|convolve|cooks_distance|cooks_distance_glm|cooks_distance_lm|cophenetic|cophenetic_default|cophenetic_dendrogram|cor|cor_test|cor_test_default|cor_test_formula|cov|cov_wt|cov2cor|covratio|cpgram|cut_dendrogram|cutree|cycle|cycle_default|cycle_ts|D|dbeta|dbinom|dcauchy|dchisq|decompose|delete_response|deltat|deltat_default|dendrapply|density|density_default|deparse2|deriv|deriv_default|deriv_formula|deriv3|deriv3_default|deriv3_formula|deviance|deviance_default|deviance_glm|deviance_lm|deviance_mlm|deviance_nls|dexp|df|df_kernel|df_residual|df_residual_default|df_residual_nls|DF2formula|dfbeta|dfbeta_lm|dfbetas|dfbetas_lm|dffits|dgamma|dgeom|dhyper|diff_ts|diffinv|diffinv_default|diffinv_ts|diffinv_vector|dist|dlnorm|dlogis|dmultinom|dnbinom|dnorm|dpois|drop_scope|drop_terms|drop1|drop1_default|drop1_glm|drop1_lm|drop1_mlm|dsignrank|dt|dummy_coef|dummy_coef_aovlist|dummy_coef_lm|dunif|dweibull|dwilcox|ecdf|eff_aovlist|effects|effects_glm|effects_lm|embed|end|end_default|estVar|estVar_mlm|estVar_SSD|expand_model_frame|extractAIC|extractAIC_aov|extractAIC_coxph|extractAIC_glm|extractAIC_lm|extractAIC_negbin|extractAIC_survreg|factanal|factanal_fit_mle|factor_scope|family|family_glm|family_lm|fft|filter|fisher_test|fitted|fitted_default|fitted_isoreg|fitted_kmeans|fitted_nls|fitted_smooth_spline|fitted_values|fivenum|fligner_test|fligner_test_default|fligner_test_formula|format_perc|format_dist|format_ftable|formula|formula_character|formula_data_frame|formula_default|formula_formula|formula_glm|formula_lm|formula_nls|formula_terms|frequency|frequency_default|friedman_test|friedman_test_default|friedman_test_formula|ftable|ftable_default|ftable_formula|Gamma|gaussian|get_all_vars|getCall|getCall_default|getInitial|getInitial_default|getInitial_formula|getInitial_selfStart|glm|glm_control|glm_fit|hasTsp|hat|hatvalues|hatvalues_lm|hatvalues_smooth_spline|hclust|head_ts|heatmap|HL|HoltWinters|hyman_filter|identify_hclust|influence|influence_glm|influence_lm|influence_measures|integrate|interaction_plot|inverse_gaussian|IQR|is_empty_model|is_leaf|is_mts|is_stepfun|is_ts|is_tskernel|isoreg|KalmanForecast|KalmanLike|KalmanRun|KalmanSmooth|kernapply|kernapply_default|kernapply_ts|kernapply_tskernel|kernapply_vector|kernel|kmeans|knots|knots_stepfun|kruskal_test|kruskal_test_default|kruskal_test_formula|ks_test|ks_test_default|ks_test_formula|ksmooth|labels_dendrogram|labels_dist|labels_lm|labels_terms|lag|lag_default|lag_plot|line|lines_isoreg|lines_stepfun|lines_ts|lm|lm_fit|lm_influence|lm_wfit|loadings|loess|loess_control|loess_smooth|logLik|logLik_Arima|logLik_glm|logLik_lm|logLik_logLik|logLik_nls|loglin|lowess|ls_diag|ls_print|lsfit|mad|mahalanobis|make_link|make_tables_aovproj|make_tables_aovprojlist|makeARIMA|makepredictcall|makepredictcall_default|makepredictcall_poly|manova|mantelhaen_test|mauchly_test|mauchly_test_mlm|mauchly_test_SSD|mcnemar_test|median|median_default|medpolish|merge_dendrogram|midcache_dendrogram|model_extract|model_frame|model_frame_aovlist|model_frame_default|model_frame_glm|model_frame_lm|model_matrix|model_matrix_default|model_matrix_lm|model_offset|model_response|model_tables|model_tables_aov|model_tables_aovlist|model_weights|monthplot|monthplot_default|monthplot_stl|monthplot_StructTS|monthplot_ts|mood_test|mood_test_default|mood_test_formula|mvfft|na_action|na_action_default|na_contiguous|na_contiguous_default|na_exclude|na_exclude_data_frame|na_exclude_default|na_fail|na_fail_default|na_omit|na_omit_data_frame|na_omit_default|na_omit_ts|na_pass|napredict|napredict_default|napredict_exclude|naprint|naprint_default|naprint_exclude|naprint_omit|naresid|naresid_default|naresid_exclude|nextn|nleaves|nlm|nlminb|nls|nls_port_fit|nls_control|nlsModel|nlsModel_plinear|NLSstAsymptotic|NLSstAsymptotic_sortedXyData|NLSstClosestX|NLSstClosestX_sortedXyData|NLSstLfAsymptote|NLSstLfAsymptote_sortedXyData|NLSstRtAsymptote|NLSstRtAsymptote_sortedXyData|nobs|nobs_default|nobs_dendrogram|nobs_glm|nobs_lm|nobs_logLik|nobs_nls|numericDeriv|offset|oneway_test|Ops_ts|optim|optimHess|optimise|optimize|order_dendrogram|p_adjust|pacf|pacf_default|Pair|pairs_profile|pairwise_prop_test|pairwise_t_test|pairwise_table|pairwise_wilcox_test|pbeta|pbinom|pbirthday|pcauchy|pchisq|pexp|pf|pgamma|pgeom|phyper|Pillai|pkolmogorov|pkolmogorov_one_asymp|pkolmogorov_one_exact|pkolmogorov_two_asymp|pkolmogorov_two_exact|plclust|plnorm|plogis|plot_acf|plot_decomposed_ts|plot_dendrogram|plot_density|plot_ecdf|plot_hclust|plot_HoltWinters|plot_isoreg|plot_lm|plot_medpolish|plot_mlm|plot_ppr|plot_prcomp|plot_princomp|plot_profile|plot_profile_nls|plot_spec|plot_spec_coherency|plot_spec_phase|plot_stepfun|plot_stl|plot_ts|plot_tskernel|plot_TukeyHSD|plotNode|plotNodeLimit|pnbinom|pnorm|pointwise|poisson|poisson_test|poly|polym|port_get_named_v|port_msg|power|power_anova_test|power_prop_test|power_t_test|PP_test|ppoints|ppois|ppr|ppr_default|ppr_formula|prcomp|prcomp_default|prcomp_formula|predict|predict_ar|predict_Arima|predict_arima0|predict_glm|predict_HoltWinters|predict_lm|predict_loess|predict_mlm|predict_nls|predict_poly|predict_ppr|predict_prcomp|predict_princomp|predict_smooth_spline|predict_smooth_spline_fit|predict_StructTS|predLoess|preplot|princomp|princomp_default|princomp_formula|print_acf|print_anova|print_aov|print_aovlist|print_ar|print_Arima|print_arima0|print_dendrogram|print_density|print_dist|print_dummy_coef|print_dummy_coef_list|print_ecdf|print_factanal|print_family|print_formula|print_ftable|print_glm|print_hclust|print_HoltWinters|print_htest|print_infl|print_integrate|print_isoreg|print_kmeans|print_lm|print_loadings|print_loess|print_logLik|print_medpolish|print_mtable|print_nls|print_pairwise_htest|print_power_htest|print_ppr|print_prcomp|print_princomp|print_smooth_spline|print_stepfun|print_stl|print_StructTS|print_summary_aov|print_summary_aovlist|print_summary_ecdf|print_summary_glm|print_summary_lm|print_summary_loess|print_summary_manova|print_summary_nls|print_summary_ppr|print_summary_prcomp|print_summary_princomp|print_tables_aov|print_terms|print_ts|print_tskernel|print_TukeyHSD|print_tukeyline|print_tukeysmooth|print_xtabs|printCoefmat|profile|profile_glm|profile_nls|profiler|profiler_nls|proj|Proj|proj_aov|proj_aovlist|proj_default|proj_lm|promax|prop_test|prop_trend_test|psignrank|psmirnov|psmirnov_asymp|psmirnov_exact|psmirnov_simul|pt|ptukey|punif|pweibull|pwilcox|qbeta|qbinom|qbirthday|qcauchy|qchisq|qexp|qf|qgamma|qgeom|qhyper|qlnorm|qlogis|qnbinom|qnorm|qpois|qqline|qqnorm|qqnorm_default|qqplot|qr_influence|qr_lm|qsignrank|qsmirnov|qt|qtukey|quade_test|quade_test_default|quade_test_formula|quantile|quantile_default|quantile_ecdf|quantile_POSIXt|quasi|quasibinomial|quasipoisson|qunif|qweibull|qwilcox|r2dtable|Rank|rbeta|rbinom|rcauchy|rchisq|read_ftable|rect_hclust|reformulate|regularize_values|relevel|relevel_default|relevel_factor|relevel_ordered|reorder|reorder_default|reorder_dendrogram|replications|reshape|resid|residuals|residuals_default|residuals_glm|residuals_HoltWinters|residuals_isoreg|residuals_lm|residuals_nls|residuals_smooth_spline|residuals_tukeyline|rev_dendrogram|rexp|rf|rgamma|rgeom|rhyper|rlnorm|rlogis|rmultinom|rnbinom|rnorm|Roy|rpois|rsignrank|rsmirnov|rstandard|rstandard_glm|rstandard_lm|rstudent|rstudent_glm|rstudent_lm|rt|runif|runmed|rweibull|rwilcox|rWishart|safe_pchisq|safe_pf|scatter_smooth|screeplot|screeplot_default|sd|se_aov|se_aovlist|se_contrast|se_contrast_aov|se_contrast_aovlist|selfStart|selfStart_default|selfStart_formula|setNames|shapiro_test|sigma|sigma_default|sigma_glm|sigma_mlm|simpleLoess|simulate|simulate_lm|smooth|smooth_spline|smoothEnds|sortedXyData|sortedXyData_default|spec_ar|spec_pgram|spec_taper|spectrum|sphericity|spl_coef_conv|spline|splinefun|splinefunH|splinefunH0|SSasymp|SSasympOff|SSasympOrig|SSbiexp|SSD|SSD_mlm|SSfol|SSfpl|SSgompertz|SSlogis|SSmicmen|SSweibull|start|start_default|stat_anova|step|stepfun|stl|str_dendrogram|str_logLik|StructTS|summary_aov|summary_aovlist|summary_ecdf|summary_glm|summary_infl|summary_lm|summary_loess|summary_manova|summary_mlm|summary_nls|summary_ppr|summary_prcomp|summary_princomp|summary_stepfun|summary_stl|summary_tukeysmooth|supsmu|symnum|t_test|t_test_default|t_test_formula|t_ts|tail_ts|termplot|terms|terms_aovlist|terms_default|terms_formula|terms_terms|Thin_col|Thin_row|time|time_default|time_ts|toeplitz|toeplitz2|Tr|ts|ts_intersect|ts_plot|ts_union|tsdiag|tsdiag_Arima|tsdiag_arima0|tsdiag_StructTS|tsp|tsSmooth|tsSmooth_StructTS|TukeyHSD|TukeyHSD_aov|uniroot|update|update_default|update_formula|update_packageStatus|var|var_test|var_test_default|var_test_formula|variable_names|variable_names_default|variable_names_lm|varimax|vcov|vcov_aov|vcov_Arima|vcov_glm|vcov_lm|vcov_mlm|vcov_nls|vcov_summary_glm|vcov_summary_lm|weighted_mean|weighted_mean_Date|weighted_mean_default|weighted_mean_difftime|weighted_mean_POSIXct|weighted_mean_POSIXlt|weighted_residuals|weights|weights_default|weights_glm|weights_nls|wilcox_test|wilcox_test_default|wilcox_test_formula|Wilks|window|window_default|window_ts|write_ftable|xtabs)\b
        name: support.function.stat.r
      - match: \b(adist|alarm|apropos|aregexec|argNames|argsAnywhere|as_bibentry|as_bibentry_bibentry|as_bibentry_citation|as_character_person|as_character_roman|as_data_frame_bibentry|as_data_frame_citation|as_data_frame_person|as_environment_hashtab|as_person|as_person_default|as_personList|as_personList_default|as_personList_person|as_relistable|as_roman|asDateBuilt|askYesNo|aspell|aspell_filter_LaTeX_commands_from_Aspell_tex_filter_info|aspell_filter_LaTeX_worker|aspell_find_dictionaries|aspell_find_program|aspell_inspect_context|aspell_package|aspell_package_C_files|aspell_package_description|aspell_package_pot_files|aspell_package_R_files|aspell_package_Rd_files|aspell_package_vignettes|aspell_query_wiktionary_categories|aspell_R_C_files|aspell_R_manuals|aspell_R_R_files|aspell_R_Rd_files|aspell_R_vignettes|aspell_update_dictionary|aspell_write_personal_dictionary_file|assignInMyNamespace|assignInNamespace|attachedPackageCompletions|available_packages|bibentry|blank_out_character_ranges|blank_out_ignores_in_lines|blank_out_regexp_matches|browseEnv|browseURL|browseVignettes|bug_report|bug_report_info|c_bibentry|c_person|capture_output|changedFiles|charClass|check_for_XQuartz|check_screen_device|checkCRAN|checkHT|chooseBioCmirror|chooseCRANmirror|citation|cite|citeNatbib|citEntry|citFooter|citHeader|close_socket|close_txtProgressBar|clrhash|combn|compareVersion|conformToProto|contrib_url|correctFilenameToken|count_fields|create_post|data|data_entry|dataentry|de|de_ncols|de_restore|de_setup|debugcall|debugger|defaultUserAgent|demo|download_file|download_packages|dump_frames|edit|edit_data_frame|edit_default|edit_matrix|edit_vignette|emacs|example|expr2token|file_test|file_edit|fileCompletionPreferred|fileCompletions|fileSnapshot|filter_packages_by_depends_predicates|find|find_files_in_directories|findCRANmirror|findExactMatches|findFuzzyMatches|findGeneric|findLineNum|findMatches|fix|fixInNamespace|flush_console|fnLineNum|format_aspell|format_aspell_inspect_context|format_bibentry|format_citation|format_hashtab|format_MethodsFunction|format_news_db|format_object_size|format_person|format_roman|formatOL|formatUL|functionArgs|fuzzyApropos|get_parse_data_for_message_strings|getAnywhere|getCRANmirrors|getDependencies|getFromNamespace|gethash|getIsFirstArg|getKnownS3generics|getParseData|getParseText|getRcode|getRcode_vignette|getS3method|getSrcByte|getSrcDirectory|getSrcfile|getSrcFilename|getSrcLocation|getSrcref|getTxtProgressBar|glob2rx|globalVariables|hashtab|hasName|head|head_array|head_default|head_ftable|head_function|head_matrix|help|help_request|help_search|help_start|helpCompletions|history|hsearch_db|hsearch_db_concepts|hsearch_db_keywords|index_search|inFunction|install_packages|installed_packages|is_hashtab|is_relistable|isBasePkg|isInsideQuotes|isS3method|isS3stdGeneric|keywordCompletions|length_hashtab|limitedLabels|loadedPackageCompletions|loadhistory|localeToCharset|ls_str|lsf_str|macDynLoads|maintainer|make_sysdata_rda|make_packages_html|make_socket|makeRegexpSafe|makeRweaveLatexCodeRunner|makeUserAgent|maphash|matchAvailableTopics|memory_limit|memory_size|menu|merge_demo_index|merge_vignette_index|methods|mirror2html|modifyList|new_packages|news|normalCompletions|nsl|numhash|object_size|offline_help_helper|old_packages|Ops_roman|package_skeleton|packageDate|packageDescription|packageName|packageStatus|packageVersion|page|person|personList|pico|print_aspell|print_aspell_inspect_context|print_bibentry|print_Bibtex|print_browseVignettes|print_changedFiles|print_citation|print_fileSnapshot|print_findLineNumResult|print_getAnywhere|print_hashtab|print_help_files_with_topic|print_hsearch|print_hsearch_db|print_Latex|print_ls_str|print_MethodsFunction|print_news_db|print_object_size|print_packageDescription|print_packageIQR|print_packageStatus|print_person|print_roman|print_sessionInfo|print_socket|print_summary_packageStatus|print_vignette|printhsearchInternal|process_events|prompt|prompt_data_frame|prompt_default|promptData|promptImport|promptPackage|rc_getOption|rc_options|rc_settings|rc_status|read_csv|read_csv2|read_delim|read_delim2|read_DIF|read_fortran|read_fwf|read_socket|read_table|readCitationFile|recover|registerNames|regquote|relist|relist_default|relist_factor|relist_list|relist_matrix|remhash|remove_packages|removeSource|rep_bibentry|rep_person|rep_roman|resolvePkgType|Rprof|Rprof_memory_summary|Rprofmem|RShowDoc|RSiteSearch|rtags|rtags_file|Rtangle|RtangleFinish|RtangleRuncode|RtangleSetup|RtangleWritedoc|RweaveChunkPrefix|RweaveEvalWithOpt|RweaveLatex|RweaveLatexFinish|RweaveLatexOptions|RweaveLatexRuncode|RweaveLatexSetup|RweaveLatexWritedoc|RweaveTryStop|savehistory|select_list|sessionInfo|setBreakpoint|sethash|setIsFirstArg|setRepositories|setTxtProgressBar|shorten_to_string|simplifyRepos|sort_bibentry|specialCompletions|specialFunctionArgs|specialOpCompletionsHelper|specialOpLocs|stack|stack_data_frame|stack_default|Stangle|str|str_data_frame|str_Date|str_default|str_hashtab|str_POSIXt|str2logical|strcapture|strextract|strOptions|strslice|subset_news_db|substr_with_tabs|summary_aspell|summary_packageStatus|Summary_roman|summaryRprof|suppressForeignCheck|Sweave|SweaveGetSyntax|SweaveHooks|SweaveParseOptions|SweaveReadFile|SweaveSyntConv|tail|tail_array|tail_default|tail_ftable|tail_function|tail_matrix|tar|timestamp|toBibtex|toBibtex_bibentry|toBibtex_person|toLatex|toLatex_sessionInfo|toLatexPDlist|topicName|transform_bibentry|txtProgressBar|type_convert|type_convert_data_frame|type_convert_default|type_convert_list|typhash|undebugcall|unique_bibentry|unique_person|unlist_relistable|unstack|unstack_data_frame|unstack_default|untar|untar2|unzip|update_packages|update_packageStatus|upgrade|upgrade_packageStatus|url_show|URLdecode|URLencode|vi|View|vignette|warnErrList|write_csv|write_csv2|write_ctags|write_etags|write_socket|write_table|wsbrowser|xedit|xemacs|zip)\b
        name: support.function.misc.r

      # Python (legacy built-in functions)
      - match: \b(file|reduce|intern|raw_input|unicode|cmp|basestring|execfile|long|xrange)\b
        name: support.function.legacy.builtin.python

      # JavaScript and CoffeeScript Functions
      - match: \bon(Rowsinserted|Rowsdelete|Rowenter|Rowexit|Resize|Resizestart|Resizeend|Reset|Readystatechange|Mouseout|Mouseover|Mousedown|Mouseup|Mousemove|Before(cut|deactivate|unload|update|paste|print|editfocus|activate)|Blur|Scrolltop|Submit|Select|Selectstart|Selectionchange|Hover|Help|Change|Contextmenu|Controlselect|Cut|Cellchange|Clock|Close|Deactivate|Datasetchanged|Datasetcomplete|Dataavailable|Drop|Drag|Dragstart|Dragover|Dragdrop|Dragenter|Dragend|Dragleave|Dblclick|Unload|Paste|Propertychange|Error|Errorupdate|Keydown|Keyup|Keypress|Focus|Load|Activate|Afterupdate|Afterprint|Abort)\b
        name: support.function.event-handler.coffee
      - match: \b(shift|showModelessDialog|showModalDialog|showHelp|scroll|scrollX|scrollByPages|scrollByLines|scrollY|scrollTo|stop|strike|sizeToContent|sidebar|signText|sort|sup|sub|substr|substring|splice|split|send|set(Milliseconds|Seconds|Minutes|Hours|Month|Year|FullYear|Date|UTC(Milliseconds|Seconds|Minutes|Hours|Month|FullYear|Date)|Time|Hotkeys|Cursor|ZOptions|Active|Resizable|RequestHeader)|search|slice|savePreferences|small|home|handleEvent|navigate|char|charCodeAt|charAt|concat|contextual|confirm|compile|clear|captureEvents|call|createStyleSheet|createPopup|createEventObject|to(GMTString|UTCString|String|Source|UpperCase|LowerCase|LocaleString)|test|taint|taintEnabled|indexOf|italics|disableExternalCapture|dump|detachEvent|unshift|untaint|unwatch|updateCommands|join|javaEnabled|pop|push|plugins.refresh|paddings|parse|print|prompt|preference|enableExternalCapture|exec|execScript|valueOf|UTC|find|file|fileModifiedDate|fileSize|fileCreatedDate|fileUpdatedDate|fixed|fontsize|fontcolor|forward|fromCharCode|watch|link|load|lastIndexOf|anchor|attachEvent|atob|apply|alert|abort|routeEvents|resize|resizeBy|resizeTo|recalc|returnValue|replace|reverse|reload|releaseCapture|releaseEvents|go|get(Milliseconds|Seconds|Minutes|Hours|Month|Day|Year|FullYear|Time|Date|TimezoneOffset|UTC(Milliseconds|Seconds|Minutes|Hours|Day|Month|FullYear|Date)|Attention|Selection|ResponseHeader|AllResponseHeaders)|moveBy|moveBelow|moveTo|moveToAbsolute|moveAbove|mergeAttributes|match|margins|btoa|big|bold|borderWidths|blink|back)\b
        name: support.function.coffee
      - match: \b(acceptNode|add|addEventListener|addTextTrack|adoptNode|after|animate|append|appendChild|appendData|before|blur|canPlayType|captureStream|caretPositionFromPoint|caretRangeFromPoint|checkValidity|clear|click|cloneContents|cloneNode|cloneRange|close|closest|collapse|compareBoundaryPoints|compareDocumentPosition|comparePoint|contains|convertPointFromNode|convertQuadFromNode|convertRectFromNode|createAttribute|createAttributeNS|createCaption|createCDATASection|createComment|createContextualFragment|createDocument|createDocumentFragment|createDocumentType|createElement|createElementNS|createEntityReference|createEvent|createExpression|createHTMLDocument|createNodeIterator|createNSResolver|createProcessingInstruction|createRange|createShadowRoot|createTBody|createTextNode|createTFoot|createTHead|createTreeWalker|delete|deleteCaption|deleteCell|deleteContents|deleteData|deleteRow|deleteTFoot|deleteTHead|detach|disconnect|dispatchEvent|elementFromPoint|elementsFromPoint|enableStyleSheetsForSet|entries|evaluate|execCommand|exitFullscreen|exitPointerLock|expand|extractContents|fastSeek|firstChild|focus|forEach|get|getAll|getAnimations|getAttribute|getAttributeNames|getAttributeNode|getAttributeNodeNS|getAttributeNS|getBoundingClientRect|getBoxQuads|getClientRects|getContext|getDestinationInsertionPoints|getElementById|getElementsByClassName|getElementsByName|getElementsByTagName|getElementsByTagNameNS|getItem|getNamedItem|getSelection|getStartDate|getVideoPlaybackQuality|has|hasAttribute|hasAttributeNS|hasAttributes|hasChildNodes|hasFeature|hasFocus|importNode|initEvent|insertAdjacentElement|insertAdjacentHTML|insertAdjacentText|insertBefore|insertCell|insertData|insertNode|insertRow|intersectsNode|isDefaultNamespace|isEqualNode|isPointInRange|isSameNode|item|key|keys|lastChild|load|lookupNamespaceURI|lookupPrefix|matches|move|moveAttribute|moveAttributeNode|moveChild|moveNamedItem|namedItem|nextNode|nextSibling|normalize|observe|open|parentNode|pause|play|postMessage|prepend|preventDefault|previousNode|previousSibling|probablySupportsContext|queryCommandEnabled|queryCommandIndeterm|queryCommandState|queryCommandSupported|queryCommandValue|querySelector|querySelectorAll|registerContentHandler|registerElement|registerProtocolHandler|releaseCapture|releaseEvents|remove|removeAttribute|removeAttributeNode|removeAttributeNS|removeChild|removeEventListener|removeItem|replace|replaceChild|replaceData|replaceWith|reportValidity|requestFullscreen|requestPointerLock|reset|scroll|scrollBy|scrollIntoView|scrollTo|seekToNextFrame|select|selectNode|selectNodeContents|set|setAttribute|setAttributeNode|setAttributeNodeNS|setAttributeNS|setCapture|setCustomValidity|setEnd|setEndAfter|setEndBefore|setItem|setNamedItem|setRangeText|setSelectionRange|setSinkId|setStart|setStartAfter|setStartBefore|slice|splitText|stepDown|stepUp|stopImmediatePropagation|stopPropagation|submit|substringData|supports|surroundContents|takeRecords|terminate|toBlob|toDataURL|toggle|toString|values|write|writeln)\b
        name: support.function.dom.coffee
      - match: \b(isNaN|isFinite|eval|uneval|parseInt|parseFloat|decodeURI|decodeURIComponent|encodeURI|encodeURIComponent|escape|unescape|require|set(Interval|Timeout)|clear(Interval|Timeout))\b
        name: support.function.builtin.coffee

      - include: source.swift#builtin-functions
      - include: source.swift#builtin-global-functions
      - include: source.python#builtin-functions
      - include: source.python#builtin-types
      - include: source.python#magic-function-names
