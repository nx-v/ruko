name: Ruko
scopeName: source.spwn # will change to Ruko once the language is out
fileTypes: [ruko, rk, spwn]
patterns: [{include: '#core'}]

# Last updated: November 26, 2025

# This file is entirely maintained by NexoVolta (nx-v) for the Ruko programming
# language. If you want to contribute, please open an issue or a pull request
# on the official GitHub repository:

# https://github.com/nx-v/ruko

# Note that this grammar is still actively being developed alongside
# the compiler and spec itself, so frequent updates may be necessary.

# If you find any bugs or want to suggest any new features, please
# open an issue or a pull request on the repository above.

# Planned features / TODOs:
#
# - Add support for indentation-based syntax (like Python, Haskell, etc.)
#   as an alternative to curly braces for blocks. A massive refactor will
#   be needed to implement this properly.
# - Add support for reflection and meta-programming syntax.
#   Refer to the "Safe C++" and "Reflection" propsals for the C++26 standard
#   for inspiration.
#   https://safecpp.org/draft.html
#   https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2996r0.html
#   - [ ] Unsafe by default, for the sake of performance.
#     Use the 'safe' keyword to enable scoped 'safe' mode.
#   - [x] Add splicing syntax <[ ]>. Splicing is used to insert code at compile-time.
# - [x] Add dynamic JSX/XML literals <(expr)> </>.
# - [x] Backslashes are now used for infix function calls.
#   For example: a \x\ b is equivalent to x(a, b).
#   This now means that operators CANNOT start or end with a backslash,
#   and backslashes cannot be used prefix or postfix,
#   same with angle brackets, pipes, and forward slashes,
#   which are used for JSX/generics, lambdas and regexes respectively.
# - [ ] Rework inline Markdown syntax. Refer to Typst, Textile, Texy,
#   AsciiDoc and other lightweight markup languages for inspiration.
#   - [x] Headings and subheadings
#   - [x] Deleted and inserted text ~~deleted~~ ++inserted++
#   - [x] Superscript ^super^
#   - [x] Subscript ~sub~
#   - [x] Highlighted text ==highlight==
#   - [x] Redacted text ||redacted||
#   - [ ] Inline math $$math$$
#   - [ ] Spans !!.custom.classes span!!
#   - [ ] Selectors and anchors #anchor .class
#   - [ ] Code blocks
#   - [ ] Definition blocks :::
#   - [ ] Tables | Header 1 | Header 2 |
#   - [ ] Citations
#   - References:
#     https://docs.asciidoctor.org/asciidoc/latest/
#     https://typst.app/docs/reference/
#     https://texy.nette.org/en/
#     https://textile-lang.com/
# - [ ] Plan and implement all the built-in modules, classes, objects, constants
#   functions and properties for Ruko's standard library.
#   This would all be done in a separate PR and once the grammar is completely
#   finished.
# - [ ] Multi-base numeric literals (up to base 64). Digits will be \d, a-z,
#   lowercase Icelandic thorn, lowercase eth, A-Z, uppercase Icelandic thorn.
# - [ ] Add new parameter binding/destructuring syntax for:
#   - [ ] Strings (yes, strings are meant to be destructured)
#   - [ ] Regular expressions (yes, regex captures should be destructured)
#   - [ ] Arrays
#   - [ ] Sets
#   - [ ] Maps and objects
#   - [ ] Tuples
#   - [ ] Function arguments
#   - [ ] Variables
# - [x] Fix and expand regex syntax and highlighting:
#   - [x] Add support for fuzzy matching (edits, insertions, deletions, etc.)
#   - [x] Improve highlighting for regexes with flags
#   - [x] Add and expand quantifiers and range highlighting

# Changelog of notable changes since initial release:
#
# - Refactored and improved the syntax highlighting for operators.
#   Operators are now highlighted more consistently, and more Unicode
#   symbols are supported.
# - Added infix function call syntax using backslashes.
#   a \x\ b
# - Brought back Haskell-style function call syntax with
#   space OR comma-separated arguments.
#     funcName arg1 arg2 { arg3: 10 }; or
#     funcName arg1, arg2, { arg3: 10 }
#   This CANNOT be mixed and matched with normal function call syntax.
#     funcName(arg1, arg2, { arg3: 10 })
# - Add operator definition syntax for user-defined operators.
#   oper param <suffix>: return_type { ... }
#   oper <prefix> param: return_type { ... }
#   oper param1 <infix> param2: return_type { ... }
#   oper param1 <ternary_1> param2 <ternary_2> param3: return_type { ... }
#   Example: oper x ** y -> f64 = pow(x, y)
# - Added Python slicing syntax for arrays, strings, tuples, etc.:
#   array[start:end:step]
#   string[start:end:step]
#   tuple[start:end:step]
#   Negative indices and arbitrary expressions are supported.
# - Added C(++) directives: #include, #define, #ifdef, #ifndef, #else,
#   #elif, #endif, #pragma, #region, #endregion, #once, #error, #warning.
#   These can be placed anywhere in the code, and will be processed before compilation.
#   A change to #define directives is that they can support regex
#   replacements as well as normal text replacements. This is dangerous,
#   so use with caution.
# - Added new keywords: expr, eval, init (C++ static init) and comp (Zig comptime).
# - Overall syntax has been reworked to be terser and more consistent.
#   Inspired by Rust, Zig, Flix, Jai, Odin, D, Reason and Motoko.
# - Import/export/module syntax inspired by JavaScript/TypeScript, Rust and Python:
#   - glob file path matching: import path/**/*.ruko
#   - named imports/exports: import module{a,b,c}
#   - default imports/exports: import module)
#   - renaming imports/exports: import module{a:x,b:y}
#   - show/hide mechanism: import module{a,b-c,d}
#   - glob-style pattern matching: import module{a*,b?,c{1,2}}
# - Fixed many JSX/XML bugs with tags and attributes:
#   - Fixed attributes not highlighting properly in self-closing tags.
#     <MyComponent prop="value" />
#   - Fixed attributes with no values not highlighting properly.
#     <MyComponent disabled />
#   - Fixed nested tags not highlighting properly.
#     <Parent><Child></Child></Parent>
#   - Fixed the final '>' in an implicit closing tag '</>' not being highlighted properly.
#     <MyComponent></> now highlights the final > properly.
#   - Fixed comments within tags not highlighting properly.
#   - __New inline Markdown-like syntax:__
#     - **bold** __bold__
#     - _italic_ *italic*
#     - ~~deleted~~ ++inserted++
#     - ==highlighted==
#     - ||redacted||
#     - ^superscript^
#     - ~subscript~
#     - ``code``
#     - imported links: [text](url)
#   - A line starting with '>' starts a code block until the end of the line.  Use
#     brackets, braces or strings to span multiple lines.
#     <div>
#       > let x = 10
#       Normal text here.
#     </>
#   - Same for headings, which start with '# ## ### #### ##### ######' etc.
#     <div>
#       ### This is a heading
#       > let y = 20
#       More normal text.
#     </>
#   - Blockquotes now start with '*' rather than '>', to avoid conflicts with code blocks.
#     <div>
#       * This is a blockquote.
#         It can span multiple lines.
#     </>
#   - '+' and '-' indicate ordered and unordered list items respectively.
#     <div>
#       + Item 1
#       + Item 2
#         - Subitem 2.1
#         - Subitem 2.2
#       + Item 3
#     </>
# - Fix bug with highlighting of generics when followed by
#   ! or ~ macro/destructor calls. For example: Vec<int>!(), MyType~().
# - Brought back train-case for CSS properties and HTML attributes.
#   For example: background-color, font-size, border-radius, my-component, etc.
# - Added x->y syntax for C++-style pointer dereferencing.
#   object->method(arg1, arg2)
#   object->property
# - Custom modifiers can now be placed before any declaration or binding, including
#   in lambda functions, for example: async inplace func sort(x: []int) { ... }
#   This includes within map declarations and function parameters, though the
#   contextual keyword 'fn' is required in order to use those modifiers.
# - Reworked function parameter binding/destructuring syntax. For example:
#   func f(const (a, b), let {c, d}, mut [e, f], dyn g) { ... }
# - Function calls are highlighted more consistently, triggering beside ( and { only,
#   and in s-expressions right after an opening (. When a function call is assigned
#   to a variable, or used in an expression, the call is highlighted more consistently
#   and the function call must be bracketed.
# - Added s-expression and message passing syntax, resembling Lisp, Clojure, Elixir
#   and Smalltalk/Objective C syntax, but must be placed within square and round
#   brackets respectively. These may not conflict with normal function calls.
#   [object message: arg1, arg2 message2: arg3]
#   (function arg1 arg2 arg3)
# - Added keywords temp, prop, actor, realm, style, script, intern, extern,
#   assert, check, given, using, state, decl, and debug.
#   These are used for various purposes such as temporary variables, properties,
#   actors (concurrency), realms (namespaces), styles (CSS), scripts (JS),
#   internal/external linkage, assertions, context parameters, state variables,
#   declarations, and debugging.
# - Fixed empty generics: T<> is now highlighted properly in calls and annotations.
#   Fixed generics before curly braces. T<C> { x } does not trigger another type
#   annotation and highlights a regular block.
# - Added syntax for macro `x!()` and destructor `x~()` calls. These are placed
#   after the generics if any. For example: Vec<int>!(), MyType~().
# - Fixed style k-v pairs in style blocks which highlight until a semicolon, comma
#   or closing brace.
# - All control structures do not need to be bracketed. If the body of a
#   control structure is a single statement, the braces can be omitted,
#   and is replaced by a colon (:). This includes if, for, while, switch,
#   match, try, catch, etc.
# - Fixed syntax highlighting of code blocks beside lambda pipes.
# - Added numeric literals for all bases from 2 to 16, including special digits
#   for base 12 (including Unicode Turned 2 and Turned 3 for digits 10 and 11).
#   Base 12 (0z, \z in strings and character classes) uses digits \d,
#   A, X, T, or turned 2 for digit 10, and B, E or turned 3 for digit 11.
# - Numbers and escape sequences have been reworked, and will no longer accept
#   invalid digits for their respective bases beyond 0x10FFFF, or decimal 1114111.
# - Most keywords should have a max of 6 characters. Longer keywords have been
#   shortened or removed. For example, 'function' is 'func', 'property' is 'prop',
#   'template' is 'temp', 'iterator' is 'iter', etc.
# - Range keywords to, till and by have been removed in favor of Swift-like
#   range operators '>..', '...', '..<' and '>.<', and the step operator '..''.
# - Generics now capture properly before and after function and type names.
#   For example, T.<x>, T?.<x>, T!.<x>, T::<x>, T?:<x>, T!:<x>.
#   They can even be curried: x<T><U>(y), x<T><U><V>(y).
# - Generic type parameters now work for prefix operators as well. i.e. T<&x>, etc.
# - Fixed a bug where escape sequences for literals would accept integers bigger than
#   decimal 1114111 which now are highlighted as an error.
# - Bases 4 and 6 have been removed, though a multi-base (up to base 64)
#   numeric literal is still in the works.
# - Interpolation and formatting syntax have been reworked and fixed, and can now
#   span multiple lines and beyond 20 nested layers thanks to applyEndPatternLast.
#   Because of this, spacing around most of the patterns here have also been removed;
#   a separate 'space' scope is added to join everything together.
# - Fixed some bugs with regular expressions:
#   - Added and expanded quantifiers and range highlighting
#   - Add support for fuzzy matching (edits, insertions, deletions, etc.)
#   - Improved highlighting for regexes with flags
# - Added prefixes to strings, with those prefixes being the symbols used to
#   enable those features.
#   - Prefix \ makes a string raw (i.e. no escape sequences),
#   - Prefix % makes a string formatted (i.e. with interpolation and format specifiers),
#   - Prefix $ allows interpolation without formatting (i.e. simple variable/expression
#     substitution).
#   - Prefix # makes a string a #template string, which supports all features
#     and is used specifically to mark arguments inside template strings.
#   These prefixes can be combined in any order, including multiple times.
#   These will be added to regular expressions later on.
# - Added Python negation syntax: is not, if not, not in, not of.
#   - Removed unless/until keywords. Replaced by if not, while not.
# - Switched around regular expressions and unquoted strings:
#   / triggers a regex when it begins an expression. ` is now used to begin
#   unquoted strings.
# - Two (or more) regular expressions in a row on the same line without a comma
#   triggers a replacement string instead of a normal regular expression literal.
# - Changed up syntax highlighting of switch and match statements to be more
#   consistent with JavaScript.
# - Function calls now trigger beside '(' and '{'.
# - Removed Perl/Ruby's unless and until keywords. Use 'if!' and 'while!' instead.
#   for! is not supported due to the way for-loops are structured.
# - Fixed module syntax to be more consistent with JavaScript.
# - Dashes will no longer be allowed in identifiers. Use underscores instead.
# - Fixed XML highlighting and attributes, inspired by Svelte, Angular (TS), HAML
#   - @directive
#   - #id and .class
#   - :event and |pipe (both from Svelte)
#   - %directive
#   - &reference and *spread
#   - ?boolean and @property (from Lit)
# - Added script blocks for injection of raw JS, C++, Rust, Zig, etc.
#   If no language is specified, C++ is assumed, because of Ruko's compiler target.
# - Fixed keys in literal objects. They will now highlight until a colon, comma
#   or closing brace.
# - Fixed modifier keywords beside lambda functions. Modifiers can now be placed
#   before lambda functions in addition to normal function declarations.
# - Fixed default values in function arguments, thus no longer requiring trailing
#   commas. 'from' and 'where' statements, the string `\| and the operator | have to
#   be bracketed.
# - Slightly changed attribute selectors to allow for regexp matches.

working-storage-section:
  - &entity-name |
    (?x) \s*\b

    (?!
      (?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b
      (?: # keywords
        [io]n|of|[ai]s|by|has|old|new|del
        |unset|ref|deref|and|x?or|not
        |const|let|mut|dyn|va[rl]|use
        |given|expr|eval|init|comp
        |func|pro[pc]|type|class|actor|trait
        |impl|enum|module|model|struct|record
        |union|iter|macro|query|elem|temp|oper
        |object|realm|style|script|quote
        |go|defer|do|with|from|where
        |if|else|then|guard|when
        |for|loop|while|goto|move
        |try|throw|catch|switch
        |match|case|pass|def|defer
        |break|skip|redo|retry
        |return|yield|await|scope
        |import|export|intern|extern
        |debug|assert|check|decl
      )
      \b
    )

    # identifier
    ([\p{Pc}\p{L}]\w*)
    \b

  - &html-tag-names
    - match: (?x)([?!:]:|[?!]?\.|[?!-]>)
      captures:
        1: {name: punctuation.separator.namespace.ruko}
    - match: \b([\p{Pc}\p{L}]\w*)\b(?=[:.])
      name: entity.name.tag.namespace.ruko
    - match: \b((?:[\p{Pc}\p{L}&&\P{Ll}][\w&&\P{Lu}]*)+)\b
      name: support.class.component.ruko
    - include: '#clauses'
    - include: '#declarations'
    - include: '#keywords'
    - include: '#html-tag-names'

repository:
  core:
    patterns:
      - include: '#punctuation'
      - include: '#directives'
      - include: '#ignore-long-lines'
      - include: '#clauses'
      - include: '#declarations'
      - include: '#keywords'
      - include: '#comments'
      - include: '#argument-list'
      - include: '#function-clause'
      - include: '#function-calls'
      - include: '#symbols'
      - include: '#decorators'
      - include: '#type-signature'
      - include: '#splice-brackets'
      - include: '#xml'
      - include: '#generics'
      - include: '#literals'
      - include: '#accessor-operators'
      - include: '#brackets'
      - include: '#operators'
      - include: '#variables'
      - include: '#illegal'
      - include: '#space'

  # Ignore / illegal patterns

  ignore-long-lines:
    comment: avoid parsing files with long lines of code
    match: ^\N{4097,}$

  space:
    match: \s+
    name: meta.var.expr.ruko

  illegal:
    patterns:
      - match: \p{N}+
        name: invalid.illegal.number.ruko
      - match: \w+
        name: invalid.illegal.variable.ruko
      - match: '[({\[)}\]]+'
        name: invalid.illegal.missing-bracket.ruko
      - match: '[\p{P}\p{S}&&[^,;''"`({\[)}\]\p{Pc}]]+'
        name: invalid.illegal.operator.ruko
      - match: \S+
        name: invalid.illegal.uncaught.ruko

  illegal-identifier:
    applyEndPatternLast: true
    name: meta.type.ruko
    begin: (?<=\w+\b)\s*(?=\b\w+)
    end: (?=)|$
    patterns:
      - match: \s*\w+\s*
        name: invalid.illegal.identifier.ruko

  # Directives

  directives:
    comments: Yeah these are just straight-up copied from C/C++ grammars
    patterns:
      - applyEndPatternLast: true
        begin: ^\s*(\#)(!|if|else|elif|end|ifdef|ifndef)\b
        end: $
        name: meta.directive.ruko
        captures:
          1: {name: punctuation.definition.directive.ruko}
          2: {name: keyword.control.directive.ruko}
        patterns: [{include: $self}]
      - applyEndPatternLast: true
        begin: ^\s*(\#)(define|undef)\b
        end: $
        name: meta.directive.ruko
        captures:
          1: {name: punctuation.definition.directive.ruko}
          2: {name: keyword.control.directive.ruko}
        patterns:
          - include: '#regexp-patterns'
          - begin: (:)\s*
            end: \s*([,;])|$
            name: string.regexp.replace.ruko
            captures:
              1: {name: punctuation.definition.regexp.ruko}
            patterns:
              - include: '#back-references'
              - include: '#xml-regex-content'
              - begin: \s*(\{)
                end: (\})\s*
                name: meta.interpolation.regexp.ruko
                captures:
                  1: {name: punctuation.definition.variable.ruko}
                patterns:
                  - include: '#back-references'
                  - include: '#xml-regex-content'
                  - include: $self
          - match: .+
            name: meta.directive.definition.ruko
      - applyEndPatternLast: true
        begin: ^\s*(\#)(include|exclude|import|export|extern|intern)\b
        end: $
        name: meta.directive.ruko
        captures:
          1: {name: punctuation.definition.directive.ruko}
          2: {name: keyword.control.directive.ruko}
        patterns: [{include: '#module-content'}]
      - applyEndPatternLast: true
        begin: ^\s*(\#)(pragma|region|endregion|once)\b
        end: $
        name: meta.directive.ruko
        captures:
          1: {name: punctuation.definition.directive.ruko}
          2: {name: keyword.control.directive.ruko}
        patterns: [{include: $self}]
      - comment: null directive
        match: ^\s*(\#)\s*$
        name: meta.directive.ruko
        captures:
          1: {name: punctuation.definition.directive.ruko}
          2: {name: text.whitespace.ruko}
        patterns: [{include: $self}]

  # Types

  types:
    patterns:
      - include: '#comments'
      - include: '#type-brackets'
      - include: '#embedded-expressions'
      - include: '#embedded-formatting'
      - include: '#embedded-arguments'
      - include: '#angle-brackets'
      - include: '#type-modifiers'
      - include: '#type-keywords'
      - include: '#type-names'
      - include: '#literals'
      - include: '#type-variables'
      - include: '#type-operators'
      - include: '#space'

  type-variables:
    comment: Four types of variables - _lead_underscore UPPERCASE PascalCase camelCase
    match: |
      (?x) \s* \b

      (?!
        (?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b
        (?: # keywords
          [io]n|of|[ai]s|by|has|old|new|del
          |unset|ref|deref|and|x?or|not
          |const|let|mut|dyn|va[rl]|use
          |given|expr|eval|init|comp
          |func|pro[pc]|type|class|actor|trait
          |impl|enum|module|model|struct|record
          |union|iter|macro|query|elem|temp|oper
          |object|realm|style|script|quote
          |go|defer|do|with|from|where
          |if|else|then|guard|when
          |for|loop|while|goto|move
          |try|throw|catch|switch
          |match|case|pass|def|defer
          |break|skip|redo|retry
          |return|yield|await|scope
          |import|export|intern|extern
          |debug|assert|check|decl
        )
        \b
      )

      (?:
        (?<=
          (?: ['"`)\]}\w] | \\.) \s* # literal, bracket or space
          (?: [?!]?\. | [?!:]: | [?!-]> ) =? # accessor or qualified name separator
        )
        \b # methods
        (?: # Properties
            # Leading underscore
            (\p{Pc}+\w*\b(?!\p{Pc}+))
          | # Train case
            ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)
          | # Pascal case
            ((?:[\p{Pc}\p{L}&&\P{Ll}][\w&&\P{Lu}]*)+)
          | # Camel or kebab case
            ([\p{Pc}\p{L}]\w*)
        )
        |
        (?<!
          (?: [,;'"`)}\]\w] | \\. ) # literal, bracket or space
          (?: [\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]+ ) # operators
        )
        \b
        (?: # Objects
            # Leading underscore
            (\p{Pc}+\w*\b(?!\p{Pc}+))
          | # Train case
            ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)
          | # Pascal case
            ((?:[\p{Pc}\p{L}&&\P{Ll}][\w&&\P{Lu}]*)+)
          | # Camel or kebab case
            ([\p{Pc}\p{L}]\w*)
        )
        (?! [?!]?\.\.+ ) # not a range operator
        (?= 
            (?: [?!]?\. | [?!:]: | [?!-]> ) =? # accessor or qualified name separator
          | \#?\[ # or array access
        )
        |
        (?: # Regular variables
            # Leading underscore
            (\p{Pc}+\w*\b(?!\p{Pc}+))
          | # Train case
            ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)
          | # Pascal case
            ((?:[\p{Pc}\p{L}&&\P{Ll}][\w&&\P{Lu}]*)+)
          | # Camel or kebab case
            ([\p{Pc}\p{L}]\w*)
        )
      )\b

      \s*
    captures:
      1: {name: entity.name.trait.ruko}
      2: {name: entity.name.interface.ruko}
      3: {name: entity.name.interface.ruko}
      4: {name: entity.name.trait.ruko}
      5: {name: entity.name.module.ruko}
      6: {name: entity.name.namespace.ruko}
      7: {name: entity.name.namespace.ruko}
      8: {name: entity.name.module.ruko}
      9: {name: entity.name.type.ruko}
      10: {name: entity.name.class.ruko}
      11: {name: entity.name.class.ruko}
      12: {name: entity.name.type.ruko}

  type-signature:
    applyEndPatternLast: true
    name: meta.type.ruko
    begin: (?<=(?:[)}\]\w'"`]|\\.)>*\|?|^\|?)(:)(?=$|<*(?:['"`\w\s]|\#?[(\[{]))
    end: (?=)|$
    beginCaptures:
      1: {name: punctuation.definition.annotation.ruko}
    patterns: [{include: '#types'}]

  type-brackets:
    patterns:
      - include: '#type-curly-brackets'
      - include: '#type-square-brackets'
      - include: '#type-round-brackets'

  type-curly-brackets:
    repository:
      punctuation:
        patterns:
          - match: ','
            name: punctuation.separator.mapping.ruko
          - match: (?<=(?:['"`)}\]\w]|\\.)[\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]*):(?=(?:['"`\w\s]|\#?[(\[{])|$)
            name: punctuation.separator.key-value.ruko

    patterns:
      - begin: |
          (?x)
          (?<=
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \b
              (?: # destructuring keywords
                const|let|mut|dyn|va[rl]|use
                |given|expr|eval|init|comp
                |case
              )
            \b
            (?:$|[,;'"({\[)}\]\s]) # beside a delimiter or space
            >* # after generics
            \s*
          )
          (\#?\{)\s*
        end: \s*(\})
        name: meta.brace.curly.ruko
        captures:
          1:
            name: punctuation.definition.binding-pattern.object.ruko
        patterns:
          - include: '#labels'
          - include: '#punctuation'
          - include: '#as-keyword'
          - include: '#types'
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \b
              (?: # expression keywords
                [io]n|of|[ai]s|by|has|old|new|del
                |unset|ref|deref|and|x?or|not
              )
            \b
            (?:$|[,;'"({\[)}\]\s]) # beside a delimiter or space
            >* # after generics
            \s*
          )
          (\#\{)\s*
        end: \s*(\})
        name: meta.brace.curly.ruko
        captures:
          1: {name: punctuation.definition.mapping.ruko}
        patterns:
          - include: '#labels'
          - include: '#punctuation'
          - include: '#types'
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \b
              (?: # expression keywords
                [io]n|of|[ai]s|by|has|old|new|del
                |unset|ref|deref|and|x?or|not
              )
            \b
            (?:$|[,;'"({\[)}\]\s]) # beside a delimiter or space
            >* # after generics
            \s*
          )
          (\{)\s*
        end: \s*(\})
        name: meta.brace.curly.ruko
        captures:
          1: {name: punctuation.definition.dictionary.ruko}
        patterns:
          - include: '#labels'
          - include: '#punctuation'
          - include: '#types'
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:
                ^
              | [,;({\[]
              | (?:^|[,;({\[)}\]\w'"`]|\\.):\s*
              | [\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]+
            )
            \s*
          )
          (?<! (?: [\w'"`)}\]] | \\.) >* \s* ) # not after generics
          (\#\{)\s*
        end: \s*(\})
        name: meta.brace.curly.ruko
        captures:
          1: {name: punctuation.definition.mapping.ruko}
        patterns:
          - include: '#labels'
          - include: '#punctuation'
          - include: '#types'
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:
                ^
              | [,;({\[]
              | (?:^|[,;({\[)}\]\w'"`]|\\.):\s*
              | [\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]+
            )
            \s*
          )
          (?<! (?: [\w'"`)}\]] | \\.) >* \s* ) # not after generics
          (\{)\s*
        end: \s*(\})
        name: meta.brace.curly.ruko
        captures:
          1: {name: punctuation.definition.dictionary.ruko}
        patterns:
          - include: '#labels'
          - include: '#punctuation'
          - include: '#types'
          - include: $self

  type-round-brackets:
    repository:
      punctuation:
        patterns:
          - match: ','
            name: punctuation.separator.arguments.ruko
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(as)\b\s*
            name: keyword.operator.expression.as.ruko
          - match: (?<=[\w\s][(|])\.
            name: punctuation.definition.metadata.ruko

    patterns:
      - begin: |
          (?x)
          (?<= # literal
              (?: [\w'"`)}\]] | \\.) >* \s*
            | [^.]\.=?|[?!:]:=?
          )
          (\#?\()\s*
        end: \s*(\))
        name: meta.brace.round.ruko
        captures:
          1: {name: punctuation.definition.parameters.ruko}
        patterns:
          - include: '#types'
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \b
              (?: # destructuring keywords
                const|let|mut|dyn|va[rl]|use
                |given|expr|eval|init|comp
                |case
              )
            \b
            (?:$|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \s*
          )
          (\#?\()\s*
        end: \s*(\))
        name: meta.brace.round.ruko
        captures:
          1: {name: punctuation.definition.binding-pattern.tuple.ruko}
        patterns:
          - include: '#punctuation'
          - include: '#types'
          - include: $self
      - begin: (\#\()\s*
        end: \s*(\))
        name: meta.brace.round.ruko
        captures:
          1: {name: punctuation.definition.tuple.ruko}
        patterns:
          - include: '#types'
          - include: $self
      - begin: (\()\s*
        end: \s*(\))
        name: meta.brace.round.ruko
        captures:
          1: {name: punctuation.definition.expression.ruko}
        patterns:
          - include: '#types'
          - include: $self

  type-square-brackets:
    repository:
      punctuation:
        patterns:
          - match: ','
            name: punctuation.separator.sequence.ruko

    patterns:
      - begin: |
          (?x)
          (?<= # literal
              (?: [\w'"`)}\]] | \\.) \s*
            | [^.]\.=?|[?!:]:=?
          )
          (\#?\[)\s*
        end: \s*(\])
        name: meta.brace.square.ruko
        captures:
          1: {name: punctuation.definition.attribute-selector.ruko}
        patterns:
          - include: '#types'
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \b
              (?: # destructuring keywords
                const|let|mut|dyn|va[rl]|use
                |given|expr|eval|init|comp
                |case
              )
            \b
            (?:$|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \s*
          )
          (\#?\[)\s*
        end: \s*(\])
        name: meta.brace.square.ruko
        captures:
          1: {name: punctuation.definition.binding-pattern.array.ruko}
        patterns:
          - include: '#punctuation'
          - include: '#types'
          - include: $self
      - begin: (\#\[)\s*
        end: \s*(\])
        name: meta.brace.square.ruko
        captures:
          1: {name: punctuation.definition.sequence.ruko}
        patterns:
          - include: '#punctuation'
          - include: '#types'
          - include: $self
      - begin: (\[)\s*
        end: \s*(\])
        name: meta.brace.square.ruko
        captures:
          1: {name: punctuation.definition.array.ruko}
        patterns:
          - include: '#punctuation'
          - include: '#types'
          - include: $self

  type-keywords:
    patterns:
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(from)\b\s*
        name: storage.type.extends.ruko
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(for)\b\s*
        name: storage.type.implements.ruko
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(infer|as)\b\s*
        name: keyword.operator.expression.$1.ruko
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(is\s+not|is|has\s+not|has|has\s+not|has)\b\s*
        name: keyword.operator.expression.is.ruko
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b((inst|value|pair|type|name|size|key)of)\b\s*
        name: keyword.operator.expression.$1.ruko
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(instof)\b\s*
        name: keyword.operator.expression.instanceof.ruko
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(ext)\b\s*
        name: storage.type.extends.ruko
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(impl)\b\s*
        name: storage.type.implements.ruko

  type-operators:
    patterns:
      - &qualified-name-separators
        comment: Qualified name separators
        match: (?<=[)}\]\w])(?:(\?[.:>]=?)|(![.:>]=?)|((?:::|\.|->)=?))(?=[({\[\w])
        captures:
          1: {name: keyword.operator.optional.ruko}
          2: {name: keyword.operator.assert.ruko}
          3: {name: keyword.operator.accessor.ruko}
      - match: \s*(--?>|~~?>|==?>)
        name: keyword.operator.type.function.ruko
      - match: \s*(<--?|<~~?|<==?)
        name: keyword.operator.type.channel.ruko
      - comment: Prefix type operators
        match: |
          (?x)
          \s*
          (?:
             (\*)  # pointer
            |(\&)  # reference
            |(\%)  # format
            |(\@)  # decorator
            |(\^)  # borrow 
            |(\!)  # negation
            |(\~)  # destructor
            |(\?)  # optional
            |(\\)  # lifetime
            |(\-)  # negation
            |(\+)  # arithmetic
            |(\.\.\.) # spread
          ) 
          (?=[\w'"`]|\#?[(\[{<])
        captures: &prefix-type-operator-captures
          1: {name: keyword.operator.pointer.ruko}
          2: {name: keyword.operator.reference.ruko}
          3: {name: keyword.operator.format.ruko}
          4: {name: keyword.operator.decorator.ruko}
          5: {name: keyword.operator.borrow.ruko}
          6: {name: keyword.operator.negation.ruko}
          7: {name: keyword.operator.destructor.ruko}
          8: {name: keyword.operator.optional.ruko}
          9: {name: keyword.operator.lifetime.ruko}
          10: {name: keyword.operator.negation.ruko}
          11: {name: keyword.operator.arithmetic.ruko}
          12: {name: keyword.operator.spread.ruko}
      - comment: Infix type operators
        match: |
          (?x)
          (?<=^|['"`)}\]\w\s]|\\.)
            (?:
               (\+)      # sum
              |(\-)      # difference
              |(\|)      # union
              |(\&)      # intersection
              |(\^)      # exclusion 
              |(<:|>:)   # strict super/subtype
              |(<=|>=)   # super/subtype
              |(!=|==)   # inequality/equality
              |(<<|>>)   # variance (i.e. covariant/contravariant)
              |(===|!==) # identity/non-identity
              |(=~|!~)   # pattern match/non-pattern match
              |(:)       # extends/implements
            )
          (?=['"`\w\s]|\#?[(\[{])
        captures:
          1: {name: keyword.operator.sum.ruko}
          2: {name: keyword.operator.difference.ruko}
          3: {name: keyword.operator.union.ruko}
          4: {name: keyword.operator.intersection.ruko}
          5: {name: keyword.operator.exclusion.ruko}
          6: {name: keyword.operator.relation.ruko}
          7: {name: keyword.operator.relation.ruko}
          8: {name: keyword.operator.comparison.ruko}
          9: {name: keyword.operator.coalescing.ruko}
          10: {name: keyword.operator.comparison.ruko}
          11: {name: keyword.operator.similarity.ruko}
          12: {name: keyword.operator.prototype.ruko}
      - comment: Suffix type operators
        match: |
          (?x)
          (?<=[\w'"`)\]}>]|\\.)
          (?:
             (\!) # negation
            |(\?) # existential
          )
          \B
        captures: &suffix-type-operator-captures
          1: {name: keyword.operator.assert.ruko}
          2: {name: keyword.operator.existential.ruko}

  parameter-type-operators:
    patterns:
      - comment: Prefix type operators
        match: |
          (?x)
          (?:
             (\*)  # pointer
            |(\&)  # reference
            |(\%)  # format
            |(\@)  # decorator
            |(\^)  # borrow 
            |(\!)  # negation
            |(\~)  # destructor
            |(\?)  # optional
            |(\\)  # lifetime
            |(\-)  # negation
            |(\+)  # arithmetic
            |(\.\.\.) # spread
          )
        captures: *prefix-type-operator-captures
      - comment: Suffix type operators
        match: |
          (?x)
          (?:
             (\!) # negation
            |(\?) # existential
          )
        captures: *suffix-type-operator-captures

  # Literals and Constants

  literals:
    patterns:
      - include: '#regexps'
      - include: '#strings'
      - include: '#numbers'
      - include: '#constants'
      - include: '#strings-unquoted'
      - include: '#symbols'

  constants:
    patterns:
      - match: |
          (?x)
          (?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b
          (?:
            (true|false) # boolean
            |(null|nan)
            |(undef) # undefined
            |(inf) # infinity
          )
          \b
        captures:
          1: {name: constant.language.boolean.$1.ruko}
          2: {name: constant.language.$2.ruko}
          3: {name: constant.language.undefined.ruko}
          4: {name: constant.language.infinity.ruko}
      - match: |
          (?x)
          (?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b
          (?:
            (it|this|super|self) # special arguments
            |(args) # arguments
            |(ctor) # constructor
            |(proto) # prototype
          )
          \b
        captures:
          1: {name: variable.language.$1.ruko}
          2: {name: variable.language.arguments.ruko}
          3: {name: variable.language.constructor.ruko}
          4: {name: variable.language.prototype.ruko}
      - match: |
          (?x)
          (?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b
          (
            console|document|window|global|process|require|module|exports
            |navigator|location|history|localStorage|sessionStorage
          )
          \b
        captures:
          1: {name: support.type.object.$1.ruko}

  # Numbers

  numbers:
    applyEndPatternLast: true
    begin: (?=\d)
    end: \b\s*
    name: meta.number.ruko
    patterns:
      - comment: binary integer literal
        name: constant.numeric.binary.ruko
        match: |
          (?ix) \b
            (0b) # prefix
            [0-1] [0-1_]* # integer part
            (\.)? # decimal point
            [0-1_]* # fractional part
            (?: # exponent part
              (p) # delimiter
              ([+-])? # sign
              ([\d_]+) # mantissa
            )?
            ([\p{Pc}\p{L}]\w*)? # type suffix
          \b
        captures:
          1: {name: storage.type.numeric.ruko}
          2: {name: keyword.other.unit.ruko}
          3: {name: keyword.operator.expression.exponent.ruko}
          4: {name: keyword.operator.exponent.sign.ruko}
          5: {name: constant.numeric.decimal.exponent.mantissa.ruko}
          6: {name: keyword.other.unit.ruko}
      - comment: ternary integer literal
        name: constant.numeric.ternary.ruko
        match: |
          (?ix) \b
            (0t) # prefix
            [0-2] [0-2_]* # integer part
            (\.)? # decimal point
            [0-2_]* # fractional part
            (?: # exponent part
              (p) # delimiter
              ([+-])? # sign
              ([\d_]+) # mantissa
            )?
            ([\p{Pc}\p{L}]\w*)? # type suffix
          \b
        captures:
          1: {name: storage.type.numeric.ruko}
          2: {name: keyword.other.unit.ruko}
          3: {name: keyword.operator.expression.exponent.ruko}
          4: {name: keyword.operator.exponent.sign.ruko}
          5: {name: constant.numeric.decimal.exponent.mantissa.ruko}
          6: {name: keyword.other.unit.ruko}
      - comment: quaternary integer literal
        name: constant.numeric.quaternary.ruko
        match: |
          (?ix) \b
            (0q) # prefix
            [0-3] [0-3_]* # integer part
            (\.)? # decimal point
            [0-3_]* # fractional part
            (?: # exponent part
              (p) # delimiter
              ([+-])? # sign
              ([\d_]+) # mantissa
            )?
            ([\p{Pc}\p{L}]\w*)? # type suffix
          \b
        captures:
          1: {name: storage.type.numeric.ruko}
          2: {name: keyword.other.unit.ruko}
          3: {name: keyword.operator.expression.exponent.ruko}
          4: {name: keyword.operator.exponent.sign.ruko}
          5: {name: constant.numeric.decimal.exponent.mantissa.ruko}
          6: {name: keyword.other.unit.ruko}
      - comment: quinary integer literal
        name: constant.numeric.quinary.ruko
        match: |
          (?ix) \b
            (0p) # prefix
            [0-4] [0-4_]* # integer part
            (\.)? # decimal point
            [0-4_]* # fractional part
            (?: # exponent part
              (p) # delimiter
              ([+-])? # sign
              ([\d_]+) # mantissa
            )?
            ([\p{Pc}\p{L}]\w*)? # type suffix
          \b
        captures:
          1: {name: storage.type.numeric.ruko}
          2: {name: keyword.other.unit.ruko}
          3: {name: keyword.operator.expression.exponent.ruko}
          4: {name: keyword.operator.exponent.sign.ruko}
          5: {name: constant.numeric.decimal.exponent.mantissa.ruko}
          6: {name: keyword.other.unit.ruko}
      - comment: senary integer literal
        name: constant.numeric.senary.ruko
        match: |
          (?ix) \b
            (0h) # prefix
            [0-5] [0-5_]* # integer part
            (\.)? # decimal point
            [0-5_]* # fractional part
            (?: # exponent part
              (p) # delimiter
              ([+-])? # sign
              ([\d_]+) # mantissa
            )?
            ([\p{Pc}\p{L}]\w*)? # type suffix
          \b
        captures:
          1: {name: storage.type.numeric.ruko}
          2: {name: keyword.other.unit.ruko}
          3: {name: keyword.operator.expression.exponent.ruko}
          4: {name: keyword.operator.exponent.sign.ruko}
          5: {name: constant.numeric.decimal.exponent.mantissa.ruko}
          6: {name: keyword.other.unit.ruko}
      - comment: septenary integer literal
        name: constant.numeric.septenary.ruko
        match: |
          (?ix) \b
            (0s) # prefix
            [0-6] [0-6_]* # integer part
            (\.)? # decimal point
            [0-6_]* # fractional part
            (?: # exponent part
              (p) # delimiter
              ([+-])? # sign
              ([\d_]+) # mantissa
            )?
            ([\p{Pc}\p{L}]\w*)? # type suffix
          \b
        captures:
          1: {name: storage.type.numeric.ruko}
          2: {name: keyword.other.unit.ruko}
          3: {name: keyword.operator.expression.exponent.ruko}
          4: {name: keyword.operator.exponent.sign.ruko}
          5: {name: constant.numeric.decimal.exponent.mantissa.ruko}
          6: {name: keyword.other.unit.ruko}
      - comment: octal integer literal
        name: constant.numeric.octal.ruko
        match: |
          (?ix) \b
            (0o) # prefix
            [0-7] [0-7_]* # integer part
            (\.)? # decimal point
            [0-7_]* # fractional part
            (?: # exponent part
              (p) # delimiter
              ([+-])? # sign
              ([\d_]+) # mantissa
            )?
            ([\p{Pc}\p{L}]\w*)? # type suffix
          \b
        captures:
          1: {name: storage.type.numeric.ruko}
          2: {name: keyword.other.unit.ruko}
          3: {name: keyword.operator.expression.exponent.ruko}
          4: {name: keyword.operator.exponent.sign.ruko}
          5: {name: constant.numeric.decimal.exponent.mantissa.ruko}
          6: {name: keyword.other.unit.ruko}
      - comment: nonary integer literal
        name: constant.numeric.nonary.ruko
        match: |
          (?ix) \b
            (0e) # prefix
            [0-8] [0-8_]* # integer part
            (\.)? # decimal point
            [0-8_]* # fractional part
            (?: # exponent part
              (p) # delimiter
              ([+-])? # sign
              ([\d_]+) # mantissa
            )?
            ([\p{Pc}\p{L}]\w*)? # type suffix
          \b
        captures:
          1: {name: storage.type.numeric.ruko}
          2: {name: keyword.other.unit.ruko}
          3: {name: keyword.operator.expression.exponent.ruko}
          4: {name: keyword.operator.exponent.sign.ruko}
          5: {name: constant.numeric.decimal.exponent.mantissa.ruko}
          6: {name: keyword.other.unit.ruko}
      - comment: decimal integer literal
        name: constant.numeric.decimal.ruko
        match: |
          (?ix) \b
            (0d) # prefix
            [0-9] [0-9_]* # integer part
            (\.)? # decimal point
            [0-9_]* # fractional part
            (?: # exponent part
              (e) # delimiter
              ([+-])? # sign
              ([\d_]+) # mantissa
            )?
            ([\p{Pc}\p{L}]\w*)? # type suffix
          \b
        captures:
          1: {name: storage.type.numeric.ruko}
          2: {name: keyword.other.unit.ruko}
          3: {name: keyword.operator.expression.exponent.ruko}
          4: {name: keyword.operator.exponent.sign.ruko}
          5: {name: constant.numeric.decimal.exponent.mantissa.ruko}
          6: {name: keyword.other.unit.ruko}
      - comment: undecimal integer literal
        name: constant.numeric.undecimal.ruko
        match: |
          (?ix) \b
            (0l) # prefix
            [\da-a] [\da-a_]* # integer part
            (\.)? # decimal point
            [\da-a_]* # fractional part
            (?: # exponent part
              (p) # delimiter
              ([+-])? # sign
              ([\d_]+) # mantissa
            )?
            ([\p{Pc}\p{L}]\w*)? # type suffix
          \b
        captures:
          1: {name: storage.type.numeric.ruko}
          2: {name: keyword.other.unit.ruko}
          3: {name: keyword.operator.expression.exponent.ruko}
          4: {name: keyword.operator.exponent.sign.ruko}
          5: {name: constant.numeric.decimal.exponent.mantissa.ruko}
          6: {name: keyword.other.unit.ruko}
      - comment: duodecimal integer literal
        name: constant.numeric.duodecimal.ruko
        match: |
          (?ix) \b
            (0z) # prefix
            [\d↊↋abetx] [\d↊↋abetx_]* # integer part
            (\.)? # decimal point
            [\d↊↋abetx_]* # fractional part
            (?: # exponent part
              (p) # delimiter
              ([+-])? # sign
              ([\d_]+) # mantissa
            )?
            ([\p{Pc}\p{L}]\w*)? # type suffix
          \b
        captures:
          1: {name: storage.type.numeric.ruko}
          2: {name: keyword.other.unit.ruko}
          3: {name: keyword.operator.expression.exponent.ruko}
          4: {name: keyword.operator.exponent.sign.ruko}
          5: {name: constant.numeric.decimal.exponent.mantissa.ruko}
          6: {name: keyword.other.unit.ruko}
      - comment: tridecimal integer literal
        name: constant.numeric.tridecimal.ruko
        match: |
          (?ix) \b
            (0r) # prefix
            [\da-c] [\da-c_]* # integer part
            (\.)? # decimal point
            [\da-c_]* # fractional part
            (?: # exponent part
              (p) # delimiter
              ([+-])? # sign
              ([\d_]+) # mantissa
            )?
            ([\p{Pc}\p{L}]\w*)? # type suffix
          \b
        captures:
          1: {name: storage.type.numeric.ruko}
          2: {name: keyword.other.unit.ruko}
          3: {name: keyword.operator.expression.exponent.ruko}
          4: {name: keyword.operator.exponent.sign.ruko}
          5: {name: constant.numeric.decimal.exponent.mantissa.ruko}
          6: {name: keyword.other.unit.ruko}
      - comment: tetradecimal integer literal
        name: constant.numeric.tetradecimal.ruko
        match: |
          (?ix) \b
            (0c) # prefix
            [\da-d] [\da-d_]* # integer part
            (\.)? # decimal point
            [\da-d_]* # fractional part
            (?: # exponent part
              (p) # delimiter
              ([+-])? # sign
              ([\d_]+) # mantissa
            )?
            ([\p{Pc}\p{L}]\w*)? # type suffix
          \b
        captures:
          1: {name: storage.type.numeric.ruko}
          2: {name: keyword.other.unit.ruko}
          3: {name: keyword.operator.expression.exponent.ruko}
          4: {name: keyword.operator.exponent.sign.ruko}
          5: {name: constant.numeric.decimal.exponent.mantissa.ruko}
          6: {name: keyword.other.unit.ruko}
      - comment: pentadecimal integer literal
        name: constant.numeric.pentadecimal.ruko
        match: |
          (?ix) \b
            (0k) # prefix
            [\da-e] [\da-e_]* # integer part
            (\.)? # decimal point
            [\da-e_]* # fractional part
            (?: # exponent part
              (p) # delimiter
              ([+-])? # sign
              ([\d_]+) # mantissa
            )?
            ([\p{Pc}\p{L}]\w*)? # type suffix
          \b
        captures:
          1: {name: storage.type.numeric.ruko}
          2: {name: keyword.other.unit.ruko}
          3: {name: keyword.operator.expression.exponent.ruko}
          4: {name: keyword.operator.exponent.sign.ruko}
          5: {name: constant.numeric.decimal.exponent.mantissa.ruko}
          6: {name: keyword.other.unit.ruko}
      - comment: hexadecimal integer literal
        name: constant.numeric.hexadecimal.ruko
        match: |
          (?ix) \b
            (0x) # prefix
            [\da-f] [\da-f_]* # integer part
            (\.)? # decimal point
            [\da-f_]* # fractional part
            (?: # exponent part
              (p) # delimiter
              ([+-])? # sign
              ([\d_]+) # mantissa
            )?
            ([\p{Pc}\p{L}]\w*)? # type suffix
          \b
        captures:
          1: {name: storage.type.numeric.ruko}
          2: {name: keyword.other.unit.ruko}
          3: {name: keyword.operator.expression.exponent.ruko}
          4: {name: keyword.operator.exponent.sign.ruko}
          5: {name: constant.numeric.decimal.exponent.mantissa.ruko}
          6: {name: keyword.other.unit.ruko}
      - comment: decimal (no prefix)
        name: constant.numeric.decimal.ruko
        match: |
          (?ix) \b
            () # prefix
            \d [\d_]* # integer part
            (\.)? # decimal point
            [\d_]* # fractional part
            (?: # exponent part
              (e) # delimiter
              ([+-])? # sign
              ([\d_]+) # mantissa
            )?
            ([\p{Pc}\p{L}]\w*)? # type suffix
          \b
        captures:
          1: {name: storage.type.numeric.ruko}
          2: {name: keyword.other.unit.ruko}
          3: {name: keyword.operator.expression.exponent.ruko}
          4: {name: keyword.operator.exponent.sign.ruko}
          5: {name: constant.numeric.decimal.exponent.mantissa.ruko}
          6: {name: keyword.other.unit.ruko}

  # Symbols

  decorators:
    applyEndPatternLast: true
    begin: (?<=^|\\.|['"`({\[)}\]\s]|(?:[)}\]\w\s'"`]|\\.)\s*[:=])(\@)(?=[\p{Pc}\p{L}])
    end: (?=)|$
    name: entity.name.decorator.ruko
    captures:
      1: {name: punctuation.definition.decorator.ruko}
      2: {name: entity.name.decorator.ruko}
    patterns:
      - include: '#function-calls'
      - include: '#sigil-function-calls'
      - match: '[?!:]:|[?!]?\.|[?!-]>'
        name: punctuation.separator.namespace.ruko
      - include: '#brackets'
      - include: '#strings'
      - include: '#variables'

  symbols:
    patterns:
      - comment: quoted symbol
        applyEndPatternLast: true
        begin: (?<=^|\\.|['"`({\[)}\]\s]|(?:[)}\]\w\s'"`]|\\.)\s*[:=])(:)(?=[`'"])
        end: (?=)|$
        name: constant.language.symbol-type.ruko
        captures:
          1: {name: punctuation.definition.symbol.ruko}
        patterns:
          - include: '#strings'
      - match: (?<=^|\\.|['"`({\[)}\]\s]|(?:[)}\]\w\s'"`]|\\.)\s*[:=])(:)(\b[\p{Pc}\p{L}]\w*\b)
        name: constant.other.symbol.ruko
        captures:
          1: {name: punctuation.definition.symbol.ruko}
          2: {name: constant.other.symbol.ruko}
        patterns:
          - include: '#string-escapes'

  strings-unquoted:
    comment: Unquoted string
    applyEndPatternLast: true
    begin: (`)
    end: (?=\W)|$
    name: string.template.ruko
    captures:
      1: {name: punctuation.definition.string.ruko}
    patterns:
      - match: \b\p{Pd}+\b
      - include: '#string-escapes'

  strings:
    patterns:
      - comment: multi- single-quoted verbatim, interpolated, format, and template string
        begin: \s*(\\+\$+%+\#+|\\+\$+\#+%+|\\+%+\$+\#+|\\+%+\#+\$+|\\+\#+\$+%+|\\+\#+%+\$+|\$+\\+%+\#+|\$+\\+\#+%+|\$+%+\\+\#+|\$+%+\#+\\+|\$+\#+\\+%+|\$+\#+%+\\+|%+\\+\$+\#+|%+\\+\#+\$+|%+\$+\\+\#+|%+\$+\#+\\+|%+\#+\\+\$+|%+\#+\$+\\+|\#+\\+\$+%+|\#+\\+%+\$+|\#+\$+\\+%+|\#+\$+%+\\+|\#+%+\\+\$+|\#+%+\$+\\+)('''+)\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - match: '''''|\$\$|%%|\#\#'
            name: constant.character.escape.ruko
          - include: '#embedded-expressions'
          - include: '#embedded-formatting'
          - include: '#embedded-arguments'
      - comment: multi- double-quoted verbatim, interpolated, format, and template string
        begin: \s*(\\+\$+%+\#+|\\+\$+\#+%+|\\+%+\$+\#+|\\+%+\#+\$+|\\+\#+\$+%+|\\+\#+%+\$+|\$+\\+%+\#+|\$+\\+\#+%+|\$+%+\\+\#+|\$+%+\#+\\+|\$+\#+\\+%+|\$+\#+%+\\+|%+\\+\$+\#+|%+\\+\#+\$+|%+\$+\\+\#+|%+\$+\#+\\+|%+\#+\\+\$+|%+\#+\$+\\+|\#+\\+\$+%+|\#+\\+%+\$+|\#+\$+\\+%+|\#+\$+%+\\+|\#+%+\\+\$+|\#+%+\$+\\+)("""+)\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - match: '""|\$\$|%%|\#\#'
            name: constant.character.escape.ruko
          - include: '#embedded-expressions'
          - include: '#embedded-formatting'
          - include: '#embedded-arguments'
      - comment: single-quoted verbatim, interpolated, format, and template string
        begin: \s*(\\+\$+%+\#+|\\+\$+\#+%+|\\+%+\$+\#+|\\+%+\#+\$+|\\+\#+\$+%+|\\+\#+%+\$+|\$+\\+%+\#+|\$+\\+\#+%+|\$+%+\\+\#+|\$+%+\#+\\+|\$+\#+\\+%+|\$+\#+%+\\+|%+\\+\$+\#+|%+\\+\#+\$+|%+\$+\\+\#+|%+\$+\#+\\+|%+\#+\\+\$+|%+\#+\$+\\+|\#+\\+\$+%+|\#+\\+%+\$+|\#+\$+\\+%+|\#+\$+%+\\+|\#+%+\\+\$+|\#+%+\$+\\+)(')\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - match: '''''|\$\$|%%|\#\#'
            name: constant.character.escape.ruko
          - include: '#embedded-expressions'
          - include: '#embedded-formatting'
          - include: '#embedded-arguments'
      - comment: double-quoted verbatim, interpolated, format, and template string
        begin: \s*(\\+\$+%+\#+|\\+\$+\#+%+|\\+%+\$+\#+|\\+%+\#+\$+|\\+\#+\$+%+|\\+\#+%+\$+|\$+\\+%+\#+|\$+\\+\#+%+|\$+%+\\+\#+|\$+%+\#+\\+|\$+\#+\\+%+|\$+\#+%+\\+|%+\\+\$+\#+|%+\\+\#+\$+|%+\$+\\+\#+|%+\$+\#+\\+|%+\#+\\+\$+|%+\#+\$+\\+|\#+\\+\$+%+|\#+\\+%+\$+|\#+\$+\\+%+|\#+\$+%+\\+|\#+%+\\+\$+|\#+%+\$+\\+)(")\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - match: '""|\$\$|%%|\#\#'
            name: constant.character.escape.ruko
          - include: '#embedded-expressions'
          - include: '#embedded-formatting'
          - include: '#embedded-arguments'
      - comment: multi- single-quoted interpolated, format, and template string
        begin: \s*(\$+%+\#+|\$+\#+%+|%+\$+\#+|%+\#+\$+|\#+\$+%+|\#+%+\$+)('''+)\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expressions'
          - include: '#embedded-formatting'
          - include: '#embedded-arguments'
      - comment: multi- double-quoted interpolated, format, and template string
        begin: \s*(\$+%+\#+|\$+\#+%+|%+\$+\#+|%+\#+\$+|\#+\$+%+|\#+%+\$+)("""+)\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expressions'
          - include: '#embedded-formatting'
          - include: '#embedded-arguments'
      - comment: single-quoted interpolated, format, and template string
        begin: \s*(\$+%+\#+|\$+\#+%+|%+\$+\#+|%+\#+\$+|\#+\$+%+|\#+%+\$+)(')\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expressions'
          - include: '#embedded-formatting'
          - include: '#embedded-arguments'
      - comment: double-quoted interpolated, format, and template string
        begin: \s*(\$+%+\#+|\$+\#+%+|%+\$+\#+|%+\#+\$+|\#+\$+%+|\#+%+\$+)(")\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expressions'
          - include: '#embedded-formatting'
          - include: '#embedded-arguments'
      - comment: multi- single-quoted verbatim, interpolated, and format string
        begin: \s*(\\+\$+%+|\\+%+\$+|\$+\\+%+|\$+%+\\+|%+\\+\$+|%+\$+\\+)('''+)\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - match: '''''|\$\$|%%'
            name: constant.character.escape.ruko
          - include: '#embedded-expressions'
          - include: '#embedded-formatting'
      - comment: multi- double-quoted verbatim, interpolated, and format string
        begin: \s*(\\+\$+%+|\\+%+\$+|\$+\\+%+|\$+%+\\+|%+\\+\$+|%+\$+\\+)("""+)\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - match: '""|\$\$|%%'
            name: constant.character.escape.ruko
          - include: '#embedded-expressions'
          - include: '#embedded-formatting'
      - comment: single-quoted verbatim, interpolated, and format string
        begin: \s*(\\+\$+%+|\\+%+\$+|\$+\\+%+|\$+%+\\+|%+\\+\$+|%+\$+\\+)(')\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - match: '''''|\$\$|%%'
            name: constant.character.escape.ruko
          - include: '#embedded-expressions'
          - include: '#embedded-formatting'
      - comment: double-quoted verbatim, interpolated, and format string
        begin: \s*(\\+\$+%+|\\+%+\$+|\$+\\+%+|\$+%+\\+|%+\\+\$+|%+\$+\\+)(")\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - match: '""|\$\$|%%'
            name: constant.character.escape.ruko
          - include: '#embedded-expressions'
          - include: '#embedded-formatting'
      - comment: multi- single-quoted verbatim, interpolated, and template string
        begin: \s*(\\+\$+\#+|\\+\#+\$+|\$+\\+\#+|\$+\#+\\+|\#+\\+\$+|\#+\$+\\+)('''+)\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - match: '''''|\$\$|\#\#'
            name: constant.character.escape.ruko
          - include: '#embedded-expressions'
          - include: '#embedded-arguments'
      - comment: multi- double-quoted verbatim, interpolated, and template string
        begin: \s*(\\+\$+\#+|\\+\#+\$+|\$+\\+\#+|\$+\#+\\+|\#+\\+\$+|\#+\$+\\+)("""+)\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - match: '""|\$\$|\#\#'
            name: constant.character.escape.ruko
          - include: '#embedded-expressions'
          - include: '#embedded-arguments'
      - comment: single-quoted verbatim, interpolated, and template string
        begin: \s*(\\+\$+\#+|\\+\#+\$+|\$+\\+\#+|\$+\#+\\+|\#+\\+\$+|\#+\$+\\+)(')\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - match: '''''|\$\$|\#\#'
            name: constant.character.escape.ruko
          - include: '#embedded-expressions'
          - include: '#embedded-arguments'
      - comment: double-quoted verbatim, interpolated, and template string
        begin: \s*(\\+\$+\#+|\\+\#+\$+|\$+\\+\#+|\$+\#+\\+|\#+\\+\$+|\#+\$+\\+)(")\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - match: '""|\$\$|\#\#'
            name: constant.character.escape.ruko
          - include: '#embedded-expressions'
          - include: '#embedded-arguments'
      - comment: multi- single-quoted verbatim, format, and template string
        begin: \s*(\\+%+\#+|\\+\#+%+|%+\\+\#+|%+\#+\\+|\#+\\+%+|\#+%+\\+)('''+)\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - match: '''''|%%|\#\#'
            name: constant.character.escape.ruko
          - include: '#embedded-formatting'
          - include: '#embedded-arguments'
      - comment: multi- double-quoted verbatim, format, and template string
        begin: \s*(\\+%+\#+|\\+\#+%+|%+\\+\#+|%+\#+\\+|\#+\\+%+|\#+%+\\+)("""+)\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - match: '""|%%|\#\#'
            name: constant.character.escape.ruko
          - include: '#embedded-formatting'
          - include: '#embedded-arguments'
      - comment: single-quoted verbatim, format, and template string
        begin: \s*(\\+%+\#+|\\+\#+%+|%+\\+\#+|%+\#+\\+|\#+\\+%+|\#+%+\\+)(')\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - match: '''''|%%|\#\#'
            name: constant.character.escape.ruko
          - include: '#embedded-formatting'
          - include: '#embedded-arguments'
      - comment: double-quoted verbatim, format, and template string
        begin: \s*(\\+%+\#+|\\+\#+%+|%+\\+\#+|%+\#+\\+|\#+\\+%+|\#+%+\\+)(")\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - match: '""|%%|\#\#'
            name: constant.character.escape.ruko
          - include: '#embedded-formatting'
          - include: '#embedded-arguments'
      - comment: multi- single-quoted interpolated and format string
        begin: \s*(\$+%+|%+\$+)('''+)\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expressions'
          - include: '#embedded-formatting'
      - comment: multi- double-quoted interpolated and format string
        begin: \s*(\$+%+|%+\$+)("""+)\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expressions'
          - include: '#embedded-formatting'
      - comment: single-quoted interpolated and format string
        begin: \s*(\$+%+|%+\$+)(')\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expressions'
          - include: '#embedded-formatting'
      - comment: double-quoted interpolated and format string
        begin: \s*(\$+%+|%+\$+)(")\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expressions'
          - include: '#embedded-formatting'
      - comment: multi- single-quoted interpolated and template string
        begin: \s*(\$+\#+|\#+\$+)('''+)\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expressions'
          - include: '#embedded-arguments'
      - comment: multi- double-quoted interpolated and template string
        begin: \s*(\$+\#+|\#+\$+)("""+)\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expressions'
          - include: '#embedded-arguments'
      - comment: single-quoted interpolated and template string
        begin: \s*(\$+\#+|\#+\$+)(')\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expressions'
          - include: '#embedded-arguments'
      - comment: double-quoted interpolated and template string
        begin: \s*(\$+\#+|\#+\$+)(")\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expressions'
          - include: '#embedded-arguments'
      - comment: multi- single-quoted format and template string
        begin: \s*(%+\#+|\#+%+)('''+)\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-formatting'
          - include: '#embedded-arguments'
      - comment: multi- double-quoted format and template string
        begin: \s*(%+\#+|\#+%+)("""+)\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-formatting'
          - include: '#embedded-arguments'
      - comment: single-quoted format and template string
        begin: \s*(%+\#+|\#+%+)(')\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-formatting'
          - include: '#embedded-arguments'
      - comment: double-quoted format and template string
        begin: \s*(%+\#+|\#+%+)(")\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-formatting'
          - include: '#embedded-arguments'
      - comment: multi- single-quoted verbatim and interpolated string
        begin: \s*(\\+\$+|\$+\\+)('''+)\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - match: '''''|\$\$'
            name: constant.character.escape.ruko
          - include: '#embedded-expressions'
      - comment: multi- double-quoted verbatim and interpolated string
        begin: \s*(\\+\$+|\$+\\+)("""+)\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - match: '""|\$\$'
            name: constant.character.escape.ruko
          - include: '#embedded-expressions'
      - comment: single-quoted verbatim and interpolated string
        begin: \s*(\\+\$+|\$+\\+)(')\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - match: '''''|\$\$'
            name: constant.character.escape.ruko
          - include: '#embedded-expressions'
      - comment: double-quoted verbatim and interpolated string
        begin: \s*(\\+\$+|\$+\\+)(")\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - match: '""|\$\$'
            name: constant.character.escape.ruko
          - include: '#embedded-expressions'
      - comment: multi- single-quoted verbatim and format string
        begin: \s*(\\+%+|%+\\+)('''+)\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - match: "''|%%"
            name: constant.character.escape.ruko
          - include: '#embedded-formatting'
      - comment: multi- double-quoted verbatim and format string
        begin: \s*(\\+%+|%+\\+)("""+)\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - match: '""|%%'
            name: constant.character.escape.ruko
          - include: '#embedded-formatting'
      - comment: single-quoted verbatim and format string
        begin: \s*(\\+%+|%+\\+)(')\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - match: "''|%%"
            name: constant.character.escape.ruko
          - include: '#embedded-formatting'
      - comment: double-quoted verbatim and format string
        begin: \s*(\\+%+|%+\\+)(")\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - match: '""|%%'
            name: constant.character.escape.ruko
          - include: '#embedded-formatting'
      - comment: multi- single-quoted verbatim and template string
        begin: \s*(\\+\#+|\#+\\+)('''+)\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - match: '''''|\#\#'
            name: constant.character.escape.ruko
          - include: '#embedded-arguments'
      - comment: multi- double-quoted verbatim and template string
        begin: \s*(\\+\#+|\#+\\+)("""+)\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - match: '""|\#\#'
            name: constant.character.escape.ruko
          - include: '#embedded-arguments'
      - comment: single-quoted verbatim and template string
        begin: \s*(\\+\#+|\#+\\+)(')\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - match: '''''|\#\#'
            name: constant.character.escape.ruko
          - include: '#embedded-arguments'
      - comment: double-quoted verbatim and template string
        begin: \s*(\\+\#+|\#+\\+)(")\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - match: '""|\#\#'
            name: constant.character.escape.ruko
          - include: '#embedded-arguments'
      - comment: multi- single-quoted interpolated string
        begin: \s*(\$+)('''+)\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expressions'
      - comment: multi- double-quoted interpolated string
        begin: \s*(\$+)("""+)\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expressions'
      - comment: single-quoted interpolated string
        begin: \s*(\$+)(')\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expressions'
      - comment: double-quoted interpolated string
        begin: \s*(\$+)(")\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expressions'
      - comment: multi- single-quoted format string
        begin: \s*(%+)('''+)\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-formatting'
      - comment: multi- double-quoted format string
        begin: \s*(%+)("""+)\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-formatting'
      - comment: single-quoted format string
        begin: \s*(%+)(')\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-formatting'
      - comment: double-quoted format string
        begin: \s*(%+)(")\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-formatting'
      - comment: multi- single-quoted template string
        begin: \s*(\#+)('''+)\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-arguments'
      - comment: multi- double-quoted template string
        begin: \s*(\#+)("""+)\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-arguments'
      - comment: single-quoted template string
        begin: \s*(\#+)(')\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-arguments'
      - comment: double-quoted template string
        begin: \s*(\#+)(")\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-arguments'
      - comment: multi- single-quoted verbatim string
        begin: \s*(\\+)('''+)\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - match: "''"
            name: constant.character.escape.ruko
      - comment: multi- double-quoted verbatim string
        begin: \s*(\\+)("""+)\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - match: '""'
            name: constant.character.escape.ruko
      - comment: single-quoted verbatim string
        begin: \s*(\\+)(')\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - match: "''"
            name: constant.character.escape.ruko
      - comment: double-quoted verbatim string
        begin: \s*(\\+)(")\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - match: '""'
            name: constant.character.escape.ruko
      - comment: multi- single-quoted plain string
        begin: \s*()('''+)\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - include: '#string-escapes'
      - comment: multi- double-quoted plain string
        begin: \s*()("""+)\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - include: '#string-escapes'
      - comment: single-quoted plain string
        begin: \s*()(')\s*
        contentName: string.quoted.single.ruko
        end: \s*((\2)(?!'+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - include: '#string-escapes'
      - comment: double-quoted plain string
        begin: \s*()(")\s*
        contentName: string.quoted.double.ruko
        end: \s*((\2)(?!"+))
        captures:
          1: {name: storage.type.string.ruko}
          2: {name: punctuation.definition.string.ruko}
        patterns:
          - include: '#string-escapes'

  string-escapes:
    patterns:
      - begin: (\\)(?=\s*$)
        end: ^\s*(?=\S)
        captures:
          1: {name: constant.character.escape.newline.ruko}
      - include: '#unicode-escapes'
      - match: \\([cm][a-z])
        name: constant.character.control.ruko
      - match: \\[abefprnstv]
        name: constant.character.escape.ruko
      - include: '#named-escapes'
      - match: \\\p{S}
        name: constant.character.escape.symbol.ruko
      - match: \\\p{P}
        name: constant.character.escape.punctuation.ruko
      - match: \\[a-zA-Z\p{C}]
        name: invalid.illegal.escape.ruko
      - match: \\\s
        name: constant.character.escape.space.ruko
      - match: \\\p{L}
        name: constant.character.escape.letter.ruko
      - match: \\\p{N}
        name: constant.character.escape.number.ruko
      - match: \\.
        name: constant.character.escape.other.ruko

  named-characters:
    name: string.unquoted.plain.in.ruko
    comment: Grammar for the Unicode Named Character Mini-Language.
    patterns:
      - applyEndPatternLast: true
        name: constant.other.function.ruko
        begin: \b([\p{Pc}\p{L}]\w*\b([:.][\p{Pc}\p{L}]\w*)*)\b(?=\{)
        beginCaptures:
          1:
            patterns: [{include: '#function-namespace'}]
        end: (?=)|$
        patterns:
          - begin: (\{)
            end: (\})
            captures:
              1: {name: constant.other.function.ruko}
            patterns: [{include: '#named-characters'}]
      - match: \b([\p{Pc}\p{L}]\w*\b([:.][\p{Pc}\p{L}]\w*)*)\b([;,]|(?=\W))
        name: constant.character.escape.ruko
        captures:
          1:
            patterns: [{include: '#character-namespace'}]
      - include: '#xml-regex-content'
      - include: '#punctuation'
      - include: '#illegal'

  function-namespace:
    patterns:
      - match: ([\p{Pc}\p{L}]\w*)\b(?=[.:])
        name: support entity.name.tag.namespace.ruko
      - match: ([\p{Pc}\p{L}]\w*)\b
        name: support entity.name.function.member.ruko

  character-namespace:
    patterns:
      - match: ([\p{Pc}\p{L}]\w*)\b(?=[.:])
        name: constant.other.character-class.ruko
      - match: ([\p{Pc}\p{L}]\w*)\b
        name: constant.character.escape.unicode.ruko

  named-escapes:
    patterns:
      - applyEndPatternLast: true
        name: constant.other.function.ruko
        begin: \\j([\p{Pc}\p{L}]\w*\b([:.][\p{Pc}\p{L}]\w*)*)\b(?=\{)
        beginCaptures:
          1:
            patterns: [{include: '#function-namespace'}]
        end: (?=)|$
        patterns:
          - begin: (\{)
            end: (\})
            captures:
              1: {name: constant.other.function.ruko}
            patterns: [{include: '#named-characters'}]
      - match: \\j([\p{Pc}\p{L}]\w*\b([:.][\p{Pc}\p{L}]\w*)*)\b([;,]|(?=\W))
        name: constant.character.escape.ruko
        captures:
          1:
            patterns: [{include: '#character-namespace'}]
      - begin: \\j{\s*
        end: \s*}
        name: constant.other.character-class.unicode.ruko
        patterns:
          - applyEndPatternLast: true
            name: constant.other.function.ruko
            begin: \b([\p{Pc}\p{L}]\w*\b([:.][\p{Pc}\p{L}]\w*)*)\b(?=\{)
            beginCaptures:
              1:
                patterns: [{include: '#function-namespace'}]
            end: (?=)|$
            patterns:
              - begin: (\{)
                end: (\})
                captures:
                  1: {name: constant.other.function.ruko}
                patterns: [{include: '#named-characters'}]
          - match: \b([\p{Pc}\p{L}]\w*\b([:.][\p{Pc}\p{L}]\w*)*)\b([;,]|(?=\W))
            name: constant.character.escape.ruko
            captures:
              1:
                patterns: [{include: '#character-namespace'}]
          - include: '#xml-regex-content'
          - include: '#punctuation'
          - include: '#illegal'

  unicode-escapes:
    patterns:
      - comment: standard \x escapes
        match: \\x[0-7]\h
        name: constant.character.escape.ascii.ruko
      - comment: Low surrogate pairs U+DC00-DFFF
        match: \\u[dD][c-fC-F]\h{2}
        name: constant.character.escape.surrogate-low.ruko
      - comment: High surrogate pairs U+D800-DBFF
        match: \\u[dD][89abAB]\h{2}
        name: constant.character.escape.surrogate-high.ruko
      - comment: UTF-8 continuation byte escape
        match: \\x[89abAB]\h
        name: constant.character.escape.continuation.ruko
      - comment: UTF-8 2-byte sequence lead byte escape
        match: \\x[cdCD]\h
        name: constant.character.escape.lead.two.ruko
      - comment: UTF-8 3-byte sequence lead byte escape
        match: \\x[eE]\h
        name: constant.character.escape.lead.three.ruko
      - comment: UTF-8 4-byte sequence lead byte escape
        match: \\x[fF][0-4]
        name: constant.character.escape.lead.four.ruko
      - comment: Unused/illegal UTF-8 byte escapes
        match: \\x\h{2}
        name: invalid.illegal.escape.utf8.ruko
      - comment: Hexadecimal escape sequences
        match: \\u\h{4}
        name: constant.character.escape.unicode.ruko
      - comment: UTF-32 escape sequences
        match: \\U0*(10\h{6}|\h{1,5})
        name: constant.character.escape.astral.ruko
      - comment: Binary escape sequences
        match: \\b0*(10000[0-1]{16}|1[01]{0,19}|0)
        name: constant.character.escape.binary.ruko
      - comment: Octal escape sequences
        match: \\o0*(41[0-7]{5}|[1-3][0-7]{6}|[1-7][0-7]{0,5}|0)
        name: constant.character.escape.octal.ruko
      - comment: Decimal escape sequences
        match: \\0*(111411[10]|111410\d|11140\d{2}|111[0-3]\d{3}|110\d{4}|10\d{5}|[1-9]\d{0,5}|0)
        name: constant.character.escape.numeric.ruko
      - comment: Quaternary escape sequences
        match: \\q0*(1003{8}|100[0-2]{10}|10[0-3]{12}|[1-3][0-3]{0,18}|0)
        name: constant.character.escape.quaternary.ruko

  # Embedded expressions

  embedded:
    patterns:
      - include: '#embedded-expressions'
      - include: '#embedded-formatting'
      - include: '#embedded-arguments'

  embedded-verbatim:
    patterns:
      - match: \#\#|\$\$|\%\%
        name: constant.character.escape.ruko
      - include: '#embedded-expressions'
      - include: '#embedded-formatting'
      - include: '#embedded-arguments'

  embedded-expressions:
    patterns:
      - comment: Interpolated expression
        begin: (\${)\s*
        end: \s*(\})
        name: meta.embedded.expression.ruko
        captures:
          1: {name: punctuation.definition.variable.ruko}
        patterns: [{include: $self}]
      - comment: Interpolated expression
        applyEndPatternLast: true
        name: meta.embedded.expression.ruko
        begin: |
          (?x)
          (\$) # beginning of identifier
          # ignore all keywords
          (?!
            (?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b
            (?: # keywords
              [io]n|of|[ai]s|by|has|old|new|del
              |unset|ref|deref|and|x?or|not
              |const|let|mut|dyn|va[rl]|use
              |given|expr|eval|init|comp
              |func|pro[pc]|type|class|actor|trait
              |impl|enum|module|model|struct|record
              |union|iter|macro|query|elem|temp|oper
              |object|realm|style|script|quote
              |go|defer|do|with|from|where
              |if|else|then|guard|when
              |for|loop|while|goto|move
              |try|throw|catch|switch
              |match|case|pass|def|defer
              |break|skip|redo|retry
              |return|yield|await|scope
              |import|export|intern|extern
              |debug|assert|check|decl
            )
            \b
          )
          (?=[\p{Pc}\p{L}]) # next to a word
        end: (?=)|$
        captures:
          1: {name: punctuation.definition.variable.ruko}
        patterns:
          - include: '#constants'
          - include: '#generics'
          - include: '#brackets'
          - include: '#embedded-function-calls'
          - match: (?<=>|\w)(!)(?=\#?[({])
            captures:
              1: {name: keyword.operator.macro.ruko}
          - match: (?<=>|\w)(~)(?=\#?[({])
            captures:
              1: {name: keyword.operator.destructor.ruko}
          - include: '#variables'
          - include: '#numbers'
          - *qualified-name-separators

  embedded-arguments:
    patterns:
      - name: meta.embedded.placeholder.ruko
        match: |
          (?x)
          (\#) # sigil
          (
            (?:
              (?:&|%|\$|~~?|\*\*?)? # sigil
              [?!]? # required or optional
            )?
            [+-]? \d+ # start of range
            (?:
              (?:[>.]\.[.<]|\.\.|[=.]\.[.=]|\.\.=?|=\.=) # range operator
              [+-]? \d+ # end of range
              (?:
                \.{1,3}
                [+-]? \d+ # increment
              )?
            )?
          )
        captures:
          1: {name: punctuation.definition.anchor.ruko}
          2:
            name: constant.numeric.decimal.ruko
            patterns:
              - match: '[+-]'
                name: keyword.operator.arithmetic.ruko
              - match: (?:[>.]\.[.<]|\.\.|[=.]\.[.=]|\.\.=?|=\.=)
                name: keyword.operator.range.ruko
      - name: meta.embedded.placeholder.ruko
        match: |
          (?x)
          (\#) # sigil
          (?:
            \s*
            ((?:[*&%@^!~?\\\-+]|\.{3})*) # any sigils
            ( # identifier
              (?: # function name
                \b
                # ignore all keywords
                (?!
                  (?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b
                  (?: # keywords
                    [io]n|of|[ai]s|by|has|old|new|del
                    |unset|ref|deref|and|x?or|not
                    |const|let|mut|dyn|va[rl]|use
                    |given|expr|eval|init|comp
                    |func|pro[pc]|type|class|actor|trait
                    |impl|enum|module|model|struct|record
                    |union|iter|macro|query|elem|temp|oper
                    |object|realm|style|script|quote
                    |go|defer|do|with|from|where
                    |if|else|then|guard|when
                    |for|loop|while|goto|move
                    |try|throw|catch|switch
                    |match|case|pass|def|defer
                    |break|skip|redo|retry
                    |return|yield|await|scope
                    |import|export|intern|extern
                    |debug|assert|check|decl
                  )
                  \b
                )
                \b
                [\p{Pc}\p{L}]\w* # identifier
                \b
              )
            )
            ([!?]*) # optional sigils
            \s*
          )
        captures:
          1: {name: punctuation.definition.anchor.ruko}
          2:
            name: keyword.operator.prefix.ruko
            patterns: [{include: '#parameter-type-operators'}]
          3:
            name: variable.parameter.ruko
            patterns: [{include: '#constants'}]
          4:
            name: keyword.operator.suffix.ruko
            patterns: [{include: '#parameter-type-operators'}]
      - name: meta.embedded.placeholder.ruko
        begin: (\#{)\s*
        end: \s*(\})
        captures:
          1: {name: punctuation.definition.anchor.ruko}
        patterns:
          - include: '#parameter-variables'
          - include: $self

  # Format and flag specifiers

  embedded-formatting:
    comment: Oniguruma supports only 20 levels of recursion
    applyEndPatternLast: true
    name: meta.embedded.formatting.ruko
    begin: (?<!%)(%)(?=[\p{Pc}\p{L}])
    end: (?=)|$
    captures:
      1: {name: punctuation.definition.directive.ruko}
    patterns: [{include: '#format-syntax'}]

  format-syntax:
    comment: Format specifier language, inspired by MS-DOS, Bash and Python's f-strings.
    patterns:
      - comment: with optional value
        applyEndPatternLast: true
        begin: (?:(?<=%)|(\|))([\p{Pc}\p{L}]\w*)\b(:)
        end: (?=)|$
        name: storage.type.format.ruko
        captures:
          1: {name: punctuation.separator.mapping.ruko}
          2: {name: storage.type.format.ruko}
          3: {name: punctuation.separator.key-value.ruko}
        patterns:
          - include: '#constants'
          - include: '#generics'
          - include: '#brackets'
          - include: '#embedded-function-calls'
          - match: (?<=>|\w)(!)(?=\#?[({])
            captures:
              1: {name: keyword.operator.macro.ruko}
          - match: (?<=>|\w)(~)(?=\#?[({])
            captures:
              1: {name: keyword.operator.destructor.ruko}
          - include: '#variables'
          - include: '#numbers'
          - include: '#regexps'
          - include: '#symbols'
          - *qualified-name-separators
      - comment: type specifier
        match: (?:(?<=%)|(\|))([\p{Pc}\p{L}]\w*)\b
        name: storage.type.format.ruko
        captures:
          1: {name: punctuation.separator.mapping.ruko}
          2: {name: storage.type.format.ruko}
      - comment: // for multiple flags at once with single-character aliases
        match: (?:(?<=%)|(//))([\p{Pc}\p{L}]\w*)\b
        name: storage.type.format.ruko
        captures:
          1: {name: punctuation.definition.flag.ruko}
          2: {name: storage.type.format.ruko}
      - comment: / for a single flag, with optional arguments
        match: (?:(?<=%)|(/))([\p{Pc}\p{L}]\w*)\b
        name: storage.type.format.ruko
        captures:
          1: {name: punctuation.definition.flag.ruko}
          2: {name: storage.type.format.ruko}
      - include: '#format-switch-clause'

  format-switch-clause:
    patterns:
      - comment: // for multiple flags at once with single-character aliases
        applyEndPatternLast: true
        begin: (?:(?<=%)|(//))([\p{Pc}\p{L}]\w*)\b
        end: (?=)|$
        captures:
          1: {name: punctuation.definition.flag.ruko}
          2: {name: storage.type.format.ruko}
        patterns:
          - comment: Format switch without value
            match: ([\p{Pc}\p{L}]\w*)
            captures:
              1: {name: keyword.other.flag.ruko}
      - comment: / for a single flag, with optional arguments
        applyEndPatternLast: true
        begin: (?:(?<=%)|(/))([\p{Pc}\p{L}]\w*)\b
        end: (?=)|$
        captures:
          1: {name: punctuation.definition.flag.ruko}
          2: {name: storage.type.format.ruko}
        patterns:
          - comment: Format switch without value
            match: ([\p{Pc}\p{L}]\w*)
            captures:
              1: {name: keyword.modifier.ruko}

  # Regular expressions

  regexps:
    applyEndPatternLast: true
    begin: |
      (?x)
      (?<=
        (?:
            # beginning of line
            ^
          | # separator
            [,;]
          | # opening bracket
            \#? [({\[]
          | # postfix or infix operator
            [\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]+ \s
          | # a keyword
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            [\p{Pc}\p{L}]\w*  # keyword or identifier
        ) \s*
      ) \s*
      (?=/(?:$|[^\s/]))
    end: (?=)|$
    name: meta.regexp.ruko
    patterns:
      - applyEndPatternLast: true
        comment: Single-line pattern section
        begin: (/)(?!/)\s*
        end: \s*(/)(\p{L}*)
        contentName: string.regexp.pattern.ruko
        captures:
          1: {name: punctuation.definition.regexp.ruko}
          2: {name: keyword.other.flag.ruko}
        patterns:
          - include: '#regexp-patterns'
          - comment: Single-line replacement section
            begin: (:)\s*
            end: \s*(\|)|\s*(?=/)
            name: string.regexp.replace.ruko
            captures:
              1: {name: punctuation.definition.regexp.ruko}
            patterns:
              - include: '#back-references'
              - include: '#xml-regex-content'

  fuzzy-expression:
    patterns:
      - include: '#punctuation'
      - include: '#comments'
      - include: '#function-calls'
      - include: '#literals'
      - include: '#embedded'
      - include: '#operators'
      - include: '#clauses'
      - include: '#declarations'
      - include: '#keywords'
      - include: '#fuzzy-brackets'
      - match: \b[\p{Pc}\p{L}]\w*\b
        name: keyword.other.unit.ruko
      - include: '#space'

  fuzzy-brackets:
    patterns:
      - begin: (\{)\s*
        end: \s*(\})
        captures:
          1: {name: punctuation.definition.mapping.ruko}
        patterns:
          - match: ','
            name: punctuation.separator.mapping.ruko
          - include: '#labels'
          - include: '#fuzzy-expression'
          - include: $self
      - begin: (\[)\s*
        end: \s*(\])
        captures:
          1: {name: punctuation.definition.array.ruko}
        patterns:
          - match: ','
            name: punctuation.separator.sequence.ruko
          - include: '#fuzzy-expression'
          - include: $self
      - begin: (\()\s*
        end: \s*(\))
        captures:
          1: {name: punctuation.definition.expression.ruko}
        patterns:
          - match: ','
            name: punctuation.separator.arguments.ruko
          - include: '#fuzzy-expression'
          - include: $self

  back-references:
    patterns:
      - match: \$(\d+[+-]?|[+-]\d*)
        name: keyword.other.back-reference.ruko
      - begin: (\$<)\s*
        end: \s*(>)
        name: keyword.other.back-reference.ruko
        captures:
          1: {name: keyword.other.back-reference.ruko}
        patterns: &regex-back-references
          - include: '#variables'
          - include: '#numbers'
          - include: '#operators'
          - include: '#xml-regex-content'
      - begin: (\$(['"]))\s*
        end: \s*(\2)
        name: keyword.other.back-reference.ruko
        captures:
          1: {name: keyword.other.back-reference.ruko}
        patterns: *regex-back-references

  regexp-patterns:
    comment: |
      See https://gist.github.com/CMCDragonkai/6c933f4a7d713ef712145c5eb94a1816
      and https://www.regular-expressions.info/
    patterns:
      - include: '#comments'
      - include: '#embedded'
      - include: '#strings'
      - include: '#unicode-escapes'
      - match: \|
        name: keyword.operator.or.ruko
      - match: \&
        name: keyword.operator.composition.ruko
      - match: \.
        name: constant.character.all.ruko
      - match: (?i)\\[by](?:{(?:[^\\{}]|\\.)+})?
        name: keyword.control.anchor.ruko
      - match: (\\[aAm<]|\^+)(?:{(?:[^\\{}]|\\.)+})?
        name: keyword.control.begin.ruko
      - match: (\\[zZM>]|\$+)(?:{(?:[^\\{}]|\\.)+})?
        name: keyword.control.end.ruko
      - match: \\K
        name: keyword.control.keep-out.ruko
      - match: \\G
        name: keyword.control.search.ruko
      - match: \\R
        name: constant.character.control.ruko
      - match: \\[XO]
        name: constant.character.unicode.ruko
      - match: \\\d+
        name: keyword.other.back-reference.ruko
      - match: \{\s*(?:\d*\s*,){,2}\s*\d*\s*}\s*(?:(\?)|(\+)|(\*))?
        captures:
          0: {name: keyword.operator.quantifier.ruko}
          1: {name: keyword.operator.modifier.lazy.ruko}
          2: {name: keyword.operator.modifier.eager.ruko}
          3: {name: keyword.operator.modifier.greedy.ruko}
      - match: (?:(\?)|(\+)|(\*))\s*(?:(\?)|(\+)|(\*))?
        captures:
          1: {name: keyword.operator.quantifier.lazy.ruko}
          2: {name: keyword.operator.quantifier.eager.ruko}
          3: {name: keyword.operator.quantifier.greedy.ruko}
          4: {name: keyword.operator.modifier.lazy.ruko}
          5: {name: keyword.operator.modifier.eager.ruko}
          6: {name: keyword.operator.modifier.greedy.ruko}
      - begin: (\\k<)
        end: \s*(>)
        name: constant.other.back-reference.ruko
        captures:
          1: {name: keyword.other.back-reference.ruko}
        patterns: *regex-back-references
      - begin: (\\g<)
        end: \s*(>)
        name: constant.other.subroutine.ruko
        captures:
          1: {name: keyword.other.subroutine.ruko}
        patterns: *regex-back-references
      - begin: (\\k('''+|"""+|['"]))
        end: \s*(\2)
        name: constant.other.back-reference.ruko
        captures:
          1: {name: keyword.other.back-reference.ruko}
        patterns: *regex-back-references
      - begin: (\\g('''+|"""+|['"]))
        end: \s*(\2)
        name: constant.other.subroutine.ruko
        captures:
          1: {name: keyword.other.subroutine.ruko}
        patterns: *regex-back-references
      - begin: (\{)
        end: \s*(\})
        name: meta.fuzzy.ruko
        captures:
          1: {name: punctuation.definition.fuzzy.ruko}
        patterns:
          - applyEndPatternLast: true
            begin: (?<=^|\\.|[,;'"`({\[)}\]\w\s])(:)
            beginCaptures:
              1: {name: punctuation.separator.key-value.ruko}
            end: (?=[,;}]|)|$
            patterns: [{include: '#regexp-patterns'}]
          - include: '#fuzzy-expression'
      - match: \\[abefrntv]
        name: constant.character.escape.ruko
      - match: \\[wsdhulqmji]
        name: constant.other.character-class.ruko
      - match: \\[WSDHULQMJI]
        name: constant.other.character-class.negated.ruko
      - include: '#regexp-groups'
      - include: '#regexp-character-set'
      - include: '#regexp-character-class'
      - include: '#space'

  regexp-groups:
    patterns:
      - comment: Backtracking control verb
        begin: (\(\*([\p{Pc}\p{L}]\w*)?(:)?)
        end: \s*(\))
        name: meta.group.backtrack.ruko
        captures:
          1: {name: punctuation.section.expression.ruko}
          2: {name: keyword.control.ruko}
          3: {name: punctuation.separator.colon.ruko}
        patterns: [{include: '#regexp-patterns'}]
      - comment: Block comment
        begin: (\()(\?#)
        contentName: comment.block.regexp.ruko
        end: \s*(\))
        name: comment.block.regexp.ruko
        captures:
          1: {name: punctuation.definition.comment.ruko}
        patterns:
          - match: \\.
            name: comment.block.regexp.ruko
      - comment: Lookahead assertion
        begin: (\(\?=)
        end: \s*(\))
        name: meta.group.look-ahead.ruko
        captures:
          1: {name: punctuation.definition.group.look-ahead.ruko}
        patterns: [{include: '#regexp-patterns'}]
      - comment: Lookbehind assertion
        begin: (\(\?<=)
        end: \s*(\))
        name: meta.group.look-behind.ruko
        captures:
          1: {name: punctuation.definition.group.look-behind.ruko}
        patterns: [{include: '#regexp-patterns'}]
      - comment: Negative lookahead assertion
        begin: (\(\?!)
        end: \s*(\))
        name: meta.group.negative-look-ahead.ruko
        captures:
          1: {name: punctuation.definition.group.negative-look-ahead.ruko}
        patterns: [{include: '#regexp-patterns'}]
      - comment: Negative lookbehind assertion
        begin: (\(\?<!)
        end: \s*(\))
        name: meta.group.negative-look-behind.ruko
        captures:
          1: {name: punctuation.definition.group.negative-look-behind.ruko}
        patterns: [{include: '#regexp-patterns'}]
      - comment: Match directive Oniguruma supports only 20 levels of recursion
        begin: (?x)(\(\?)(?=%)
        captures:
          1: {name: punctuation.definition.group.directive.ruko}
        end: \s*(\))
        name: meta.group.directive.ruko
        patterns:
          - include: '#format-syntax'
          - include: '#regexp-patterns'
      - comment: Longest match
        begin: (\(\?/=?)
        end: \s*(\))
        name: meta.group.longest.ruko
        captures:
          1: {name: punctuation.definition.group.longest.ruko}
        patterns: [{include: '#regexp-patterns'}]
      - comment: Back-reference groups
        begin: \((\?&(?:([+-]?\d+)|([\p{Pc}\p{L}]\w*)))(:)?
        end: \s*\)
        name: meta.group.back-reference.ruko
        captures:
          0: {name: punctuation.definition.group.back-reference.ruko}
          1: {name: punctuation.definition.group.back-reference.ruko}
          2: {name: constant.numeric.index.ruko}
          3: {patterns: [{include: '#variables'}]}
          4: {name: punctuation.separator.colon.ruko}
        patterns: [{include: '#regexp-patterns'}]
      - comment: Back-reference groups
        begin: \((\?&)
        end: \s*\)
        name: meta.group.back-reference.ruko
        captures:
          0: {name: punctuation.definition.group.back-reference.ruko}
          1: {name: punctuation.definition.group.back-reference.ruko}
        patterns:
          - begin: (?<=\(\?&)('''+|"""+|['"])
            end: \s*(\1)
            name: constant.other.group.ruko
            captures:
              1: {name: punctuation.definition.group.back-reference.ruko}
            patterns: *regex-back-references
          - include: '#regexp-patterns'
      - comment: Flag modifier group
        begin: (\(\?\^?(?:([+-]?\d+?)|((?:[+-]\p{Lu}+)+|\p{Lu}+(?:[+-]\p{Lu}+)*)|((?:[+-]\p{Ll}+)+|\p{Ll}+(?:[+-]\p{Ll}+)*)))\s*(:)?
        end: \s*(\))
        name: meta.group.flag.ruko
        captures:
          0: {name: punctuation.definition.group.flag.ruko}
          1: {name: punctuation.definition.group.flag.ruko}
          2: {name: constant.numeric.index.ruko}
          3: {name: keyword.control.recursion.ruko}
          4: {name: keyword.other.flag.ruko}
          5: {name: punctuation.separator.colon.ruko}
        patterns: [{include: '#regexp-patterns'}]
      - comment: Call-outs
        begin: (\(\?)(?={)
        end: \s*(\))
        name: meta.group.call-out.ruko
        captures:
          1: {name: punctuation.definition.group.call-out.ruko}
        patterns:
          - begin: (?<=\(\?)(\{)
            end: \s*(\})\s*([<*>])?(?:(\[)(.*?)(\]))?
            name: punctuation.definition.group.call-out.ruko
            captures:
              1: {name: punctuation.definition.group.call-out.ruko}
              2: {name: keyword.operator.range.ruko}
              3: {name: punctuation.definition.tag.ruko}
              4: {patterns: [{include: '#function-names'}]}
              5: {name: punctuation.definition.tag.ruko}
            patterns: [{include: $self}]
          - include: '#regexp-patterns'
      - comment: Atomic groups
        begin: (\(\?>)
        end: \s*(\))
        name: meta.group.atomic.ruko
        captures:
          1: {name: punctuation.definition.group.atomic.ruko}
        patterns: [{include: '#regexp-patterns'}]
      - comment: Non-capturing groups
        begin: (\(\?:)
        end: \s*(\))
        name: meta.group.non-capturing.ruko
        captures:
          1: {name: punctuation.definition.group.non-capturing.ruko}
        patterns: [{include: '#regexp-patterns'}]
      - comment: Branch groups
        begin: (\(\?)(?=[(|])
        end: \s*(\))
        name: meta.group.branch.ruko
        captures:
          1: {name: punctuation.definition.group.branch.ruko}
        patterns: [{include: '#regexp-patterns'}]
      - comment: Absent groups
        begin: (\(\?~)
        end: \s*(\))
        name: meta.group.absent.ruko
        captures:
          1: {name: punctuation.definition.group.absent.ruko}
        patterns: [{include: '#regexp-patterns'}]
      - comment: Named groups (angle brackets)
        begin: \(\?(?=<(?![!=]))
        end: \s*(\))
        name: meta.group.named.ruko
        captures:
          0: {name: punctuation.definition.group.named.ruko}
        patterns:
          - begin: (?<=\(\?)(<)
            end: \s*(>)
            name: constant.other.group.ruko
            captures:
              1: {name: punctuation.definition.group.named.ruko}
            patterns: *regex-back-references
          - include: '#regexp-patterns'
      - comment: Named groups (single or double-quotes)
        begin: \(\?(?=['"])
        end: \s*(\))
        name: meta.group.named.ruko
        captures:
          0: {name: punctuation.definition.group.named.ruko}
        patterns:
          - begin: (?<=\(\?)('''+|"""+|['"])
            end: \s*(\1)
            name: constant.other.group.ruko
            captures:
              1: {name: punctuation.definition.group.named.ruko}
            patterns: *regex-back-references
          - include: '#regexp-patterns'
      - comment: Unnamed groups
        begin: (\()
        end: (\s*\))
        name: meta.group.ruko
        captures:
          1: {name: punctuation.definition.group.ruko}
        patterns: [{include: '#regexp-patterns'}]

  regexp-character-class:
    patterns:
      - include: '#embedded'
      - begin: (\\)(?=\s*$)
        end: ^\s*(?=\S)
        captures:
          1: {name: constant.character.escape.newline.ruko}
      - include: '#named-escapes'
      - include: '#unicode-escapes'
      - begin: (?i)\\p{
        end: \s*}
        name: constant.other.character-class.unicode.ruko
        patterns: [{include: '#attribute-selectors'}]
      - match: (?i)\\([cm][a-z])
        name: constant.character.control.ruko
      - match: (?i)\\p[a-z]{1,2}
        name: constant.other.character-class.unicode.ruko
      - match: (?i)\\[ci]({\w+})?
        name: constant.other.character-class.xml.ruko
      - match: (?i)\\n{(?:[^\\{}]|\\.)+}
        name: constant.character.escape.unicode.name.ruko
      - match: \\[abefprntv]
        name: constant.character.escape.ruko
      - match: \\[a-z]
        name: constant.other.character-class.ruko
      - match: \\[A-Z]
        name: constant.other.character-class.negated.ruko
      - match: \\\p{S}
        name: constant.character.escape.symbol.ruko
      - match: \\\p{P}
        name: constant.character.escape.punctuation.ruko
      - match: \\[a-zA-Z\p{C}]
        name: invalid.illegal.escape.ruko
      - match: \\\s
        name: constant.character.escape.space.ruko
      - match: \\\p{L}
        name: constant.character.escape.letter.ruko
      - match: \\\p{N}
        name: constant.character.escape.number.ruko
      - match: \\.
        name: constant.character.escape.other.ruko

  regexp-character-operators:
    patterns:
      - match: |
          (?x)
          ( # from
              \\0*(?:111411[10]|111410\d|11140\d{2}|111[0-3]\d{3}|110\d{4}|10\d{5}|[1-9]\d{0,5}|0) # decimal escape
            | \\o0*(?:41[0-7]{5}|[1-3][0-7]{6}|[1-7][0-7]{0,5}|0) # octal escape
            | \\b0*(?:10000[0-1]{16}|1[01]{0,19}|0) # binary escape
            | \\q0*(?:1003{8}|100[0-2]{10}|10[0-3]{12}|[1-3][0-3]{0,18}|0) # quaternary escape
            | \\x\h\h # hex escape (2-digit)
            | \\u\h{4} # hex escape (4-digit)
            | \\U0*(?:10\h{6}|\h{1,5}) # hex escape (variable-length)
            | \\[cm][a-z] # meta-character
            | \\j{(?:[^\\{}]|\\.)+} # Unicode named character
            | \\(?:[abefprntv]|[^a-zA-Z]) # any escape character
            | [^\-\\\[\]] # any unescaped character
          )
            \s*(>?->?)\s* # range
          ( # to
              \\0*(?:111411[10]|111410\d|11140\d{2}|111[0-3]\d{3}|110\d{4}|10\d{5}|[1-9]\d{0,5}|0) # decimal escape
            | \\o0*(?:41[0-7]{5}|[1-3][0-7]{6}|[1-7][0-7]{0,5}|0) # octal escape
            | \\b0*(?:10000[0-1]{16}|1[01]{0,19}|0) # binary escape
            | \\q0*(?:1003{8}|100[0-2]{10}|10[0-3]{12}|[1-3][0-3]{0,18}|0) # quaternary escape
            | \\x\h\h # hex escape (2-digit)
            | \\u\h{4} # hex escape (4-digit)
            | \\U0*(?:10\h{6}|\h{1,5}) # hex escape (variable-length)
            | \\[cm][a-z] # meta-character
            | \\j{(?:[^\\{}]|\\.)+} # Unicode named character
            | \\(?:[abefprntv]|[^a-zA-Z]) # any escape character
            | [^\-\\\[\]] # any unescaped character
          ) (?:
              \s*(:)\s*
            ( # by
                -?0*(?:111411[10]|111410\d|11140\d{2}|111[0-3]\d{3}|110\d{4}|10\d{5}|[1-9]\d{0,5}|0) # decimal
              | -?0o0*(?:41[0-7]{5}|[1-3][0-7]{6}|[1-7][0-7]{0,5}|0) # octal
              | -?0b0*(?:10000[0-1]{16}|1[01]{0,19}|0) # binary
              | -?0x(?:10\h{6}|\h{1,5}) # hexadecimal
            )
          )?
        captures:
          1:
            name: constant.other.character-class.range.from.ruko
            patterns:
              - include: '#regexp-character-class'
              - include: '#regexp-character-operators'
          2: {name: keyword.operator.range.ruko}
          3:
            name: constant.other.character-class.range.to.ruko
            patterns:
              - include: '#regexp-character-class'
              - include: '#regexp-character-operators'
          4: {name: keyword.operator.range.ruko}
          5:
            name: constant.other.character-class.range.by.ruko
            patterns:
              - include: '#numbers'
              - include: '#regexp-character-class'
              - include: '#regexp-character-operators'
      - match: (\|\|)|(&&)|(\^\^)|(--)
        name: keyword.operator.set.ruko
        captures:
          1: {name: keyword.operator.union.ruko}
          2: {name: keyword.operator.intersection.ruko}
          3: {name: keyword.operator.exclusion.ruko}
          4: {name: keyword.operator.difference.ruko}

  regexp-character-set:
    patterns:
      - begin: (\[:)
        end: \s*(:\])
        name: constant.other.character-set.posix.ruko
        captures:
          1: {name: punctuation.definition.character-class.posix.ruko}
        patterns:
          - include: '#attribute-selectors'
      - begin: (\[\^)
        end: \s*(\])
        name: constant.other.character-set.negated.ruko
        captures:
          1: {name: punctuation.definition.character-class.negated.ruko}
        patterns:
          - include: '#comments'
          - include: '#regexp-character-operators'
          - include: '#regexp-character-class'
          - include: '#regexp-character-set'
      - begin: (\[)
        end: \s*(\])
        name: constant.other.character-set.ruko
        captures:
          1: {name: punctuation.definition.character-class.ruko}
        patterns:
          - include: '#comments'
          - include: '#regexp-character-operators'
          - include: '#regexp-character-class'
          - include: '#regexp-character-set'

  attribute-selectors:
    name: meta.attribute-selector.ruko
    patterns:
      - match: '[:!=</>.^$%?*+|&~]?='
        name: keyword.operator.pattern.ruko
      - match: \&\&|\|\||\^\^|\!
        name: keyword.operator.logical.ruko
      - match: ','
        name: punctuation.separator.sequence.ruko
      - match: \b(is\s+not|is|has\s+not|has|has\s+not|has)\b
        name: keyword.operator.expression.is.ruko
      - match: \b(not\s+)?([io]n|of)\b
        name: keyword.operator.expression.$2.ruko
      - begin: \b([\p{Pc}\p{L}]\w*)\b([:!=</>.^$%?*+|&~]?=)
        beginCaptures:
          1: {name: entity.other.attribute-name.key.ruko}
          2: {name: keyword.operator.pattern.ruko}
        end: (?=\&\&|\|\||\^\^|[\s,:;'"`)}\]]|\\.)
        name: string.unquoted.attribute-name.ruko
        patterns: [{include: '#regexp-patterns'}]
      - match: (?xi)\b[is]\b\s*(?=[)}\]]|([&|^])\1)
        name: storage.modifier.ignore-when.ruko
      - include: '#string-escapes'
      - comment: Attribute names
        match: \b([\p{Pc}\p{L}]\w*)\b
        captures:
          1: {name: entity.other.attribute-name.ruko}
          2: {name: keyword.operator.pattern.ruko}
      - include: '#comments'
      - include: '#operators'

  # Splicing

  splice-brackets:
    patterns:
      - begin: \s*(<\{)
        end: (\}>)
        name: meta.splicing.ruko
        captures:
          1: {name: punctuation.definition.splice.ruko}
          2: {name: punctuation.definition.splice.ruko}
        patterns: [{include: $self}]
      - begin: \s*(<\[)
        end: (\]>)
        name: meta.splicing.ruko
        captures:
          1: {name: punctuation.definition.splice.ruko}
          2: {name: punctuation.definition.splice.ruko}
        patterns: [{include: $self}]

  # XML (JSX) and Markdown

  xml:
    applyEndPatternLast: true
    comment: Only captured when next to opening brackets, commas,
      semicolons, keywords, and operators.
      XML also supports functional components.
    begin: |
      (?x)
      (?<=
        (?:
            # beginning of line
            ^
          | # separator
            [,;]
          | # opening bracket
            \#? [({\[]
          | # postfix or infix operator
            [\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]+ \s
          | # a keyword
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            [\p{Pc}\p{L}]\w*  # keyword or identifier
        ) \s*
      ) \s*
      (?=<[>\p{Pc}\p{L}(])
    end: (?=)|$
    patterns:
      - include: '#tag-component-name'

  tag-component-name:
    patterns:
      - comment: XML Fragment
        contentName: text.html.fragment.ruko
        begin: (<)(?=>)
        end: (?<=</)(>)
        captures:
          1: {name: punctuation.definition.tag.ruko}
        patterns:
          - include: '#tag-termination'
      - comment: Expression tags like <( ... )>.
        contentName: text.html.ruko
        begin: (<)(\()
        end: |
          (?x) \s*
          (?:
              (/>) # Tags implicitly closed.
            | ((?<=</).*?)(>)
          ) \s*
        beginCaptures:
          1: {name: punctuation.definition.tag.ruko}
          2: {name: punctuation.definition.expression.ruko}
        endCaptures:
          1: {name: punctuation.definition.tag.ruko}
          2: {name: punctuation.definition.expression.ruko}
        patterns:
          - begin: (?<=<\()\s*
            end: \s*(\))
            name: meta.expression.tag.ruko
            captures:
              1: {name: punctuation.definition.expression.ruko}
            patterns: [include: $self]
          - include: '#tag-attributes'
          - include: '#tag-termination'
          - match: (?<=</)(>)
            name: punctuation.definition.tag.ruko
      - comment: Tags that end > are trapped in tag-termination
        contentName: text.html.ruko
        begin: |
          (?x)
          (<) # start tag begin
          (
            (?:
              \b
              [\p{Pc}\p{L}]\w* # identifier
              \b
              (?:[?!:]:|[?!]?\.|[?!-]>) # qualified name separator
            )*
            [\p{Pc}\p{L}]\w* # last part of identifier
            \b
          )
          (?=[,;'"`({\[)}\]/>\s])
        end: |
          (?x) \s*
          (?:
              (?<=</)(\2)?(>) # explicit end tag
            | (/>) # self-closing tag
            | ((?<=</).*?)(>)
          ) \s*
        beginCaptures:
          1: {name: punctuation.definition.tag.ruko}
          2: {patterns: [{include: '#tag-names'}]}
        endCaptures:
          0: {name: meta.tag.ruko}
          1: {patterns: [{include: '#tag-names'}]}
          2: {name: punctuation.definition.tag.ruko}
          3: {name: punctuation.definition.tag.ruko}
          4: {name: invalid.illegal.termination.ruko}
          5: {name: punctuation.definition.tag.ruko}
        patterns:
          - include: '#tag-attributes'
          - include: '#tag-termination'
          - match: (?<=</)(>)
            name: punctuation.definition.tag.ruko

  xml-comments:
    begin: (<!--)
    end: (-->)
    captures:
      1: {name: punctuation.definition.comment.ruko}
    name: comment.block.html.ruko
    patterns:
      - include: '#xml-comments'

  tag-termination:
    comment: uses non consuming search for </ in </tag>
    contentName: meta.xml.children.ruko
    begin: (>)
    end: (</(?=\b|>))
    captures:
      1: {name: punctuation.definition.tag.ruko}
    patterns:
      - include: '#evaluated-code'
      - include: '#xml-entities'
      - include: '#tag-component-name'
      - include: '#markdown'
      - include: '#xml-comments'

  tag-attributes:
    patterns:
      - match: \s*([@#&*|%.:~^?]|::)(?=[\w$'"`])
        name: punctuation.definition.entity.ruko
      - include: '#spread-attribute'
      - include: '#style-attribute'
      - include: '#attribute-directive'
      - include: '#attribute-assignment'
      - include: '#attribute-names'
      - include: '#literals'
      - include: '#hex-colors'
      - include: '#embedded-expressions'
      - include: '#embedded-formatting'
      - include: '#embedded-arguments'
      - include: '#function-calls'
      - include: '#variables'
      - include: '#brackets'
      - include: '#comments'
      - include: '#punctuation'
      - include: '#space'

  attribute-directive:
    patterns:
      - match: \s*([@#&*%|:?])([\p{Pc}\p{L}][\p{Pd}\w]*)\b\s*
        name: meta.attribute.directive.ruko
        captures:
          1: {name: punctuation.definition.directive.ruko}
          2: {name: entity.other.attribute-name.directive.ruko}

  style-attribute:
    begin: \s*(style)\s*(=)\s*(\{)\s*
    beginCaptures:
      1: {name: storage.type.style.ruko}
      2: {name: punctuation.separator.key-value.ruko}
      3: {name: punctuation.definition.style-block.ruko}
    end: \s*(\})\s*
    endCaptures:
      1: {name: punctuation.definition.style-block.ruko}
    name: meta.attribute.style.ruko
    patterns: [{include: '#style-properties'}]

  attribute-assignment:
    applyEndPatternLast: true
    begin: \s*([\p{Pc}\p{L}][\p{Pd}\w]*)\s*(=)
    beginCaptures:
      1: &attribute-name
        name: entity.other.attribute-name.ruko
        patterns:
          - match: \s*(?<=\@)[\p{Pc}\p{L}]\w*\b\s*
            name: keyword.control.at-rule.ruko
          - match: \s*(?<=\#)[\p{Pc}\p{L}]\w*\b\s*
            name: entity.other.attribute-name.id.ruko
          - match: \s*(?<=\.)[\p{Pc}\p{L}]\w*\b\s*
            name: entity.other.attribute-name.class.ruko
          - match: \s*(?<=::)[\p{Pc}\p{L}]\w*\b\s*
            name: entity.other.attribute-name.pseudo-component.ruko
          - match: \s*(?<=\~)[\p{Pc}\p{L}]\w*\b\s*
            name: entity.other.attribute-name.key.ruko
          - match: \s*(?<=\&)[\p{Pc}\p{L}]\w*\b\s*
            name: entity.other.attribute-name.ruko entity.name.type.anchor.ruko
          - match: \s*(?<=\*)[\p{Pc}\p{L}]\w*\b\s*
            name: entity.other.attribute-name.ruko entity.name.type.alias.ruko
          - match: \s*(?<=\%)[\p{Pc}\p{L}]\w*\b\s*
            name: entity.other.attribute-name.ruko entity.name.function.ruko
          - match: \s*(?<=\|)[\p{Pc}\p{L}]\w*\b\s*
            name: entity.other.attribute-name.ruko entity.name.method.ruko
          - match: \s*(?<=\:)[\p{Pc}\p{L}]\w*\b\s*
            name: entity.other.attribute-name.ruko entity.name.procedure.ruko
          - match: \s*(?<=\^)[\p{Pc}\p{L}]\w*\b\s*
            name: entity.other.attribute-name.ruko entity.name.property.ruko
          - match: \s*(?<=\?)[\p{Pc}\p{L}]\w*\b\s*
            name: entity.other.attribute-name.ruko entity.name.predicate.ruko
          - include: '#css-property-names'
      2: {name: punctuation.separator.key-value.ruko}
    end: (?=)|$
    name: meta.attribute.assignment.ruko
    patterns: [{include: '#attribute-values'}]

  attribute-values:
    patterns:
      - include: '#literals'
      - include: '#embedded-expressions'
      - include: '#brackets'

  attribute-names:
    match: \s*([\p{Pc}\p{L}][\p{Pd}\w]*)\b(?!\s*=)\s*
    name: meta.attribute.boolean.ruko
    captures:
      1: *attribute-name

  spread-attribute:
    comment: Spread *attribute
    match: \s*(?<!\*)(\*\*?)(?!\*)\s*
    name: keyword.operator.spread.ruko

  xml-entities:
    patterns:
      - match: |
          (?xi)
          (&)(?:
              (\#\\0*(?:111411[10]|111410\d|11140\d{2}|111[0-3]\d{3}|110\d{4}|10\d{5}|[1-9]\d{0,5}|0)) # decimal
            | (\#b0*(?:10000[10]{16}|1[01]{0,19}|0)) # binary
            | (\#q0*(?:1003{8}|100[0-2]{10}|10[0-3]{12}|[1-3][0-3]{0,18}|0)) # quaternary
            | (\#o0*(?:41[0-7]{5}|[1-3][0-7]{6}|[1-7][0-7]{0,5}|0)) # octal
            | (\#x0*(?:10\h{6}|\h{1,5})) # hexadecimal
            | ([\p{Pc}\p{L}]\w*) # named
            | ((?:\\.|[^({\[)}\]\s;])+?) # numeric or invalid
          )(;)
        name: constant.other.entity.ruko
        captures: &xml-entities
          1: {name: punctuation.definition.entity.ruko}
          2: {name: constant.character.escape.decimal.ruko}
          3: {name: constant.character.escape.binary.ruko}
          4: {name: constant.character.escape.quaternary.ruko}
          6: {name: constant.character.escape.octal.ruko}
          7: {name: constant.character.escape.hexadecimal.ruko}
          8: {name: constant.character.entity.named.ruko}
          9: {name: constant.character.entity.ruko}
          10: {name: punctuation.definition.entity.ruko}
      - match: '&(?=\w*;)'
        name: invalid.illegal.ambiguous-ampersand.ruko
      - comment: Entity with & and invalid name
        match: '&\s*+;'
        name: invalid.illegal.bad-ampersand.ruko

  inline-markdown:
    patterns:
      - include: '#ampersand'
      - include: '#bracket'
      - include: '#bold'
      - include: '#italic'
      - include: '#underline'
      - include: '#strikethrough'
      - include: '#superscript'
      - include: '#subscript'
      - include: '#redacted'
      - include: '#highlight'
      - include: '#xml-regex-content'
      - include: '#raw'
      - include: '#escape'
      - include: '#image-inline'
      - include: '#image-ref'
      - include: '#link-email'
      - include: '#link-inet'
      - include: '#link-inline'
      - include: '#link-ref'
      - include: '#link-ref-literal'
      - include: '#link-ref-shortcut'

  ampersand:
    comment: Markdown will convert this for us. We match it so that the HTML grammar will not mark it up as invalid.
    match: '&(?!([a-zA-Z\d]+|#[\d]+|#x\h+);)'
    name: meta.other.valid-ampersand.markdown

  bold:
    begin: (\*\*|\b__)(?=\S)
    captures:
      1: {name: punctuation.definition.bold.markdown}
    end: (?<=\S)(\1)
    name: markup.bold.markdown
    patterns:
      - include: '#ampersand'
      - include: '#bracket'
      - include: '#italic'
      - include: '#underline'
      - include: '#strikethrough'
      - include: '#superscript'
      - include: '#subscript'
      - include: '#redacted'
      - include: '#highlight'
      - include: '#xml-regex-content'
      - include: '#raw'
      - include: '#escape'
      - include: '#image-inline'
      - include: '#image-ref'
      - include: '#link-email'
      - include: '#link-inet'
      - include: '#link-inline'
      - include: '#link-ref'
      - include: '#link-ref-literal'
      - include: '#link-ref-shortcut'

  italic:
    begin: (\*|\b_)(?=\S)
    captures:
      1: {name: punctuation.definition.italic.markdown}
    end: (?<=\S)(\1)((?!\1)|(?=\1\1))
    name: markup.italic.markdown
    patterns:
      - include: '#ampersand'
      - include: '#bracket'
      - include: '#bold'
      - include: '#underline'
      - include: '#strikethrough'
      - include: '#superscript'
      - include: '#subscript'
      - include: '#redacted'
      - include: '#highlight'
      - include: '#xml-regex-content'
      - include: '#raw'
      - include: '#escape'
      - include: '#image-inline'
      - include: '#image-ref'
      - include: '#link-email'
      - include: '#link-inet'
      - include: '#link-inline'
      - include: '#link-ref'
      - include: '#link-ref-literal'
      - include: '#link-ref-shortcut'

  strikethrough:
    begin: (~~)(?=\S)
    captures:
      1: {name: punctuation.definition.strikethrough.markdown}
    end: (?<=\S)(~~)
    name: markup.strikethrough.markdown
    patterns:
      - include: '#ampersand'
      - include: '#bracket'
      - include: '#bold'
      - include: '#italic'
      - include: '#underline'
      - include: '#superscript'
      - include: '#subscript'
      - include: '#redacted'
      - include: '#highlight'
      - include: '#xml-regex-content'
      - include: '#raw'
      - include: '#escape'
      - include: '#image-inline'
      - include: '#image-ref'
      - include: '#link-email'
      - include: '#link-inet'
      - include: '#link-inline'
      - include: '#link-ref'
      - include: '#link-ref-literal'
      - include: '#link-ref-shortcut'

  underline:
    begin: (\+\+)(?=\S)
    captures:
      1: {name: punctuation.definition.underline.markdown}
    end: (?<=\S)(\+\+)
    name: markup.underline.markdown
    patterns:
      - include: '#ampersand'
      - include: '#bracket'
      - include: '#bold'
      - include: '#italic'
      - include: '#strikethrough'
      - include: '#superscript'
      - include: '#subscript'
      - include: '#redacted'
      - include: '#highlight'
      - include: '#xml-regex-content'
      - include: '#raw'
      - include: '#escape'
      - include: '#image-inline'
      - include: '#image-ref'
      - include: '#link-email'
      - include: '#link-inet'
      - include: '#link-inline'
      - include: '#link-ref'
      - include: '#link-ref-literal'
      - include: '#link-ref-shortcut'

  redacted:
    begin: (\|\|)(?=\S)
    captures:
      1: {name: punctuation.definition.redacted.markdown}
    end: (?<=\S)(\|\|)
    name: markup.redacted.markdown
    patterns:
      - include: '#ampersand'
      - include: '#bracket'
      - include: '#bold'
      - include: '#italic'
      - include: '#underline'
      - include: '#strikethrough'
      - include: '#superscript'
      - include: '#subscript'
      - include: '#highlight'
      - include: '#xml-regex-content'
      - include: '#raw'
      - include: '#escape'
      - include: '#image-inline'
      - include: '#image-ref'
      - include: '#link-email'
      - include: '#link-inet'
      - include: '#link-inline'
      - include: '#link-ref'
      - include: '#link-ref-literal'
      - include: '#link-ref-shortcut'

  highlight:
    begin: (==)(?=\S)
    captures:
      1: {name: punctuation.definition.highlight.markdown}
    end: (?<=\S)(==)
    name: markup.highlight.markdown
    patterns:
      - include: '#ampersand'
      - include: '#bracket'
      - include: '#bold'
      - include: '#italic'
      - include: '#underline'
      - include: '#strikethrough'
      - include: '#superscript'
      - include: '#subscript'
      - include: '#redacted'
      - include: '#xml-regex-content'
      - include: '#raw'
      - include: '#escape'
      - include: '#image-inline'
      - include: '#image-ref'
      - include: '#link-email'
      - include: '#link-inet'
      - include: '#link-inline'
      - include: '#link-ref'
      - include: '#link-ref-literal'
      - include: '#link-ref-shortcut'

  superscript:
    begin: (\^)(?=\S)
    captures:
      1: {name: punctuation.definition.superscript.markdown}
    end: (?<=\S)(\^)
    name: markup.superscript.markdown
    patterns:
      - include: '#ampersand'
      - include: '#bracket'
      - include: '#bold'
      - include: '#italic'
      - include: '#underline'
      - include: '#strikethrough'
      - include: '#subscript'
      - include: '#redacted'
      - include: '#highlight'
      - include: '#xml-regex-content'
      - include: '#raw'
      - include: '#escape'
      - include: '#image-inline'
      - include: '#image-ref'
      - include: '#link-email'
      - include: '#link-inet'
      - include: '#link-inline'
      - include: '#link-ref'
      - include: '#link-ref-literal'
      - include: '#link-ref-shortcut'

  subscript:
    begin: (~)(?=\S)
    captures:
      1: {name: punctuation.definition.subscript.markdown}
    end: (?<=\S)(~)
    name: markup.subscript.markdown
    patterns:
      - include: '#ampersand'
      - include: '#bracket'
      - include: '#bold'
      - include: '#italic'
      - include: '#underline'
      - include: '#strikethrough'
      - include: '#superscript'
      - include: '#redacted'
      - include: '#highlight'
      - include: '#xml-regex-content'
      - include: '#raw'
      - include: '#escape'
      - include: '#image-inline'
      - include: '#image-ref'
      - include: '#link-email'
      - include: '#link-inet'
      - include: '#link-inline'
      - include: '#link-ref'
      - include: '#link-ref-literal'
      - include: '#link-ref-shortcut'

  bracket:
    comment: Markdown will convert this for us. We match it so that the HTML grammar will not mark it up as invalid.
    match: <(?![a-zA-Z/?\$!])
    name: meta.other.valid-bracket.markdown

  escape:
    comment: Escape characters in Markdown
    match: \\[-`*_#+.!({\[)}\]\\>~|=]
    name: constant.character.escape.markdown

  image-inline:
    comment: Inline image ![alt text](url "optional title")
    match: |
      (?x)
      (\!\[)((?<square>[^\[\]\\]|\\.|\[\g<square>*+\])*+)(\])
      # Match the link text.
      (\() # Opening paren for url
        (<?)(\S+?)(>?) # The url
        [ \t]* # Optional whitespace
        (?:
            ((\().+?(\))) # Match title in parens...
          | ((").+?(")) # or in double quotes...
          | ((').+?(')) # or in single quotes.
        )? # Title is optional
        \s* # Optional whitespace
      (\))
    name: meta.image.inline.markdown
    captures:
      1: {name: punctuation.definition.string.begin.markdown}
      2: {name: string.other.link.description.markdown}
      4: {name: punctuation.definition.string.end.markdown}
      5: {name: punctuation.definition.metadata.markdown}
      6: {name: punctuation.definition.link.markdown}
      7: {name: markup.underline.link.image.markdown}
      8: {name: punctuation.definition.link.markdown}
      9: {name: string.other.link.description.title.markdown}
      10: {name: punctuation.definition.string.markdown}
      11: {name: punctuation.definition.string.markdown}
      12: {name: string.other.link.description.title.markdown}
      13: {name: punctuation.definition.string.markdown}
      14: {name: punctuation.definition.string.markdown}
      15: {name: string.other.link.description.title.markdown}
      16: {name: punctuation.definition.string.markdown}
      17: {name: punctuation.definition.string.markdown}
      18: {name: punctuation.definition.metadata.markdown}

  image-ref:
    captures:
      1: {name: punctuation.definition.string.begin.markdown}
      2: {name: string.other.link.description.markdown}
      4: {name: punctuation.definition.string.begin.markdown}
      5: {name: punctuation.definition.constant.markdown}
      6: {name: constant.other.reference.link.markdown}
      7: {name: punctuation.definition.constant.markdown}
    match: (\!\[)((?<square>[^\[\]\\]|\\.|\[\g<square>*+\])*+)(\])[ ]?(\[)(.*?)(\])
    name: meta.image.reference.markdown
    patterns: [{include: '#xml-regex-content'}]

  link-email:
    captures:
      1: {name: punctuation.definition.link.markdown}
      2: {name: markup.underline.link.markdown}
      4: {name: punctuation.definition.link.markdown}
    match: (<)((?:mailto:)?[a-zA-Z\d.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z\d-]+(?:\.[a-zA-Z\d-]+)*)(>)
    name: meta.link.email.lt-gt.markdown
    patterns: [{include: '#xml-regex-content'}]

  link-inet:
    captures:
      1: {name: punctuation.definition.link.markdown}
      2: {name: markup.underline.link.markdown}
      3: {name: punctuation.definition.link.markdown}
    match: (<)((?:https?|ftp)://.*?)(>)
    name: meta.link.inet.markdown
    patterns: [{include: '#xml-regex-content'}]

  link-inline:
    captures:
      1: {name: punctuation.definition.string.begin.markdown}
      2: {name: string.other.link.title.markdown}
      4: {name: punctuation.definition.string.end.markdown}
      5: {name: punctuation.definition.metadata.markdown}
      6: {name: punctuation.definition.link.markdown}
      7: {name: markup.underline.link.markdown}
      9: {name: punctuation.definition.link.markdown}
      10: {name: string.other.link.description.title.markdown}
      11: {name: punctuation.definition.string.begin.markdown}
      12: {name: punctuation.definition.string.end.markdown}
      13: {name: string.other.link.description.title.markdown}
      14: {name: punctuation.definition.string.begin.markdown}
      15: {name: punctuation.definition.string.end.markdown}
      16: {name: string.other.link.description.title.markdown}
      17: {name: punctuation.definition.string.begin.markdown}
      18: {name: punctuation.definition.string.end.markdown}
      19: {name: punctuation.definition.metadata.markdown}
    match: |
      (?x)
      (\[)((?<square>[^\[\]\\]|\\.|\[\g<square>*+\])*+)(\])
      # Match the link text.
      (\() # Opening paren for url
        (<?)((?<url>(?>[^\s()]+)|\(\g<url>*\))*)(>?) # The url
        [ \t]* # Optional whitespace
        (?:
            ((\().+?(\))) # Match title in parens...
          | ((").+?(")) # or in double quotes...
          | ((').+?(')) # or in single quotes.
        )? # Title is optional
        \s* # Optional whitespace
      (\))
    name: meta.link.inline.markdown
    patterns: [{include: '#xml-regex-content'}]

  link-ref:
    captures:
      1: {name: punctuation.definition.string.begin.markdown}
      2: {name: string.other.link.title.markdown}
      4: {name: punctuation.definition.string.end.markdown}
      5: {name: punctuation.definition.constant.begin.markdown}
      6: {name: constant.other.reference.link.markdown}
      7: {name: punctuation.definition.constant.end.markdown}
    match: (\[)((?<square>[^\[\]\\]|\\.|\[\g<square>*+\])*+)(\])(\[)([^\]]*+)(\])
    name: meta.link.reference.markdown
    patterns: [{include: '#xml-regex-content'}]

  link-ref-literal:
    captures:
      1: {name: punctuation.definition.string.begin.markdown}
      2: {name: string.other.link.title.markdown}
      4: {name: punctuation.definition.string.end.markdown}
      5: {name: punctuation.definition.constant.begin.markdown}
      6: {name: punctuation.definition.constant.end.markdown}
    match: (\[)((?<square>[^\[\]\\]|\\.|\[\g<square>*+\])*+)(\])[ ]?(\[)(\])
    name: meta.link.reference.literal.markdown
    patterns: [{include: '#xml-regex-content'}]

  link-ref-shortcut:
    captures:
      1: {name: punctuation.definition.string.begin.markdown}
      2: {name: string.other.link.title.markdown}
      3: {name: punctuation.definition.string.end.markdown}
    match: (\[)(\S+?)(\])
    name: meta.link.reference.markdown
    patterns: [{include: '#xml-regex-content'}]

  raw:
    captures:
      1: {name: punctuation.definition.raw.markdown}
      2: {patterns: [{include: '#xml-regex-content'}]}
      3: {name: punctuation.definition.raw.markdown}
    match: (`+)([^`]|(?!(?<!`)\1(?!`))`)*+(\1)
    name: markup.inline.raw.string.markdown
    patterns: [{include: '#xml-regex-content'}]

  xml-regex-content:
    patterns:
      - include: '#string-escapes'
      - include: '#embedded-verbatim'

  markdown:
    patterns:
      - include: '#comments'
      - include: '#xml-entities'
      - include: '#html-tag'
      - include: '#xml-regex-content'
      - include: '#evaluated-code'
      - include: '#inline-styles'
      - include: '#headings'
      - include: '#blockquote'
      - include: '#unordered-list'
      - include: '#ordered-list'
      - include: '#inline-markdown'

  headings:
    comment: '### Headings'
    begin: ^\s*(\#{1,6})\s+(.*)\n*
    end: ^(?=\S)|(?!\G)
    beginCaptures:
      1:
        name: punctuation.definition.heading.markdown
      2:
        patterns:
          - applyEndPatternLast: true
            begin: (?<=\######\s*)
            end: (?=|$)
            name: heading.6.markdown entity.name.section.markdown
            patterns: [{include: '#markdown'}]
          - applyEndPatternLast: true
            begin: (?<=\#####\s*)
            end: (?=|$)
            name: heading.5.markdown entity.name.section.markdown
            patterns: [{include: '#markdown'}]
          - applyEndPatternLast: true
            begin: (?<=\####\s*)
            end: (?=|$)
            name: heading.4.markdown entity.name.section.markdown
            patterns: [{include: '#markdown'}]
          - applyEndPatternLast: true
            begin: (?<=\###\s*)
            end: (?=|$)
            name: heading.3.markdown entity.name.section.markdown
            patterns: [{include: '#markdown'}]
          - applyEndPatternLast: true
            begin: (?<=\##\s*)
            end: (?=|$)
            name: heading.2.markdown entity.name.section.markdown
            patterns: [{include: '#markdown'}]
          - applyEndPatternLast: true
            begin: (?<=\#\s*)
            end: (?=|$)
            name: heading.1.markdown entity.name.section.markdown
            patterns: [{include: '#markdown'}]
    name: markup.heading.markdown
    patterns: [{include: '#markdown'}]

  blockquote:
    comment: '* blockquote'
    begin: ^\s*(\*)(\s+.*)\n*
    end: ^(?=\S)|(?!\G)
    beginCaptures:
      1: {name: punctuation.definition.quote.begin.markdown}
      2:
        name: markup.quote.markdown
        patterns: [{include: '#markdown'}]
    name: markup.quote.markdown
    patterns: [{include: '#markdown'}]

  unordered-list:
    comment: '- unordered list'
    begin: ^\s*(\-)(?!>)\s+(.*)\n*
    end: ^(?=\S)|(?!\G)
    beginCaptures:
      1: {name: punctuation.definition.list.begin.markdown}
      2:
        name: markup.list.unnumbered.markdown
        patterns: [{include: '#markdown'}]
    name: markup.list.unnumbered.markdown
    patterns: [{include: '#markdown'}]

  ordered-list:
    comment: '+ ordered list'
    begin: ^\s*(\+)(?!>)\s+(.*)\n*
    end: ^(?=\S)|(?!\G)
    beginCaptures:
      1: {name: punctuation.definition.list.begin.markdown}
      2:
        name: markup.list.numbered.markdown
        patterns: [{include: '#markdown'}]
    name: markup.list.numbered.markdown
    patterns: [{include: '#markdown'}]

  evaluated-code:
    applyEndPatternLast: true
    comment: Evaluated code
    begin: (?<=^|[\w\s'"`])(>)
    end: (?=|$)
    captures:
      1: {name: punctuation.definition.markdown}
    name: meta.evaluated-code.markdown
    patterns:
      - include: '#line-continuation'
      - include: $self

  html-tag:
    comment: <Tags
    applyEndPatternLast: true
    begin: (?<=^|[\w\s'"`])(<)\b
    end: (<?>?=?)|(?=)|$
    name: meta.tag.ruko
    captures:
      1: {name: punctuation.definition.tag.ruko}
    patterns:
      - comment: Tag name
        match: (?<=<)\b([\p{Pc}\p{L}]\w*\b(?:(?:[?!:]:|[?!]?\.|[?!-]>)[\p{Pc}\p{L}]\w*)*)\b
        captures:
          1:
            name: entity.name.tag.ruko
            patterns: *html-tag-names
      - include: '#style-selectors'
      - begin: (\[)\s*
        end: \s*(\])\s*
        captures:
          1: {name: punctuation.definition.directive.ruko}
        patterns:
          - include: '#attribute-selectors'
          - include: $self
      - begin: (\{)\s*
        end: \s*(\})\s*
        captures:
          1: {name: punctuation.definition.mapping.ruko}
        patterns:
          - include: '#style-properties'
          - include: $self
      - begin: (\()\s*
        end: \s*(\))
        captures:
          1: {name: punctuation.definition.parameters.ruko}
        patterns:
          - include: '#tag-attributes'
          - include: $self
      - include: '#literals'
      - include: '#regexps'
      - include: '#punctuation'
      - include: '#comments'
      - include: '#space'

  inline-styles:
    begin: (?<=^|[\w\s'"`])(\+>)(.*)\n*
    beginCaptures:
      1:
        name: storage.type.style.ruko
      2:
        patterns:
          - match: (?<=^|\s)([?:]?=)(?=\s+|$)
            captures:
              1: {name: keyword.operator.assignment.ruko}
          - include: '#comments'
          - include: '#style-pair'
          - include: '#style-rules'
          - include: '#declaration-clause'
          - match: *entity-name
            name: entity.name.style.ruko
    end: ^(?=\S)|(?!\G)
    patterns:
      - begin: ^(\s+)(?!\s)
        end: ^(?!\1|\s*$)
        name: meta.style.yaml
        patterns: [{include: '#style-properties'}]

  # Special code blocks

  html-builtins:
    patterns:
      - include: source.css.scss#constant_functions
      - include: source.css.scss#constant_sass_functions
      - include: source.css.scss#constant_important
      - include: source.css.scss#constant_default
      - include: source.css.scss#constant_optional

  property-name:
    match: (\b[\p{Pc}\p{L}]\w*\b(?:(?:(?:[?!:]:|[?!]?\.|[?!-]>)?[\p{Pc}\p{L}]\w*)*)\b)
    name: meta.property-name.ruko
    captures:
      1:
        patterns:
          - include: '#css-value-names'
          - match: ([\p{Pc}\p{L}]\w*)\b(?=[.:])
            name: constant.other.ruko
          - match: ([\p{Pc}\p{L}]\w*)\b
            name: constant.language.ruko
          - match: '[?!:]:|[?!]?\.|[?!-]>'
            name: punctuation.separator.namespace.ruko

  style-list:
    begin: \s*(\[)\s*
    end: \s*(\])
    name: meta.brace.square.ruko
    captures:
      1: {name: punctuation.definition.expression.ruko}
    patterns:
      - include: '#punctuation'
      - include: '#style-property-values'
      - include: $self

  style-property-values:
    patterns:
      - include: '#hex-colors'
      - include: '#embedded-expressions'
      - include: '#embedded-formatting'
      - include: '#embedded-arguments'
      - include: '#css-value-names'
      - include: $self

  hex-colors:
    match: \s*(\#)\b(\h{3,4}|\h{6}|\h{8})\b\s*
    captures:
      1: {name: punctuation.definition.constant.css}
      2:
        name: constant.other.color.rgb-value.hex.css
        patterns:
          - match: (\h{2})(\h{2})(\h{2})(\h{2})?
            captures:
              1: {name: constant.other.color.red-value.hex.css}
              2: {name: constant.other.color.green-value.hex.css}
              3: {name: constant.other.color.blue-value.hex.css}
              4: {name: constant.other.color.alpha-value.hex.css}
          - match: (\h)(\h)(\h)(\h)?
            captures:
              1: {name: constant.other.color.red-value.hex.css}
              2: {name: constant.other.color.green-value.hex.css}
              3: {name: constant.other.color.blue-value.hex.css}
              4: {name: constant.other.color.alpha-value.hex.css}

  tag-names:
    match: \s*\b([\p{Pc}\p{L}]\w*\b(?:(?:[?!:]:|[?!]?\.|[?!-]>)?[\p{Pc}\p{L}]\w*)*)\b\s*
    name: entity.name.tag.ruko
    captures:
      1:
        name: entity.name.tag.ruko
        patterns: *html-tag-names

  script-blocks:
    patterns:
      - begin: \b((?i:js))\b\s*(\{)\s*
        end: \s*(\})\s*
        name: meta.brace.script.ruko
        beginCaptures:
          1: {name: storage.type.language.ruko}
          2: {name: punctuation.definition.block.script.ruko}
        endCaptures:
          1: {name: punctuation.definition.block.script.ruko}
        patterns:
          - include: '#embedded'
          - include: source.js
      - begin: \b((?i:jsx))\b\s*(\{)\s*
        end: \s*(\})\s*
        name: meta.brace.script.ruko
        beginCaptures:
          1: {name: storage.type.language.ruko}
          2: {name: punctuation.definition.block.script.ruko}
        endCaptures:
          1: {name: punctuation.definition.block.script.ruko}
        patterns:
          - include: '#embedded'
          - include: source.jsx
      - begin: \b((?i:ts))\b\s*(\{)\s*
        end: \s*(\})\s*
        name: meta.brace.script.ruko
        beginCaptures:
          1: {name: storage.type.language.ruko}
          2: {name: punctuation.definition.block.script.ruko}
        endCaptures:
          1: {name: punctuation.definition.block.script.ruko}
        patterns:
          - include: '#embedded'
          - include: source.ts
      - begin: \b((?i:tsx))\b\s*(\{)\s*
        end: \s*(\})\s*
        name: meta.brace.script.ruko
        beginCaptures:
          1: {name: storage.type.language.ruko}
          2: {name: punctuation.definition.block.script.ruko}
        endCaptures:
          1: {name: punctuation.definition.block.script.ruko}
        patterns:
          - include: '#embedded'
          - include: source.tsx
      - begin: \b((?i:py))\b\s*(\{)\s*
        end: \s*(\})\s*
        name: meta.brace.script.ruko
        beginCaptures:
          1: {name: storage.type.language.ruko}
          2: {name: punctuation.definition.block.script.ruko}
        endCaptures:
          1: {name: punctuation.definition.block.script.ruko}
        patterns:
          - include: '#embedded'
          - include: source.python
      - begin: \b((?i:rb))\b\s*(\{)\s*
        end: \s*(\})\s*
        name: meta.brace.script.ruko
        beginCaptures:
          1: {name: storage.type.language.ruko}
          2: {name: punctuation.definition.block.script.ruko}
        endCaptures:
          1: {name: punctuation.definition.block.script.ruko}
        patterns:
          - include: '#embedded'
          - include: source.ruby
      - begin: \b((?i:php))\b\s*(\{)\s*
        end: \s*(\})\s*
        name: meta.brace.script.ruko
        beginCaptures:
          1: {name: storage.type.language.ruko}
          2: {name: punctuation.definition.block.script.ruko}
        endCaptures:
          1: {name: punctuation.definition.block.script.ruko}
        patterns:
          - include: '#embedded'
          - include: source.php
      - begin: \b((?i:java))\b\s*(\{)\s*
        end: \s*(\})\s*
        name: meta.brace.script.ruko
        beginCaptures:
          1: {name: storage.type.language.ruko}
          2: {name: punctuation.definition.block.script.ruko}
        endCaptures:
          1: {name: punctuation.definition.block.script.ruko}
        patterns:
          - include: '#embedded'
          - include: source.java
      - begin: \b((?i:cpp))\b\s*(\{)\s*
        end: \s*(\})\s*
        name: meta.brace.script.ruko
        beginCaptures:
          1: {name: storage.type.language.ruko}
          2: {name: punctuation.definition.block.script.ruko}
        endCaptures:
          1: {name: punctuation.definition.block.script.ruko}
        patterns:
          - include: '#embedded'
          - include: source.cpp
      - begin: \b((?i:c))\b\s*(\{)\s*
        end: \s*(\})\s*
        name: meta.brace.script.ruko
        beginCaptures:
          1: {name: storage.type.language.ruko}
          2: {name: punctuation.definition.block.script.ruko}
        endCaptures:
          1: {name: punctuation.definition.block.script.ruko}
        patterns:
          - include: '#embedded'
          - include: source.c
      - begin: \b((?i:cs))\b\s*(\{)\s*
        end: \s*(\})\s*
        name: meta.brace.script.ruko
        beginCaptures:
          1: {name: storage.type.language.ruko}
          2: {name: punctuation.definition.block.script.ruko}
        endCaptures:
          1: {name: punctuation.definition.block.script.ruko}
        patterns:
          - include: '#embedded'
          - include: source.cs
      - begin: \b((?i:go))\b\s*(\{)\s*
        end: \s*(\})\s*
        name: meta.brace.script.ruko
        beginCaptures:
          1: {name: storage.type.language.ruko}
          2: {name: punctuation.definition.block.script.ruko}
        endCaptures:
          1: {name: punctuation.definition.block.script.ruko}
        patterns:
          - include: '#embedded'
          - include: source.go
      - begin: \b((?i:rs))\b\s*(\{)\s*
        end: \s*(\})\s*
        name: meta.brace.script.ruko
        beginCaptures:
          1: {name: storage.type.language.ruko}
          2: {name: punctuation.definition.block.script.ruko}
        endCaptures:
          1: {name: punctuation.definition.block.script.ruko}
        patterns:
          - include: '#embedded'
          - include: source.rust
      - begin: \b((?i:swift))\b\s*(\{)\s*
        end: \s*(\})\s*
        name: meta.brace.script.ruko
        beginCaptures:
          1: {name: storage.type.language.ruko}
          2: {name: punctuation.definition.block.script.ruko}
        endCaptures:
          1: {name: punctuation.definition.block.script.ruko}
        patterns:
          - include: '#embedded'
          - include: source.swift
      - begin: \b((?i:kt))\b\s*(\{)\s*
        end: \s*(\})\s*
        name: meta.brace.script.ruko
        beginCaptures:
          1: {name: storage.type.language.ruko}
          2: {name: punctuation.definition.block.script.ruko}
        endCaptures:
          1: {name: punctuation.definition.block.script.ruko}
        patterns:
          - include: '#embedded'
          - include: source.kotlin
      - begin: \b((?i:scala))\b\s*(\{)\s*
        end: \s*(\})\s*
        name: meta.brace.script.ruko
        beginCaptures:
          1: {name: storage.type.language.ruko}
          2: {name: punctuation.definition.block.script.ruko}
        endCaptures:
          1: {name: punctuation.definition.block.script.ruko}
        patterns:
          - include: '#embedded'
          - include: source.scala
      - begin: \b((?i:hs))\b\s*(\{)\s*
        end: \s*(\})\s*
        name: meta.brace.script.ruko
        beginCaptures:
          1: {name: storage.type.language.ruko}
          2: {name: punctuation.definition.block.script.ruko}
        endCaptures:
          1: {name: punctuation.definition.block.script.ruko}
        patterns:
          - include: '#embedded'
          - include: source.haskell
      - begin: \b((?i:lua))\b\s*(\{)\s*
        end: \s*(\})\s*
        name: meta.brace.script.ruko
        beginCaptures:
          1: {name: storage.type.language.ruko}
          2: {name: punctuation.definition.block.script.ruko}
        endCaptures:
          1: {name: punctuation.definition.block.script.ruko}
        patterns:
          - include: '#embedded'
          - include: source.lua
      - begin: \b((?i:dart))\b\s*(\{)\s*
        end: \s*(\})\s*
        name: meta.brace.script.ruko
        beginCaptures:
          1: {name: storage.type.language.ruko}
          2: {name: punctuation.definition.block.script.ruko}
        endCaptures:
          1: {name: punctuation.definition.block.script.ruko}
        patterns:
          - include: '#embedded'
          - include: source.dart
      - begin: \b((?i:objc))\b\s*(\{)\s*
        end: \s*(\})\s*
        name: meta.brace.script.ruko
        beginCaptures:
          1: {name: storage.type.language.ruko}
          2: {name: punctuation.definition.block.script.ruko}
        endCaptures:
          1: {name: punctuation.definition.block.script.ruko}
        patterns:
          - include: '#embedded'
          - include: source.objc
      - begin: \b((?i:objcpp))\b\s*(\{)\s*
        end: \s*(\})\s*
        name: meta.brace.script.ruko
        beginCaptures:
          1: {name: storage.type.language.ruko}
          2: {name: punctuation.definition.block.script.ruko}
        endCaptures:
          1: {name: punctuation.definition.block.script.ruko}
        patterns:
          - include: '#embedded'
          - include: source.objcpp
      - begin: \b((?i:perl))\b\s*(\{)\s*
        end: \s*(\})\s*
        name: meta.brace.script.ruko
        beginCaptures:
          1: {name: storage.type.language.ruko}
          2: {name: punctuation.definition.block.script.ruko}
        endCaptures:
          1: {name: punctuation.definition.block.script.ruko}
        patterns:
          - include: '#embedded'
          - include: source.perl
      - begin: \b((?i:r))\b\s*(\{)\s*
        end: \s*(\})\s*
        name: meta.brace.script.ruko
        beginCaptures:
          1: {name: storage.type.language.ruko}
          2: {name: punctuation.definition.block.script.ruko}
        endCaptures:
          1: {name: punctuation.definition.block.script.ruko}
        patterns:
          - include: '#embedded'
          - include: source.r
      - begin: \b((?i:sh))\b\s*(\{)\s*
        end: \s*(\})\s*
        name: meta.brace.script.ruko
        beginCaptures:
          1: {name: storage.type.language.ruko}
          2: {name: punctuation.definition.block.script.ruko}
        endCaptures:
          1: {name: punctuation.definition.block.script.ruko}
        patterns:
          - include: '#embedded'
          - include: source.shell
      - begin: \b((?i:sql))\b\s*(\{)\s*
        end: \s*(\})\s*
        name: meta.brace.script.ruko
        beginCaptures:
          1: {name: storage.type.language.ruko}
          2: {name: punctuation.definition.block.script.ruko}
        endCaptures:
          1: {name: punctuation.definition.block.script.ruko}
        patterns:
          - include: '#embedded'
          - include: source.sql
      - begin: \b((?i:html))\b\s*(\{)\s*
        end: \s*(\})\s*
        name: meta.brace.script.ruko
        beginCaptures:
          1: {name: storage.type.language.ruko}
          2: {name: punctuation.definition.block.script.ruko}
        endCaptures:
          1: {name: punctuation.definition.block.script.ruko}
        patterns:
          - include: '#embedded'
          - include: text.html.basic
      - begin: \b((?i:css))\b\s*(\{)\s*
        end: \s*(\})\s*
        name: meta.brace.script.ruko
        beginCaptures:
          1: {name: storage.type.language.ruko}
          2: {name: punctuation.definition.block.script.ruko}
        endCaptures:
          1: {name: punctuation.definition.block.script.ruko}
        patterns:
          - include: '#embedded'
          - include: source.css
      - begin: \b((?i:json))\b\s*(\{)\s*
        end: \s*(\})\s*
        name: meta.brace.script.ruko
        beginCaptures:
          1: {name: storage.type.language.ruko}
          2: {name: punctuation.definition.block.script.ruko}
        endCaptures:
          1: {name: punctuation.definition.block.script.ruko}
        patterns:
          - include: '#embedded'
          - include: source.json
      - begin: \b((?i:xml))\b\s*(\{)\s*
        end: \s*(\})\s*
        name: meta.brace.script.ruko
        beginCaptures:
          1: {name: storage.type.language.ruko}
          2: {name: punctuation.definition.block.script.ruko}
        endCaptures:
          1: {name: punctuation.definition.block.script.ruko}
        patterns:
          - include: '#embedded'
          - include: text.xml
      - begin: \b((?i:yaml|yml))\b\s*(\{)\s*
        end: \s*(\})\s*
        name: meta.brace.script.ruko
        beginCaptures:
          1: {name: storage.type.language.ruko}
          2: {name: punctuation.definition.block.script.ruko}
        endCaptures:
          1: {name: punctuation.definition.block.script.ruko}
        patterns:
          - include: '#embedded'
          - include: source.yaml
      - begin: \b((?i:markdown|md))\b\s*(\{)\s*
        end: \s*(\})\s*
        name: meta.brace.script.ruko
        beginCaptures:
          1: {name: storage.type.language.ruko}
          2: {name: punctuation.definition.block.script.ruko}
        endCaptures:
          1: {name: punctuation.definition.block.script.ruko}
        patterns:
          - include: '#embedded'
          - include: text.html.markdown
      - begin: \b((?i:latex|tex))\b\s*(\{)\s*
        end: \s*(\})\s*
        name: meta.brace.script.ruko
        beginCaptures:
          1: {name: storage.type.language.ruko}
          2: {name: punctuation.definition.block.script.ruko}
        endCaptures:
          1: {name: punctuation.definition.block.script.ruko}
        patterns:
          - include: '#embedded'
          - include: text.tex.latex
      - begin: \b((?i:was[imt]|wasm|wat))\b\s*(\{)\s*
        end: \s*(\})\s*
        name: meta.brace.script.ruko
        beginCaptures:
          1: {name: storage.type.language.ruko}
          2: {name: punctuation.definition.block.script.ruko}
        endCaptures:
          1: {name: punctuation.definition.block.script.ruko}
        patterns:
          - include: '#embedded'
          - include: source.wat
      - begin: \b((?i:cljs?))\b\s*(\{)\s*
        end: \s*(\})\s*
        name: meta.brace.script.ruko
        beginCaptures:
          1: {name: storage.type.language.ruko}
          2: {name: punctuation.definition.block.script.ruko}
        endCaptures:
          1: {name: punctuation.definition.block.script.ruko}
        patterns:
          - include: '#embedded'
          - include: source.clojure
      - begin: \b((?i:makefile|make))\b\s*(\{)\s*
        end: \s*(\})\s*
        name: meta.brace.script.ruko
        beginCaptures:
          1: {name: storage.type.language.ruko}
          2: {name: punctuation.definition.block.script.ruko}
        endCaptures:
          1: {name: punctuation.definition.block.script.ruko}
        patterns:
          - include: '#embedded'
          - include: source.makefile
      - begin: \b((?i:hs))\b\s*(\{)\s*
        end: \s*(\})\s*
        name: meta.brace.script.ruko
        beginCaptures:
          1: {name: storage.type.language.ruko}
          2: {name: punctuation.definition.block.script.ruko}
        endCaptures:
          1: {name: punctuation.definition.block.script.ruko}
        patterns:
          - include: '#embedded'
          - include: source.haskell
      - begin: \b((?i:ml))\b\s*(\{)\s*
        end: \s*(\})\s*
        name: meta.brace.script.ruko
        beginCaptures:
          1: {name: storage.type.language.ruko}
          2: {name: punctuation.definition.block.script.ruko}
        endCaptures:
          1: {name: punctuation.definition.block.script.ruko}
        patterns:
          - include: '#embedded'
          - include: source.ml
      - begin: \b((?i:ocaml))\b\s*(\{)\s*
        end: \s*(\})\s*
        name: meta.brace.script.ruko
        beginCaptures:
          1: {name: storage.type.language.ruko}
          2: {name: punctuation.definition.block.script.ruko}
        endCaptures:
          1: {name: punctuation.definition.block.script.ruko}
        patterns:
          - include: '#embedded'
          - include: source.ocaml
      - begin: \b((?i:fs))\b\s*(\{)\s*
        end: \s*(\})\s*
        name: meta.brace.script.ruko
        beginCaptures:
          1: {name: storage.type.language.ruko}
          2: {name: punctuation.definition.block.script.ruko}
        endCaptures:
          1: {name: punctuation.definition.block.script.ruko}
        patterns:
          - include: '#embedded'
          - include: source.fsharp

  operator-declarations:
    comment: |
      Operator declarations.
      Format: <prec> <associativity> <fixity> <operator> (-> <return type>)
    patterns:
      - include: '#comments'
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(prec)\b\s*(?:(\d+)|([\p{Pc}\p{L}]\w*))
        captures:
          1: {name: storage.modifier.precedence.ruko}
          2: {name: constant.numeric.integer.ruko}
          3: {name: constant.language.ruko}
      - match: *entity-name
        name: variable.parameter.operator.ruko
      - include: '#type-signature'
      - include: '#suffix-operators'
      - include: '#prefix-operators'
      - include: '#infix-operators'

  style-block:
    begin: \s*(\{)\s*
    end: \s*(\})\s*
    name: meta.brace.style.ruko
    captures:
      1: {name: punctuation.section.property-list.ruko}
    patterns:
      - include: '#style-properties'

  style-pair:
    begin: (?<=^|[;,{\[(])\s*\b([\p{Pd}\w]+)\b(:)\s*
    end: (?=[;,}\])]|$)
    name: meta.property.css.ruko
    beginCaptures:
      1:
        name: support.type.property-name.ruko
        patterns: [{include: '#css-property-names'}]
      2: {name: punctuation.separator.key-value.ruko}
    patterns:
      - include: '#style-property-values'
      - match: \s+
        name: meta.var.expr.ruko

  style-properties:
    patterns:
      - include: '#comments'
      - include: '#style-pair'
      - include: '#embedded'
      - include: '#clauses'
      - include: '#declarations'
      - include: '#keywords'
      - include: '#style-rules'
      - include: '#style-block'
      - include: '#space'
      - include: $self

  style-rules:
    patterns:
      - include: '#type-operators'
      - begin: \s*(\()\s*
        end: \s*(\))
        captures:
          1: {name: punctuation.definition.parameters.ruko}
        patterns:
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(as)\b\s*
            name: keyword.operator.expression.as.ruko
          - include: '#clauses'
          - include: '#constants'
          - include: '#declarations'
          - include: '#expression-keywords'
          - include: '#style-pair'
          - include: '#parameter-variables'
          - include: $self
      - begin: \s*(\[)\s*
        end: \s*(\])\s*
        captures:
          1: {name: punctuation.definition.selector.ruko}
        patterns:
          - include: '#attribute-selectors'
          - include: $self
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(from|to|except|only|as)\b\s*
        name: keyword.operator.expression.ruko
      - include: '#style-selectors'
      - include: '#format-syntax'
      - include: '#tag-names'

  style-selectors:
    patterns:
      - match: \s*([@#&*|%.:~^?]|::)(?=[\w$'"`])
        name: punctuation.definition.entity.ruko
      - match: \s*(?<=\@)[\p{Pc}\p{L}]\w*\b\s*
        name: keyword.control.at-rule.ruko
      - match: \s*(?<=\#)[\p{Pc}\p{L}]\w*\b\s*
        name: entity.other.attribute-name.id.ruko
      - match: \s*(?<=\.)[\p{Pc}\p{L}]\w*\b\s*
        name: entity.other.attribute-name.class.ruko
      - match: \s*(?<=::)[\p{Pc}\p{L}]\w*\b\s*
        name: entity.other.attribute-name.pseudo-component.ruko
      - match: \s*(?<=\~)[\p{Pc}\p{L}]\w*\b\s*
        name: entity.other.attribute-name.key.ruko
      - match: \s*(?<=\&)[\p{Pc}\p{L}]\w*\b\s*
        name: entity.other.attribute-name.ruko entity.name.type.anchor.ruko
      - match: \s*(?<=\*)[\p{Pc}\p{L}]\w*\b\s*
        name: entity.other.attribute-name.ruko entity.name.type.alias.ruko
      - match: \s*(?<=\%)[\p{Pc}\p{L}]\w*\b\s*
        name: entity.other.attribute-name.ruko entity.name.function.ruko
      - match: \s*(?<=\|)[\p{Pc}\p{L}]\w*\b\s*
        name: entity.other.attribute-name.ruko entity.name.method.ruko
      - match: \s*(?<=\:)[\p{Pc}\p{L}]\w*\b\s*
        name: entity.other.attribute-name.ruko entity.name.procedure.ruko
      - match: \s*(?<=\^)[\p{Pc}\p{L}]\w*\b\s*
        name: entity.other.attribute-name.ruko entity.name.property.ruko
      - match: \s*(?<=\?)[\p{Pc}\p{L}]\w*\b\s*
        name: entity.other.attribute-name.ruko entity.name.predicate.ruko

  # Comments

  comments:
    patterns:
      - include: '#block-comments'
      - include: '#line-comments'

  block-comments:
    patterns:
      - begin: \s*(/\*\*)(?![\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]+)
        end: \s*(\*/)
        name: comment.block.documentation.ruko
        captures:
          1: {name: punctuation.definition.comment.ruko}
        patterns:
          - include: '#jsdoc'
          - include: text.html.markdown#inline
          - include: '#nested-jsdoc-comment'
      - begin: \s*(/\*)(?![\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]+)
        end: \s*(\*/)
        name: comment.block.ruko
        captures:
          1: {name: punctuation.definition.comment.ruko}
        patterns:
          - include: text.html.markdown#inline
          - include: '#nested-block-comment'

  line-comments:
    patterns:
      - begin: \s*(///)(?![\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]+)
        end: \s*$
        name: comment.line.documentation.ruko
        captures:
          1: {name: punctuation.definition.comment.ruko}
        patterns:
          - include: '#jsdoc'
          - include: text.html.markdown#inline
      - begin: \s*(//)(?![\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]+)
        end: \s*$
        name: comment.line.number-sign.ruko
        captures:
          1: {name: punctuation.definition.comment.ruko}
        patterns:
          - include: text.html.markdown#inline

  nested-jsdoc-comment:
    begin: (/\*\*?)(?![\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]+)
    end: \s*(\*/)
    name: comment.block.documentation.nested.ruko
    captures:
      1: {name: punctuation.definition.comment.ruko}
    patterns:
      - include: '#jsdoc'
      - include: text.html.markdown#inline
      - include: '#nested-jsdoc-comment'

  nested-block-comment:
    begin: (/\*)(?![\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]+)
    end: \s*(\*/)
    name: comment.block.nested.ruko
    captures:
      1: {name: punctuation.definition.comment.ruko}
    patterns:
      - include: text.html.markdown#inline
      - include: '#nested-block-comment'

  # JSDoc

  jsdoc:
    patterns:
      - include: '#jsdoc-inline-tags'
      - include: '#jsdoc-access'
      - include: '#jsdoc-as-name-path'
      - include: '#jsdoc-simple'
      - include: '#jsdoc-simple-name-path'
      - include: '#jsdoc-module'
      - include: '#jsdoc-type-name'
      - include: '#jsdoc-type-no-name'
      - comment: additional jsdoc V2 keywords
        match: (?<!\w)@(add|api|body|codeend|codestart|demo|download|group|hide|iframe|image|inherits|option|outline|page|parent|signature|tag)\b
        name: storage.type.class.jsdoc
      - comment: additional jsdoc keywords
        match: (?<!\w)@(accessor|alternateClassName|aside|cfg|chainable|docauthor|evented|experimental|ftype|hide|inheritable|localdoc|markdown|mixins|new|override|preventable|ptype|removed|scss mixin|object|template|uses|xtype)\b
        name: storage.type.class.jsdoc

  jsdoc-access:
    comment: '@tag protected....'
    match: (@(access))\s*(private|protected|public)?(?=\s|$)
    captures:
      1: {name: storage.type.class.jsdoc}
      3: {name: storage.modifier.jsdoc}

  jsdoc-module:
    comment: '@tag {optional type} module:file'
    begin: (@(exports|module|listens|requires)\b)\s*(?=({(?:(?>(?:[^\\{}]|\\.)+)|\g<-1>)*\})?\s*(\S*)([\S\s]*))
    end: ^|(?=\*/)|(?=\5$)
    beginCaptures:
      1: {name: storage.type.class.jsdoc}
    patterns:
      - include: '#jsdoc-typedef-scopes'
      - match: (?:(module)(:))?(((?!\*/)\S)+)
        captures:
          1: {name: keyword.module.jsdoc}
          2: {name: punctuation.jsdoc}
          3: {name: string.modulename.jsdoc}

  jsdoc-as-name-path:
    comment: to terminate the block
    begin: (@(borrows|lends)\b)\s*(?=(?!\*/)\S+(?:(?:\s*\bas\b\s*(?!\*/)\S+)?)?([\S\s]*))
    end: ^|(?=\*/)|(?=\3$)
    beginCaptures:
      1: {name: storage.type.class.jsdoc}
    patterns:
      - include: '#jsdoc-name-path-scopes'

  jsdoc-simple:
    comment: '@tag'
    match: (@(abs|author|classdesc|copyright|default|defaultvalue|deprecated|description|desc|example|external|fileoverview|file|global|host|ignore|inheritdoc|inner|instance|license|override|overview|readonly|see|since|stat|summary|todo|tutorial|virtual|variation|version)\b)(?=$|\s)
    captures:
      1: {name: storage.type.class.jsdoc}

  jsdoc-simple-name-path:
    comment: '@tag {opt type} Class#xxx or Class#Event:aaaa etc'
    begin: (@(alias|augments|callback|extends|emits|event|fires|impl|memberof|mixes|name|property|property|this|typedef)\b)\s*(?=({(?:(?>(?:[^\\{}]|\\.)+)|\g<-1>)*\})?\s*\S*([\S*\s]*))
    end: ^|(?=\*/)|(?=\4$)
    beginCaptures:
      1: {name: storage.type.class.jsdoc}
    patterns:
      - include: '#jsdoc-typedef-scopes'
      - include: '#jsdoc-name-path-scopes'

  jsdoc-type-name:
    comment: '@tag {optional type} name'
    begin: (@(arg|argument|class|constant|constructor|constructs|const|function|fn|kind|member|method|mixin|actor|param|var)\b)\s*(?=({(?:(?>(?:[^\\{}]|\\.)+)|\g<-1>)*\})?\s*(((\[(?:(?>[^\[\]]+)|\g<-1>)*\])|\S)+)?([\S\s]*))
    end: ^|(?=\*/)|(?=\7$)
    beginCaptures:
      1: {name: storage.type.class.jsdoc}
    patterns:
      - include: '#jsdoc-typedef-scopes'
      - include: '#jsdoc-name-scopes'

  jsdoc-type-no-name:
    comment: '@tag {types}'
    begin: (@(enum|exception|implements|private|protected|public|returns|return|throws|type)\b)\s*(?=({(?:(?>(?:[^\\{}]|\\.)+)|\g<-1>)*\})?\s*([\S\s]*))
    end: ^|(?=\*/)|(?=\4$)
    beginCaptures:
      1: {name: storage.type.class.jsdoc}
    patterns:
      - include: '#jsdoc-typedef-scopes'

  jsdoc-inline-tags:
    name: meta.tag.inline.jsdoc
    begin: (\[(?:(?>[^\[\]]+)|\g<-1>)*\])?(\{)(?=@)
    end: \s*(\})
    beginCaptures:
      1: {name: string.linktext.jsdoc}
      2: {name: meta.brace.curly.jsdoc}
    endCaptures:
      1: {name: meta.brace.curly.jsdoc}
    patterns:
      - match: (@(link|tutorial))\b([^}]*)
        captures:
          1: {name: storage.type.class.jsdoc}
          3: {name: string.jsdoc}

  jsdoc-typedef-scopes:
    name: entity.name.type.instance.jsdoc
    begin: '{'
    end: '}|^'
    captures:
      0: {name: meta.brace.curly.jsdoc}
    patterns:
      - include: '#jsdoc-typedef-primitives'
      - include: '#jsdoc-name-path-scopes'
      - include: '#jsdoc-typedef-obj'

  jsdoc-typedef-primitives:
    match: \b(null|undefined|boolean|string|number)\b
    captures:
      1: {name: support.type.builtin.primitive.jsdoc}

  jsdoc-typedef-obj:
    comment: typedef object
    begin: '{'
    end: '}|^'
    captures:
      0: {name: meta.brace.curly.jsdoc}
    patterns:
      - include: '#jsdoc-typedef-primitives'
      - match: \b([\p{Pc}\p{L}]\w*)\b\s*(:)
        captures:
          1: {name: variable.other.readwrite.jsdoc}
      - include: '#jsdoc-name-path-scopes'
      - include: '#jsdoc-typedef-obj'

  jsdoc-name-scopes:
    patterns:
      - match: ((?!\*/)[\S&&[^\[\]"']])+
        captures:
          0: {name: variable.other.jsdoc}
      - name: variable.other.jsdoc
        begin: \[
        end: \]|^
        patterns:
          - include: '#jsdoc-string'
          - include: '#jsdoc-name-scopes'

  jsdoc-name-path-scopes:
    patterns:
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(as)\b\s*(?=[\p{Pc}\p{L}])
        captures:
          1: {name: keyword.as.jsdoc}
      - match: \s*(?:([\p{Pc}\p{L}&&\P{Ll}]+\w*)|([\p{Pc}\p{L}]\w*))(?=[\s\-~.#]|$)
        captures:
          1: {name: entity.name.class.jsdoc}
          2: {name: entity.name.function.jsdoc}
      - match: (\.)([\p{Pc}\p{L}]\w*)\b(?=\s|$|\")
        captures:
          1: {name: keyword.operator.accessor.jsdoc}
          2: {name: entity.name.function.method.stat.jsdoc}
      - match: (\#)([\p{Pc}\p{L}]\w*)\b(?=\s|$|\")
        captures:
          1: {name: keyword.operator.accessor.jsdoc}
          2: {name: entity.name.function.method.instance.jsdoc}
      - match: (~|-)([\p{Pc}\p{L}]\w*)\b(?=\s|$|\")
        captures:
          1: {name: keyword.operator.accessor.jsdoc}
          2: {name: entity.name.function.method.inner.jsdoc}
      - match: (\#)(event)(:)
        captures:
          1: {name: keyword.operator.accessor.jsdoc}
          2: {name: keyword.event.jsdoc}
          3: {name: keyword.operator.jsdoc}
      - name: string.method.jsdoc
        begin: \.(?="|')
        end: (?=.)
        applyEndPatternLast: true
        patterns: [{include: '#jsdoc-string'}]

  jsdoc-string:
    name: string.jsdoc
    match: \"(\\"|[^"])*"|'(\\'|[^'])*'

  # Function and method calls

  sigil-function-calls:
    name: meta.function.arguments.ruko
    match: |
      (?x)
      \b
      (
        (?:
          \b
          [\p{Pc}\p{L}]\w* # identifier
          \b
          (?:(?:[?!]?\.|[?!:]:|[?!-]>)=?) # qualified name separator
        )*
        [\p{Pc}\p{L}]\w* # last part of identifier
      )
      \b
      (?=
        \s*
        (?: # function application, composition and piping
            (?: [$@] | <\|+ | <!+ | <[-+]) (?:['"`\w\s]|\#?[(\[{])
          | # C-style function call
            (?:(?:[?!]?\.|[?!:]:|[?!-]>)=?)? \#? [({]
          | # generics
            (?:(?:[?!]?\.|[?!:]:|[?!-]>)=?)? < [\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]* (?:['"`\w]|\#?[(\[{])
          | # macro and destructor calls
            [!~] \#? [({]
          | # strings and symbols
            (?:\w*|[\\$\#%]*)['"] | `\s*(?=\N) | :[\p{Pc}\p{L}]\w*
        )
      )
    captures:
      1: {patterns: [{include: '#function-names'}]}

  function-calls:
    patterns:
      - comment: Normal (bracketed or bracketless) function calls
        name: meta.function.arguments.ruko
        match: |
          (?x)
          (?<=
            (?:
              ^
              | [\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]+ # operator
              | [,;] # delimiter
              | (?: ['"`)}\]\w\s] | \\.): # postfix colon
              | \#? [({\[] # opening bracket
              | ^ # beginning of line
            ) \s*
            | [\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]+ # operator
            | (?:
              (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
              \b
                (?: # keywords
                  [io]n|of|[ai]s|by|has|old|new|del
                  |unset|ref|deref|and|x?or|not
                  |const|let|mut|dyn|va[rl]|use
                  |given|expr|eval|init|comp
                  |func|pro[pc]|type|class|actor|trait
                  |impl|enum|module|model|struct|record
                  |union|iter|macro|query|elem|temp|oper
                  |object|realm|style|script|quote
                  |go|defer|do|with|from|where
                  |if|else|then|guard|when
                  |for|loop|while|goto|move
                  |try|throw|catch|switch
                  |match|case|pass|def|defer
                  |break|skip|redo|retry
                  |return|yield|await|scope
                  |import|export|intern|extern
                  |debug|assert|check|decl
                )
              \b
            ) \s*
          ) \s*
          \b
          (
            # ignore all keywords
            (?!
              (?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b
              (?: # keywords
                [io]n|of|[ai]s|by|has|old|new|del
                |unset|ref|deref|and|x?or|not
                |const|let|mut|dyn|va[rl]|use
                |given|expr|eval|init|comp
                |func|pro[pc]|type|class|actor|trait
                |impl|enum|module|model|struct|record
                |union|iter|macro|query|elem|temp|oper
                |object|realm|style|script|quote
                |go|defer|do|with|from|where
                |if|else|then|guard|when
                |for|loop|while|goto|move
                |try|throw|catch|switch
                |match|case|pass|def|defer
                |break|skip|redo|retry
                |return|yield|await|scope
                |import|export|intern|extern
                |debug|assert|check|decl
              )
              \b
            )
            (?:
              \b
              [\p{Pc}\p{L}]\w* # identifier
              \b
              (?:(?:[?!]?\.|[?!:]:|[?!-]>)=?) # qualified name separator
            )*
            [\p{Pc}\p{L}]\w* # last part of identifier
          )
          \b
          (?! # infix operator
            \s+ 
              (?:[\p{P}\p{S}&&[^,;'"`/({\[)}\]\p{Pc}]]+
              (?:
                [\p{P}\p{S}]*
                [\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]+
              )?
              (?=\s|$)
            )
          )
          (?=
            (?:
              \s* (?: # function name
                \b
                # ignore all keywords
                (?!
                  (?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b
                  (?: # keywords
                    [io]n|of|[ai]s|by|has|old|new|del
                    |unset|ref|deref|and|x?or|not
                    |const|let|mut|dyn|va[rl]|use
                    |given|expr|eval|init|comp
                    |func|pro[pc]|type|class|actor|trait
                    |impl|enum|module|model|struct|record
                    |union|iter|macro|query|elem|temp|oper
                    |object|realm|style|script|quote
                    |go|defer|do|with|from|where
                    |if|else|then|guard|when
                    |for|loop|while|goto|move
                    |try|throw|catch|switch
                    |match|case|pass|def|defer
                    |break|skip|redo|retry
                    |return|yield|await|scope
                    |import|export|intern|extern
                    |debug|assert|check|decl
                  )
                  \b
                )
                \b
                [\p{Pc}\p{L}]\w* # identifier
                \b
              ) (?! : # avoid matching labels/message passing here
                (?:
                    (?:\w*|[\\$\#%]*)['"] # quoted string literals
                  | `\s*(?=\N) # unquoted string literals 
                  | :[\p{Pc}\p{L}]\w* # symbols
                  | \d # numbers
                  | \s \#? [(\[] # opening brackets
                  | \s [\p{P}\p{S}&&[^.,;'"`/\\({\[)}\]\p{Pc}]] # prefix operators except / and \
                      [\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]* # followed by other operators
                    (?: ['"`\w] | \#?[(\[{]) # literal or opening bracket
                  | \s # XML tag component name
                    <[\p{Pc}\p{L}(]
                  | \s # regexp literal
                    /[^/*\s]
                  | \s \|(?: \#?[(\[{] )? # opening bracket
                    (?: [;,] \s* )* # optional separators
                    (?:
                      ((?:[*&%@^!~?\\\-+]|\.{3})*) # any sigils
                      (\b[\p{Pc}\p{L}]\w*\b) # identifier
                      ([!?]*) # optional sigils
                      \s*
                    )+ (?: \#? [)\]}] )? # closing bracket
                )
              )
              | \s* (?: # function name
                \b
                # ignore all keywords
                (?!
                  (?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b
                  (?: # keywords
                    [io]n|of|[ai]s|by|has|old|new|del
                    |unset|ref|deref|and|x?or|not
                    |const|let|mut|dyn|va[rl]|use
                    |given|expr|eval|init|comp
                    |func|pro[pc]|type|class|actor|trait
                    |impl|enum|module|model|struct|record
                    |union|iter|macro|query|elem|temp|oper
                    |object|realm|style|script|quote
                    |go|defer|do|with|from|where
                    |if|else|then|guard|when
                    |for|loop|while|goto|move
                    |try|throw|catch|switch
                    |match|case|pass|def|defer
                    |break|skip|redo|retry
                    |return|yield|await|scope
                    |import|export|intern|extern
                    |debug|assert|check|decl
                  )
                  \b
                )
                \b
                [\p{Pc}\p{L}]\w* # identifier
                \b
              )(?= :(?:\s+|$) ) # beginning of block
              | \s (?:<[-=]?\||<\+) (?:['"`\w\s]|\#?[(\[{]) 
              | (?:(?:[?!]|[?!:]:|[?!-]>)=?)? \#? [({] # C-style function call
              | (?:(?:[?!]|[?!:]:|[?!-]>)=?)? < [\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]* (?:['"`\w]|\#?[(\[{]) # generics
              | [!~] \#? [({] # macro and destructor calls
              | \s* (?:
                  (?:\w*|[\\$\#%]*)['"] # quoted string literals
                | `\s*(?=\N) # unquoted string literals 
                | :[\p{Pc}\p{L}]\w* # symbols
                | \d # numbers
                | \s \#? [(\[] # opening brackets
                | \s [\p{P}\p{S}&&[^.,;'"`/\\({\[)}\]\p{Pc}]] # prefix operators except / and \
                    [\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]* # followed by other operators
                  (?: ['"`\w] | \#?[(\[{]) # literal or opening bracket
                | \s # XML tag component name
                  <[\p{Pc}\p{L}(]
                | \s # regexp literal
                  /[^/*\s]
                | \s \|(?: \#?[(\[{] )? # opening bracket
                  (?: [;,] \s* )* # optional separators
                  (?:
                    ((?:[*&%@^!~?\\\-+]|\.{3})*) # any sigils
                    (\b[\p{Pc}\p{L}]\w*\b) # identifier
                    ([!?]*) # optional sigils
                    \s*
                  )+ (?: \#? [)\]}] )? # closing bracket
              )
            )
          )
        captures:
          1:
            name: meta.function.name.ruko
            patterns: [{include: '#function-names'}]
      - comment: Piped function calls
        name: meta.function.arguments.ruko
        match: |
          (?x)
          (?<=
            \s* # opening
            (?:\|[-=]?>|\+>) # operator
            \s*
          )
          \b
          (
            # ignore all keywords
            (?!
              (?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b
              (?: # keywords
                [io]n|of|[ai]s|by|has|old|new|del
                |unset|ref|deref|and|x?or|not
                |const|let|mut|dyn|va[rl]|use
                |given|expr|eval|init|comp
                |func|pro[pc]|type|class|actor|trait
                |impl|enum|module|model|struct|record
                |union|iter|macro|query|elem|temp|oper
                |object|realm|style|script|quote
                |go|defer|do|with|from|where
                |if|else|then|guard|when
                |for|loop|while|goto|move
                |try|throw|catch|switch
                |match|case|pass|def|defer
                |break|skip|redo|retry
                |return|yield|await|scope
                |import|export|intern|extern
                |debug|assert|check|decl
              )
              \b
            )
            (?:
              \b
              [\p{Pc}\p{L}]\w* # identifier
              \b
              (?:(?:[?!]?\.|[?!:]:|[?!-]>)=?) # qualified name separator
            )*
            [\p{Pc}\p{L}]\w* # last part of identifier
          )
          \b
        captures:
          1:
            name: meta.function.name.ruko
            patterns: [{include: '#function-names'}]

  embedded-function-calls:
    name: meta.function.name.ruko
    match: |
      (?x)
      (?:
        (?<=
          (?:^ | [,;'"`)\]}\w\s] | \#?[(\[{] | \\.) # literal, bracket or space
          (?: [?!]?\. | [?!:]: | [?!-]> ) =? # accessor or qualified name separator
        )
        \b # methods
          (?:
            # Leading underscore
            (\p{Pc}+\w*(?!\p{Pc}+))
          | # Train case
            ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)
          | # Pascal case
            ((?:[\p{Pc}\p{L}&&\P{Ll}][\w&&\P{Lu}]*)+)
          | # Camel or kebab case
            ([\p{Pc}\p{L}]\w*)
          )
        \b
        (?= # opening macro, destructor, or function call
            [!~]? \#? [({]
          | generics
            (?: [?!]?\. | [?!:]: | [?!-]> ) <
        )
        |
        (?<= ^ # beginning of line
          | (?: [,;'"`)}\]\w\s] | \#?[(\[{] | \\.) # literal
          (?: # operators
            [\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]+
          )?
        ) \b
          (?: # Regular variables
            # Leading underscore
            (\p{Pc}+\w*(?!\p{Pc}+))
          | # Train case
            ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)
          | # Pascal case
            ((?:[\p{Pc}\p{L}&&\P{Ll}][\w&&\P{Lu}]*)+)
          | # Camel or kebab case
            ([\p{Pc}\p{L}]\w*)
          )
        \b
          (?= # opening macro, destructor, or function call
              [!~]? \#? [({]
            | generics
              (?: [?!]?\. | [?!:]: | [?!-]> ) <
          )
      )
    captures:
      1:
        patterns: &builtin-names
          - include: '#type-names'
          - include: '#support-functions'
        name: entity.name.tag.ruko
      2:
        patterns: *builtin-names
        name: entity.name.tag.ruko support.class.component.ruko
      3:
        patterns: *builtin-names
        name: entity.name.class.builtin.ruko
      4:
        patterns: *builtin-names
        name: entity.name.function.member.ruko
      5:
        patterns: *builtin-names
        name: entity.name.function.tagged-template.ruko
      6:
        patterns: *builtin-names
        name: entity.name.type.ruko
      7:
        patterns: *builtin-names
        name: entity.name.class.ruko
      8:
        patterns: *builtin-names
        name: entity.name.function.ruko

  function-names:
    patterns:
      - &function-names
        name: meta.function.name.ruko
        match: |
          (?x)
          (?:
            (?<=
              (?: [,;'"`)\]}\w] | \#?[(\[{] | \\.?) # literal, bracket or space
              (?: [?!]?\. | [?!:]: | [?!-]> ) =? # accessor or qualified name separator
            )
            \b # methods
              (?:
                # Leading underscore
                (\p{Pc}+\w*(?!\p{Pc}+))
              | # Train case
                ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)
              | # Pascal case
                ((?:[\p{Pc}\p{L}&&\P{Ll}][\w&&\P{Lu}]*)+)
              | # Camel or kebab case
                ([\p{Pc}\p{L}]\w*)
              )
            \b
            (?=
                $ # end of line
              | (?: # operators
                  <\|{1,3} | <[-+] | \|{1,3}> | \+> | [$@]
                )?
                (?:[,;'"`)}\]\w\s]|\#?[(\[{]|\\.)
            )
            |
            (?<=
               ^ # beginning of line
                [\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]* # operators
              | (?: [,;'"`)}\]\w\s] | \#?[(\[{] | \\.) # literal, bracket or space
                [\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]* # operators
            ) \b
              (?: # Regular variables
                # Leading underscore
                (\p{Pc}+\w*(?!\p{Pc}+))
              | # Train case
                ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)
              | # Pascal case
                ((?:[\p{Pc}\p{L}&&\P{Ll}][\w&&\P{Lu}]*)+)
              | # Camel or kebab case
                ([\p{Pc}\p{L}]\w*)
              )
            \b
              (?=
                  $ # end of line
                | (?: # operators
                    <\|{1,3} | <[-+] | \|{1,3}> | \+> | [$@]
                  )?
                  (?:[,;'"`)}\]\w\s]|\#?[(\[{]|\\.)
              )
          )
        captures:
          1:
            patterns: *builtin-names
            name: entity.name.tag.ruko
          2:
            patterns: *builtin-names
            name: entity.name.tag.ruko support.class.component.ruko
          3:
            patterns: *builtin-names
            name: entity.name.class.builtin.ruko
          4:
            patterns: *builtin-names
            name: entity.name.function.member.ruko
          5:
            patterns: *builtin-names
            name: entity.name.function.tagged-template.ruko
          6:
            patterns: *builtin-names
            name: entity.name.type.ruko
          7:
            patterns: *builtin-names
            name: entity.name.class.ruko
          8:
            patterns: *builtin-names
            name: entity.name.function.ruko
      - include: '#variables'
      - include: '#primary-operators'

  # Variables

  parameter-variables:
    patterns:
      - applyEndPatternLast: true
        name: meta.type.ruko
        begin: (?<=(?:[)}\]\w'"`]|\\.)>*)(:)(?=$|<*(?:['"`\w\s]|\#?[(\[{]))
        end: (?=)|$
        beginCaptures:
          1: {name: punctuation.definition.annotation.ruko}
        patterns: [{include: '#types'}]
      - match: |
          (?x)
          (?<=
            (?:
              ^ # SOL
              | (?:^ | [^|]) \| # open pipe
              | \#?[({\[] # open bracket
              | [;,] # separator
              | [(|]\. \s # uncurried function
              | (?:^ | [,;'"`)}\]\s] | \#?[(\[{] | \\.) # literal, bracket or space
                \b (?: # declaration keywords
                  const|let|mut|dyn|va[rl]|use
                  |given|expr|eval|init|comp
                  |func|pro[pc]|type|class|actor|trait
                  |impl|enum|module|model|struct|record
                  |union|iter|macro|query|elem|temp|oper
                  |object|realm|style|script|quote
                  |given|use|as
                ) \b
                (?:$|[,;'"`)}\]\s] | \#?[(\[{] | \\.) 
            ) \s*
          )

          (?:
            \s*
            ([*&%@^!~?\\\-+]*) # any sigils
            (\b[\p{Pc}\p{L}]\w*\b) # identifier
            ([!?]*) # optional sigils
            \s*
          )*

          (?:
            \s*
            ((?:[*&%@^!~?\\\-+]|\.{3})*) # any sigils
            (\b[\p{Pc}\p{L}]\w*\b) # identifier
            ([!?]*) # optional sigils
            \s*
          )

          (?=
            $ # EOL
            | # close bracket or pipe
              \s* [)}\]]
            | # pipe
              \s* \|:? (?:$|['"`<\w\s)\]}]|\#?[(\[{]|\\.)
            | # separator
              \s* [;,]
            | # as keyword (aliasing)
              \s*
              (?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(as)\b
              \s*
            | # type specifier and assignment
              (?::|[?:]?=) \s* (?:[*&%@^!~?\\\-+]*) (?:['"`\w]|\#?[(\[{])
            | \s+ (?::|[?:]?=) \s+ (?:[*&%@^!~?\\\-+]*) (?:['"`\w]|\#?[(\[{])
          )
        captures:
          1:
            name: keyword.operator.prefix.ruko
            patterns: [{include: '#parameter-type-operators'}]
          2:
            name: storage.type.ruko
            patterns:
              - include: '#declaration-keywords'
              - include: '#modifiers'
          3:
            name: keyword.operator.suffix.ruko
            patterns: [{include: '#parameter-type-operators'}]
          4:
            name: keyword.operator.prefix.ruko
            patterns: [{include: '#parameter-type-operators'}]
          5:
            name: variable.parameter.ruko
            patterns: [{include: '#constants'}]
          6:
            name: keyword.operator.suffix.ruko
            patterns: [{include: '#parameter-type-operators'}]

  placeholder-variables:
    patterns:
      - match: (?i)\s*[?!][\p{Pc}\p{L}]\w*\b\s*
        name: variable.parameter.optional.ruko
      - match: (?i)\s*\*\*?[?!]?[\p{Pc}\p{L}]\w*\b\s*
        name: variable.parameter.spread.ruko
      - match: (?i)\s*~~?[?!]?[\p{Pc}\p{L}]\w*\b\s*
        name: variable.parameter.reference.ruko
      - match: (?i)\s*&[?!]?[\p{Pc}\p{L}]\w*\b\s*
        name: variable.parameter.reference.ruko
      - match: (?i)\s*%[?!]?[\p{Pc}\p{L}]\w*\b\s*
        name: variable.parameter.other.ruko
      - match: (?i)\s*\b[\p{Pc}\p{L}]\w*\b\s*
        name: variable.parameter.ruko

  variables:
    patterns:
      - match: |
          (?x)
          (?<=
            \b # qualified name
              [\p{Pc}\p{L}]\w* # identifier
              (?:(?:[?!]?\.|[?!:]:)=?)
            \b
          )
          (?:\d\w*)
        name: variable.other.index.ruko
      - comment: 4 types of variables - _lead_underscore, UPPERCASE, PascalCase, camelCase
        match: |
          (?x) \b

          (?:
            (?<=
              (?: ['"`)\]}\w] | \\.) \s* # literal, bracket or space
              (?: [?!]?\. | [?!:]: | [?!-]> ) =? # accessor or qualified name separator
            )
            \b # methods
            (?: # Properties
                # Leading underscore
                (\p{Pc}+\w*\b(?!\p{Pc}+))
              | # Train case
                ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)
              | # Pascal case
                ((?:[\p{Pc}\p{L}&&\P{Ll}][\w&&\P{Lu}]*)+)
              | # Camel or kebab case
                ([\p{Pc}\p{L}]\w*)
            )
            |
            (?<!
              (?: [,;'"`)}\]\w] | \\.) # literal, bracket or space
              (?: [\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]+ ) # operators
            )
            \b
            (?: # Objects
                # Leading underscore
                (\p{Pc}+\w*\b(?!\p{Pc}+))
              | # Train case
                ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)
              | # Pascal case
                ((?:[\p{Pc}\p{L}&&\P{Ll}][\w&&\P{Lu}]*)+)
              | # Camel or kebab case
                ([\p{Pc}\p{L}]\w*)
            )
            (?! [?!]?\.\.+ ) # not a range operator
            (?= 
                (?: [?!]?\. | [?!:]: | [?!-]> ) =? # accessor or qualified name separator
              | \#?\[ # or array access
            )
            |
            (?: # Regular variables
                # Leading underscore
                (\p{Pc}+\w*\b(?!\p{Pc}+))
              | # Train case
                ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)
              | # Pascal case
                ((?:[\p{Pc}\p{L}&&\P{Ll}][\w&&\P{Lu}]*)+)
              | # Camel or kebab case
                ([\p{Pc}\p{L}]\w*)
            )
          )\b
        captures:
          1: {name: variable.other.property.dynamic.ruko}
          2: {name: variable.other.constant.property.ruko}
          3: {name: variable.other.property.stat.ruko}
          4: {name: variable.other.property.ruko}
          5: {name: variable.other.global.ruko}
          6: {name: variable.other.constant.object.ruko}
          7: {name: variable.other.class.stat.ruko}
          8: {name: variable.other.object.ruko}
          9: {name: variable.other.dollar.ruko}
          10: {name: variable.other.constant.ruko}
          11: {name: variable.other.class.ruko}
          12: {name: variable.other.readwrite.ruko}

  # Operators

  operators:
    patterns:
      - include: '#named-infix-operators'
      - include: '#special-operators'
      - include: '#infix-operators'
      - include: '#primary-operators'
      - include: '#suffix-operators'
      - include: '#prefix-operators'

  special-operators:
    patterns:
      - match: (?<=^|[,;]|\#?[(\[{])\s*(\.\.\.?)(?=[\p{P}\p{S}&&[^,;'"`\\({\[)}\]\p{Pc}]]*(?:['"`\w]|\#?[(\[{]))
        captures:
          1: {name: keyword.operator.spread.ruko}
      - match: (?<=>|\w)(!)(?=\#?[({])
        captures:
          1: {name: keyword.operator.macro.ruko}
      - match: (?<=>|\w)(~)(?=\#?[({])
        captures:
          1: {name: keyword.operator.destructor.ruko}

  named-infix-operators:
    comment: 'Named infix operators: x \fn\ y'
    contentName: keyword.operator.infix.named.ruko
    begin: (?<=['"`)}\]\w\s]|\\.)(\\)\s*
    end: \s*(\\)(?=$|['"`\w\s]|\#?[(\[{])
    captures:
      1: {name: punctuation.definition.operator.ruko}
    patterns:
      - match: (?<=\\?)([?!:]:|[?!]?\.|[?!-]>)([\p{Pc}\p{L}]\w*)(?!(?:[?!:]:|[?!]?\.|[?!-]>))
        captures:
          1:
            name: punctuation.separator.accessor.ruko
            patterns: [{include: '#accessor-operators'}]
          2:
            name: entity.name.function.member.ruko
            patterns: [{include: '#function-names'}]
      - match: |
          (?x)
          (?<=\\?)
          ( # function name
            \b
            # ignore all keywords
            (?!
              (?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b
              (?: # keywords
                [io]n|of|[ai]s|by|has|old|new|del
                |unset|ref|deref|and|x?or|not
                |const|let|mut|dyn|va[rl]|use
                |given|expr|eval|init|comp
                |func|pro[pc]|type|class|actor|trait
                |impl|enum|module|model|struct|record
                |union|iter|macro|query|elem|temp|oper
                |object|realm|style|script|quote
                |go|defer|do|with|from|where
                |if|else|then|guard|when
                |for|loop|while|goto|move
                |try|throw|catch|switch
                |match|case|pass|def|defer
                |break|skip|redo|retry
                |return|yield|await|scope
                |import|export|intern|extern
                |debug|assert|check|decl
              )
              \b
            )
            \b
            [\p{Pc}\p{L}]\w* # identifier
            \b
          )
          (?=\\)
        captures:
          1:
            name: entity.name.function.ruko
            patterns: [{include: '#function-names'}]
      - include: '#operators'
      - include: $self

  infix-operators:
    comment: Infix operators - e.g., x + y
    patterns:
      - match: (?<=^|[\s({\[])(?:\?[.:>]=?)(?=$|[)}\]\s])
        name: keyword.operator.optional.ruko
      - match: (?<=^|[\s({\[])(?:![.:>]=?)(?=$|[)}\]\s])
        name: keyword.operator.assert.ruko
      - match: (?<=^|[\s({\[])(?:(::|\.|->)=?)(?=$|[)}\]\s])
        name: keyword.operator.accessor.ruko
      - match: (?<=^|[\s({\[])(?:[\p{P}\p{S}&&[^~<=>.,:;!''"`({\[)}\]\p{Pc}]][\p{P}\p{S}&&[^,;''"`({\[)}\]\p{Pc}]]*=)(?=$|[)}\]\s])
        name: keyword.operator.assignment.augmented.ruko
      - match: (?<=^|[\s({\[])(?:&&|\|\||\^\^|⊻⊻)(?=$|[)}\]\s])
        name: keyword.operator.logical.ruko
      - match: (?<=^|[\s({\[])(?:&|\||\^|⊻)(?=$|[)}\]\s])
        name: keyword.operator.bitwise.ruko
      - match: (?<=^|[\s({\[])(?:<<[<>]?|[<>]?>>)(?=$|[)}\]\s])
        name: keyword.operator.bitwise.shift.ruko
      - match: (?<=^|[\s({\[])(?:\+\+|--)(?=$|[)}\]\s])
        name: keyword.operator.successor.ruko
      - match: (?<=^|[\s({\[])(?:[+-][%|]?|\*\*?[%|]?|~?/|%%?)(?=$|[)}\]\s])
        name: keyword.operator.arithmetic.ruko
      - match: (?<=^|[\s({\[])(?:\+\+|\-\-|\+|\-|−|¦|\||⊕|⊖|⊞|⊟|∪|∨|⊔|±|∓|∔|∸|≏|⊎|⊻|⊽|⋎|⋓|⟇|⧺|⧻|⨈|⨢|⨣|⨤|⨥|⨦|⨧|⨨|⨩|⨪|⨫|⨬|⨭|⨮|⨹|⨺|⩁|⩂|⩅|⩊|⩌|⩏|⩐|⩒|⩔|⩖|⩗|⩛|⩝|⩡|⩢|⩣|\*|//?|⌿|÷|%|·|·|⋅|∘|×|\\|∩|∧|⊗|⊘|⊙|⊚|⊛|⊠|⊡|⊓|∗|∙|∤|⅋|≀|⊼|⋄|⋆|⋇|⋉|⋊|⋋|⋌|⋏|⋒|⟑|⦸|⦼|⦾|⦿|⧶|⧷|⨇|⨰|⨱|⨲|⨳|⨴|⨵|⨶|⨷|⨸|⨻|⨼|⨽|⩀|⩃|⩄|⩋|⩍|⩎|⩑|⩓|⩕|⩘|⩚|⩜|⩞|⩟|⩠|⫛|⊍|▷|⨝|⟕|⟖|⟗|⨟|↑|↓|⇵|⟰|⟱|⤈|⤉|⤊|⤋|⤒|⤓|⥉|⥌|⥍|⥏|⥑|⥔|⥕|⥘|⥙|⥜|⥝|⥠|⥡|⥣|⥥|⥮|⥯|￪|￬|√|∛|∜|⋆|±|∓)(?=$|[)}\]\s])
        name: keyword.operator.arithmetic.ruko
      - match: (?<=^|[\s({\[])(?:<-->|->|-->|<--|←|→|↔|↚|↛|↞|↠|↢|↣|↦|↤|↮|⇎|⇍|⇏|⇐|⇒|⇔|⇴|⇶|⇷|⇸|⇹|⇺|⇻|⇼|⇽|⇾|⇿|⟵|⟶|⟷|⟹|⟺|⟻|⟼|⟽|⟾|⟿|⤀|⤁|⤂|⤃|⤄|⤅|⤆|⤇|⤌|⤍|⤎|⤏|⤐|⤑|⤔|⤕|⤖|⤗|⤘|⤝|⤞|⤟|⤠|⥄|⥅|⥆|⥇|⥈|⥊|⥋|⥎|⥐|⥒|⥓|⥖|⥗|⥚|⥛|⥞|⥟|⥢|⥤|⥦|⥧|⥨|⥩|⥪|⥫|⥬|⥭|⥰|⧴|⬱|⬰|⬲|⬳|⬴|⬵|⬶|⬷|⬸|⬹|⬺|⬻|⬼|⬽|⬾|⬿|⭀|⭁|⭂|⭃|⥷|⭄|⥺|⭇|⭈|⭉|⭊|⭋|⭌|￩|￫|⇜|⇝|↜|↝|↩|↪|↫|↬|↼|↽|⇀|⇁|⇄|⇆|⇇|⇉|⇋|⇌|⇚|⇛|⇠|⇢|↷|↶|↺|↻|=>)(?=$|[)}\]\s])
        name: keyword.operator.arrow.ruko
      - match: (?<=^|[\s({\[])(?:<[-=]?\||\|[-=]?>)(?=$|[)}\]\s])
        name: keyword.operator.pipeline.ruko
      - match: (?<=^|[\s({\[])(?:<\+|\+>|∘)(?=$|[)}\]\s])
        name: keyword.operator.compose.ruko
      - match: (?<=^|[\s({\[])(?:[<>][:!]|[:!][<>])(?=$|[)}\]\s])
        name: keyword.operator.class.ruko
      - match: (?<=^|[\s({\[])(?:[>.]\.[.<]|[=.]\.[.=]|\.\.)(?=$|[)}\]\s])
        name: keyword.operator.range.ruko
      - match: (?<=^|[\s({\[])(?:[<>]=?|<=?>)(?=$|[)}\]\s])
        name: keyword.operator.relational.ruko
      - match: (?<=^|[\s({\[])(?:(?<!<)<=|(?<!>)>=|>|<|≥|≤|≢|∈|∉|∋|∌|⊆|⊈|⊂|⊄|⊊|∝|∊|∍|∥|∦|∷|∺|∻|∽|∾|≁|≃|≂|≄|≅|≆|≇|≈|≉|≊|≋|≌|≍|≎|≐|≑|≒|≓|≖|≗|≘|≙|≚|≛|≜|≝|≞|≟|≣|≦|≧|≨|≩|≪|≫|≬|≭|≮|≯|≰|≱|≲|≳|≴|≵|≶|≷|≸|≹|≺|≻|≼|≽|≾|≿|⊀|⊁|⊃|⊅|⊇|⊉|⊋|⊏|⊐|⊑|⊒|⊜|⊩|⊬|⊮|⊰|⊱|⊲|⊳|⊴|⊵|⊶|⊷|⋍|⋐|⋑|⋕|⋖|⋗|⋘|⋙|⋚|⋛|⋜|⋝|⋞|⋟|⋠|⋡|⋢|⋣|⋤|⋥|⋦|⋧|⋨|⋩|⋪|⋫|⋬|⋭|⋲|⋳|⋴|⋵|⋶|⋷|⋸|⋹|⋺|⋻|⋼|⋽|⋾|⋿|⟈|⟉|⟒|⦷|⧀|⧁|⧡|⧣|⧤|⧥|⩦|⩧|⩪|⩫|⩬|⩭|⩮|⩯|⩰|⩱|⩲|⩳|⩵|⩶|⩷|⩸|⩹|⩺|⩻|⩼|⩽|⩾|⩿|⪀|⪁|⪂|⪃|⪄|⪅|⪆|⪇|⪈|⪉|⪊|⪋|⪌|⪍|⪎|⪏|⪐|⪑|⪒|⪓|⪔|⪕|⪖|⪗|⪘|⪙|⪚|⪛|⪜|⪝|⪞|⪟|⪠|⪡|⪢|⪣|⪤|⪥|⪦|⪧|⪨|⪩|⪪|⪫|⪬|⪭|⪮|⪯|⪰|⪱|⪲|⪳|⪴|⪵|⪶|⪷|⪸|⪹|⪺|⪻|⪼|⪽|⪾|⪿|⫀|⫁|⫂|⫃|⫄|⫅|⫆|⫇|⫈|⫉|⫊|⫋|⫌|⫍|⫎|⫏|⫐|⫑|⫒|⫓|⫔|⫕|⫖|⫗|⫘|⫙|⫷|⫸|⫹|⫺|⊢|⊣|⟂|⫪|⫫)(?=$|[)}\]\s])
        name: keyword.operator.relational.ruko
      - match: (?<=^|[\s({\[])(?:\.|\.\.+|…|⁝|⋮|⋱|⋰|⋯)(?=$|[)}\]\s])
        name: keyword.operator.dots.ruko
      - match: (?<=^|[\s({\[])(?:[!=]==?)(?=$|[)}\]\s])
        name: keyword.operator.comparison.ruko
      - match: (?<=^|[\s({\[])(?:~[=!]|[=!]~|[=>]<)(?=$|[)}\]\s])
        name: keyword.operator.similarity.ruko
      - match: (?<=^|[\s({\[])(?:<[/*|+$:]>?|[/*|+$:]>)(?=$|[)}\]\s])
        name: keyword.operator.function.ruko
      - match: (?<=^|[\s({\[])(?:\?\?)(?=$|[)}\]\s])
        name: keyword.operator.null-coalescing.ruko
      - match: (?<=^|[\s({\[])(?:!!)(?=$|[)}\]\s])
        name: keyword.operator.coalescing.ruko
      - match: (?<=^|[\s({\[])(?:\?:?)(?=$|[)}\]\s])
        name: keyword.operator.conditional.ruko
      - match: (?<=^|[\s({\[])(?:!:?)(?=$|[)}\]\s])
        name: keyword.operator.ternary.ruko
      - match: (?<=^|[\s({\[])(?:[.:$]|:::?)(?=$|[)}\]\s])
        name: keyword.operator.macro.ruko
      - match: (?<=^|[\s({\[])(?::?=)(?=$|[)}\]\s])
        name: keyword.operator.assignment.ruko
      - match: (?<=^|[\s({\[])(?:=+>|<=+)(?=$|[)}\]\s])
        name: keyword.operator.arrow.fat.ruko
      - match: (?<=^|[\s({\[])(?:-+>|<-+)(?=$|[)}\]\s])
        name: keyword.operator.arrow.skinny.ruko
      - match: (?<=^|[\s({\[])(?:~+>|<~+)(?=$|[)}\]\s])
        name: keyword.operator.arrow.wavy.ruko
      - match: (?<=^|[\s({\[])(?:[&|^~][\p{P}\p{S}&&[^,;''"`({\[)}\]\p{Pc}]]+)(?=$|[)}\]\s])
        name: keyword.operator.logical.custom.ruko
      - match: (?<=^|[\s({\[])(?:[-+*/%][\p{P}\p{S}&&[^,;''"`({\[)}\]\p{Pc}]]+)(?=$|[)}\]\s])
        name: keyword.operator.arithmetic.custom.ruko
      - match: (?<=^|[\s({\[])(?:[@:][\p{P}\p{S}&&[^,;''"`({\[)}\]\p{Pc}]]+)(?=$|[)}\]\s])
        name: keyword.operator.prototype.custom.ruko
      - match: (?<=^|[\s({\[])(?:[.][\p{P}\p{S}&&[^,;''"`({\[)}\]\p{Pc}]]+)(?=$|[)}\]\s])
        name: keyword.operator.accessor.custom.ruko
      - match: (?<=^|[\s({\[])(?:[=!][\p{P}\p{S}&&[^,;''"`({\[)}\]\p{Pc}]]+)(?=$|[)}\]\s])
        name: keyword.operator.comparison.custom.ruko
      - match: (?<=^|[\s({\[])(?:[<>][\p{P}\p{S}&&[^,;''"`({\[)}\]\p{Pc}]]+)(?=$|[)}\]\s])
        name: keyword.operator.relational.custom.ruko
      - match: (?<=^|[\s({\[])(?:[?#][\p{P}\p{S}&&[^,;''"`({\[)}\]\p{Pc}]]+)(?=$|[)}\]\s])
        name: keyword.operator.private.custom.ruko
      - match: (?<=^|[\s({\[])(?:\p{Sm}+)(?=$|[)}\]\s])
        name: keyword.operator.math.custom.ruko
      - match: (?<=^|[\s({\[])(?:\p{Sc}+)(?=$|[)}\]\s])
        name: keyword.operator.currency.custom.ruko
      - match: (?<=^|[\s({\[])(?:[!#-&*+\-./:-@\\^|~¡-©«-±´¶·¸»¿×÷]+)(?=$|[)}\]\s])
        name: keyword.operator.ascii.custom.ruko
      - match: (?<=^|[\s({\[])([\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]+([\p{P}\p{S}]*[\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]+)?)(?=$|[)}\]\s])
        name: keyword.operator.infix.ruko

  primary-operators:
    comment: Primary operators - x+y (without spaces)
    patterns:
      - match: (?<=['"`)}\]\w]|\\.)(?:\?[.:>]=?)(?=(?:['"`\w]|\#?[(\[{]))
        name: keyword.operator.optional.ruko
      - match: (?<=['"`)}\]\w]|\\.)(?:![.:>]=?)(?=(?:['"`\w]|\#?[(\[{]))
        name: keyword.operator.assert.ruko
      - match: (?<=['"`)}\]\w]|\\.)(?:(::|\.|->)=?)(?=(?:['"`\w]|\#?[(\[{]))
        name: keyword.operator.accessor.ruko
      - match: (?<=['"`)}\]\w]|\\.)(?:[\p{P}\p{S}&&[^~<=>.,:;!''"`({\[)}\]\p{Pc}]][\p{P}\p{S}&&[^,;''"`({\[)}\]\p{Pc}]]*=)(?=(?:['"`\w]|\#?[(\[{]))
        name: keyword.operator.assignment.augmented.ruko
      - match: (?<=['"`)}\]\w]|\\.)(?:&&|\|\||\^\^|⊻⊻)(?=(?:['"`\w]|\#?[(\[{]))
        name: keyword.operator.logical.ruko
      - match: (?<=['"`)}\]\w]|\\.)(?:&|\||\^|⊻)(?=(?:['"`\w]|\#?[(\[{]))
        name: keyword.operator.bitwise.ruko
      - match: (?<=['"`)}\]\w]|\\.)(?:<<[<>]?|[<>]?>>)(?=(?:['"`\w]|\#?[(\[{]))
        name: keyword.operator.bitwise.shift.ruko
      - match: (?<=['"`)}\]\w]|\\.)(?:\+\+|--)(?=(?:['"`\w]|\#?[(\[{]))
        name: keyword.operator.successor.ruko
      - match: (?<=['"`)}\]\w]|\\.)(?:[+-][%|]?|\*\*?[%|]?|~?/|%%?)(?=(?:['"`\w]|\#?[(\[{]))
        name: keyword.operator.arithmetic.ruko
      - match: (?<=['"`)}\]\w]|\\.)(?:\+\+|\-\-|\+|\-|−|¦|\||⊕|⊖|⊞|⊟|∪|∨|⊔|±|∓|∔|∸|≏|⊎|⊻|⊽|⋎|⋓|⟇|⧺|⧻|⨈|⨢|⨣|⨤|⨥|⨦|⨧|⨨|⨩|⨪|⨫|⨬|⨭|⨮|⨹|⨺|⩁|⩂|⩅|⩊|⩌|⩏|⩐|⩒|⩔|⩖|⩗|⩛|⩝|⩡|⩢|⩣|\*|//?|⌿|÷|%|·|·|⋅|∘|×|\\|∩|∧|⊗|⊘|⊙|⊚|⊛|⊠|⊡|⊓|∗|∙|∤|⅋|≀|⊼|⋄|⋆|⋇|⋉|⋊|⋋|⋌|⋏|⋒|⟑|⦸|⦼|⦾|⦿|⧶|⧷|⨇|⨰|⨱|⨲|⨳|⨴|⨵|⨶|⨷|⨸|⨻|⨼|⨽|⩀|⩃|⩄|⩋|⩍|⩎|⩑|⩓|⩕|⩘|⩚|⩜|⩞|⩟|⩠|⫛|⊍|▷|⨝|⟕|⟖|⟗|⨟|↑|↓|⇵|⟰|⟱|⤈|⤉|⤊|⤋|⤒|⤓|⥉|⥌|⥍|⥏|⥑|⥔|⥕|⥘|⥙|⥜|⥝|⥠|⥡|⥣|⥥|⥮|⥯|￪|￬|√|∛|∜|⋆|±|∓)(?=(?:['"`\w]|\#?[(\[{]))
        name: keyword.operator.arithmetic.ruko
      - match: (?<=['"`)}\]\w]|\\.)(?:<-->|->|-->|<--|←|→|↔|↚|↛|↞|↠|↢|↣|↦|↤|↮|⇎|⇍|⇏|⇐|⇒|⇔|⇴|⇶|⇷|⇸|⇹|⇺|⇻|⇼|⇽|⇾|⇿|⟵|⟶|⟷|⟹|⟺|⟻|⟼|⟽|⟾|⟿|⤀|⤁|⤂|⤃|⤄|⤅|⤆|⤇|⤌|⤍|⤎|⤏|⤐|⤑|⤔|⤕|⤖|⤗|⤘|⤝|⤞|⤟|⤠|⥄|⥅|⥆|⥇|⥈|⥊|⥋|⥎|⥐|⥒|⥓|⥖|⥗|⥚|⥛|⥞|⥟|⥢|⥤|⥦|⥧|⥨|⥩|⥪|⥫|⥬|⥭|⥰|⧴|⬱|⬰|⬲|⬳|⬴|⬵|⬶|⬷|⬸|⬹|⬺|⬻|⬼|⬽|⬾|⬿|⭀|⭁|⭂|⭃|⥷|⭄|⥺|⭇|⭈|⭉|⭊|⭋|⭌|￩|￫|⇜|⇝|↜|↝|↩|↪|↫|↬|↼|↽|⇀|⇁|⇄|⇆|⇇|⇉|⇋|⇌|⇚|⇛|⇠|⇢|↷|↶|↺|↻|=>)(?=(?:['"`\w]|\#?[(\[{]))
        name: keyword.operator.arrow.ruko
      - match: (?<=['"`)}\]\w]|\\.)(?:<[-=]?\||\|[-=]?>)(?=(?:['"`\w]|\#?[(\[{]))
        name: keyword.operator.pipeline.ruko
      - match: (?<=['"`)}\]\w]|\\.)(?:<\+|\+>|∘)(?=(?:['"`\w]|\#?[(\[{]))
        name: keyword.operator.compose.ruko
      - match: (?<=['"`)}\]\w]|\\.)(?:[<>][:!]|[:!][<>])(?=(?:['"`\w]|\#?[(\[{]))
        name: keyword.operator.class.ruko
      - match: (?<=['"`)}\]\w]|\\.)(?:[>.]\.[.<]|[=.]\.[.=]|\.\.)(?=(?:['"`\w]|\#?[(\[{]))
        name: keyword.operator.range.ruko
      - match: (?<=['"`)}\]\w]|\\.)(?:[<>]=?|<=?>)(?=(?:['"`\w]|\#?[(\[{]))
        name: keyword.operator.relational.ruko
      - match: (?<=['"`)}\]\w]|\\.)(?:(?<!<)<=|(?<!>)>=|>|<|≥|≤|≢|∈|∉|∋|∌|⊆|⊈|⊂|⊄|⊊|∝|∊|∍|∥|∦|∷|∺|∻|∽|∾|≁|≃|≂|≄|≅|≆|≇|≈|≉|≊|≋|≌|≍|≎|≐|≑|≒|≓|≖|≗|≘|≙|≚|≛|≜|≝|≞|≟|≣|≦|≧|≨|≩|≪|≫|≬|≭|≮|≯|≰|≱|≲|≳|≴|≵|≶|≷|≸|≹|≺|≻|≼|≽|≾|≿|⊀|⊁|⊃|⊅|⊇|⊉|⊋|⊏|⊐|⊑|⊒|⊜|⊩|⊬|⊮|⊰|⊱|⊲|⊳|⊴|⊵|⊶|⊷|⋍|⋐|⋑|⋕|⋖|⋗|⋘|⋙|⋚|⋛|⋜|⋝|⋞|⋟|⋠|⋡|⋢|⋣|⋤|⋥|⋦|⋧|⋨|⋩|⋪|⋫|⋬|⋭|⋲|⋳|⋴|⋵|⋶|⋷|⋸|⋹|⋺|⋻|⋼|⋽|⋾|⋿|⟈|⟉|⟒|⦷|⧀|⧁|⧡|⧣|⧤|⧥|⩦|⩧|⩪|⩫|⩬|⩭|⩮|⩯|⩰|⩱|⩲|⩳|⩵|⩶|⩷|⩸|⩹|⩺|⩻|⩼|⩽|⩾|⩿|⪀|⪁|⪂|⪃|⪄|⪅|⪆|⪇|⪈|⪉|⪊|⪋|⪌|⪍|⪎|⪏|⪐|⪑|⪒|⪓|⪔|⪕|⪖|⪗|⪘|⪙|⪚|⪛|⪜|⪝|⪞|⪟|⪠|⪡|⪢|⪣|⪤|⪥|⪦|⪧|⪨|⪩|⪪|⪫|⪬|⪭|⪮|⪯|⪰|⪱|⪲|⪳|⪴|⪵|⪶|⪷|⪸|⪹|⪺|⪻|⪼|⪽|⪾|⪿|⫀|⫁|⫂|⫃|⫄|⫅|⫆|⫇|⫈|⫉|⫊|⫋|⫌|⫍|⫎|⫏|⫐|⫑|⫒|⫓|⫔|⫕|⫖|⫗|⫘|⫙|⫷|⫸|⫹|⫺|⊢|⊣|⟂|⫪|⫫)(?=(?:['"`\w]|\#?[(\[{]))
        name: keyword.operator.relational.ruko
      - match: (?<=['"`)}\]\w]|\\.)(?:\.|\.\.+|…|⁝|⋮|⋱|⋰|⋯)(?=(?:['"`\w]|\#?[(\[{]))
        name: keyword.operator.dots.ruko
      - match: (?<=['"`)}\]\w]|\\.)(?:[!=]==?)(?=(?:['"`\w]|\#?[(\[{]))
        name: keyword.operator.comparison.ruko
      - match: (?<=['"`)}\]\w]|\\.)(?:~[=!]|[=!]~|[=>]<)(?=(?:['"`\w]|\#?[(\[{]))
        name: keyword.operator.similarity.ruko
      - match: (?<=['"`)}\]\w]|\\.)(?:<[/*|+$:]>?|[/*|+$:]>)(?=(?:['"`\w]|\#?[(\[{]))
        name: keyword.operator.function.ruko
      - match: (?<=['"`)}\]\w]|\\.)(?:\?\?)(?=(?:['"`\w]|\#?[(\[{]))
        name: keyword.operator.null-coalescing.ruko
      - match: (?<=['"`)}\]\w]|\\.)(?:!!)(?=(?:['"`\w]|\#?[(\[{]))
        name: keyword.operator.coalescing.ruko
      - match: (?<=['"`)}\]\w]|\\.)(?:\?:?)(?=(?:['"`\w]|\#?[(\[{]))
        name: keyword.operator.conditional.ruko
      - match: (?<=['"`)}\]\w]|\\.)(?:!:?)(?=(?:['"`\w]|\#?[(\[{]))
        name: keyword.operator.ternary.ruko
      - match: (?<=['"`)}\]\w]|\\.)(?:[.:$]|:::?)(?=(?:['"`\w]|\#?[(\[{]))
        name: keyword.operator.macro.ruko
      - match: (?<=['"`)}\]\w]|\\.)(?::?=)(?=(?:['"`\w]|\#?[(\[{]))
        name: keyword.operator.assignment.ruko
      - match: (?<=['"`)}\]\w]|\\.)(?:=+>|<=+)(?=(?:['"`\w]|\#?[(\[{]))
        name: keyword.operator.arrow.fat.ruko
      - match: (?<=['"`)}\]\w]|\\.)(?:-+>|<-+)(?=(?:['"`\w]|\#?[(\[{]))
        name: keyword.operator.arrow.skinny.ruko
      - match: (?<=['"`)}\]\w]|\\.)(?:~+>|<~+)(?=(?:['"`\w]|\#?[(\[{]))
        name: keyword.operator.arrow.wavy.ruko
      - match: (?<=['"`)}\]\w]|\\.)(?:[&|^~][\p{P}\p{S}&&[^,;''"`({\[)}\]\p{Pc}]]+)(?=(?:['"`\w]|\#?[(\[{]))
        name: keyword.operator.logical.custom.ruko
      - match: (?<=['"`)}\]\w]|\\.)(?:[-+*/%][\p{P}\p{S}&&[^,;''"`({\[)}\]\p{Pc}]]+)(?=(?:['"`\w]|\#?[(\[{]))
        name: keyword.operator.arithmetic.custom.ruko
      - match: (?<=['"`)}\]\w]|\\.)(?:[@:][\p{P}\p{S}&&[^,;''"`({\[)}\]\p{Pc}]]+)(?=(?:['"`\w]|\#?[(\[{]))
        name: keyword.operator.prototype.custom.ruko
      - match: (?<=['"`)}\]\w]|\\.)(?:[.][\p{P}\p{S}&&[^,;''"`({\[)}\]\p{Pc}]]+)(?=(?:['"`\w]|\#?[(\[{]))
        name: keyword.operator.accessor.custom.ruko
      - match: (?<=['"`)}\]\w]|\\.)(?:[=!][\p{P}\p{S}&&[^,;''"`({\[)}\]\p{Pc}]]+)(?=(?:['"`\w]|\#?[(\[{]))
        name: keyword.operator.comparison.custom.ruko
      - match: (?<=['"`)}\]\w]|\\.)(?:[<>][\p{P}\p{S}&&[^,;''"`({\[)}\]\p{Pc}]]+)(?=(?:['"`\w]|\#?[(\[{]))
        name: keyword.operator.relational.custom.ruko
      - match: (?<=['"`)}\]\w]|\\.)(?:[?#][\p{P}\p{S}&&[^,;''"`({\[)}\]\p{Pc}]]+)(?=(?:['"`\w]|\#?[(\[{]))
        name: keyword.operator.private.custom.ruko
      - match: (?<=['"`)}\]\w]|\\.)(?:\p{Sm}+)(?=(?:['"`\w]|\#?[(\[{]))
        name: keyword.operator.math.custom.ruko
      - match: (?<=['"`)}\]\w]|\\.)(?:\p{Sc}+)(?=(?:['"`\w]|\#?[(\[{]))
        name: keyword.operator.currency.custom.ruko
      - match: (?<=['"`)}\]\w]|\\.)(?:[!#-&*+\-./:-@\\^|~¡-©«-±´¶·¸»¿×÷]+)(?=(?:['"`\w]|\#?[(\[{]))
        name: keyword.operator.ascii.custom.ruko
      - match: (?<=['"`)}\]\w]|\\.)([\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]+)(?=(?:['"`\w]|\#?[(\[{]))
        name: keyword.operator.primary.ruko
      - match: (?<=['"`)}\]\w]|\\.)([\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]+)(?=(?:['"`\w]|\#?[(\[{]))
        name: keyword.operator.primary.ruko

  prefix-operators:
    comment: Prefix operators
    match: ([\p{P}\p{S}&&[^,;'"`\\({\[)}\]\p{Pc}]])(?=[\p{P}\p{S}&&[^,;'"`\\({\[)}\]\p{Pc}]]*(?:['"`\w]|\#?[(\[{]))
    name: keyword.operator.prefix.ruko
    captures:
      1:
        patterns:
          - match: \*
            name: keyword.operator.pointer.ruko
          - match: /
            name: keyword.operator.spread.ruko
          - match: \+
            name: keyword.operator.increment.ruko
          - match: '-'
            name: keyword.operator.decrement.ruko
          - match: '&'
            name: keyword.operator.reference.ruko
          - match: \|
            name: keyword.operator.union.ruko
          - match: \^
            name: keyword.operator.borrow.ruko
          - match: '!'
            name: keyword.operator.logical.ruko
          - match: \$
            name: punctuation.definition.variable.ruko
          - match: '@'
            name: punctuation.definition.decorator.ruko
          - match: '~'
            name: keyword.operator.bitwise.ruko
          - match: \?
            name: keyword.operator.existential.ruko
          - match: =
            name: keyword.operator.assignment.ruko
          - match: '#'
            name: punctuation.definition.anchor.ruko
          - match: '%'
            name: keyword.operator.format.ruko
          - match: \.
            name: keyword.operator.accessor.ruko
          - match: ¬
            name: keyword.operator.lifetime.ruko

  suffix-operators:
    comment: Suffix operators
    match: (?<=(?:['"`)}\]\w]|\\.)[\p{P}\p{S}&&[^,;'"`\\({\[)}\]\p{Pc}]]*)([\p{P}\p{S}&&[^,;'"`\\({\[)}\]\p{Pc}]])
    name: keyword.operator.suffix.ruko
    captures:
      1:
        patterns:
          - match: \*
            name: keyword.operator.pointer.ruko
          - match: /
            name: keyword.operator.quotient.ruko
          - match: \+
            name: keyword.operator.increment.ruko
          - match: '-'
            name: keyword.operator.decrement.ruko
          - match: '&'
            name: keyword.operator.reference.ruko
          - match: \|
            name: keyword.operator.union.ruko
          - match: \^
            name: keyword.operator.borrow.ruko
          - match: '!'
            name: keyword.operator.logical.ruko
          - match: \$
            name: punctuation.definition.variable.ruko
          - match: '@'
            name: punctuation.definition.decorator.ruko
          - match: '~'
            name: keyword.operator.destructor.ruko
          - match: \?
            name: keyword.operator.existential.ruko
          - match: =
            name: keyword.operator.assignment.ruko
          - match: \$
            name: keyword.operator.pipeline.ruko
          - match: '#'
            name: punctuation.definition.anchor.ruko
          - match: '%'
            name: keyword.operator.format.ruko
          - match: \.
            name: keyword.operator.accessor.ruko
          - match: ¬
            name: keyword.operator.lifetime.ruko

  # Clauses and Keywords

  parameter-brackets:
    begin: (\()\s*
    end: \s*(\))
    captures:
      1: {name: punctuation.definition.parameters.ruko}
    patterns:
      - include: '#binding-pattern'
      - include: $self

  modifier-keywords:
    name: storage.modifier.ruko
    match: |
      (?x)
      (
        (?:
          (?:
            \s*
            (?<!(?:(?<!\.)\.|[?!:]:)=?)
            \b
              [\p{Pc}\p{L}]\w*
            )
            \b
          \s*
        )*
      )
      (?=
        \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b
        (?:
          const|let|mut|dyn|va[rl]|use
          |given|expr|eval|init|comp
          |func|pro[pc]|type|class|actor|trait
          |impl|enum|module|model|struct|record
          |union|iter|macro|query|elem|temp|oper
          |object|realm|style|script|quote
          |import|export|intern|extern
          |do|scope
        )
        \b\s*
      )
    captures:
      1: {patterns: [{include: '#modifiers'}]}

  type-modifiers:
    patterns:
      - name: storage.modifier.ruko
        match: |
          (?x)
          \s*\b
          (
            # ignore all keywords
            (?!
              (?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b
              (?: # keywords
                [io]n|of|[ai]s|by|has|old|new|del
                |unset|ref|deref|and|x?or|not
                |const|let|mut|dyn|va[rl]|use
                |given|expr|eval|init|comp
                |func|pro[pc]|type|class|actor|trait
                |impl|enum|module|model|struct|record
                |union|iter|macro|query|elem|temp|oper
                |object|realm|style|script|quote
                |go|defer|do|with|from|where
                |if|else|then|guard|when
                |for|loop|while|goto|move
                |try|throw|catch|switch
                |match|case|pass|def|defer
                |break|skip|redo|retry
                |return|yield|await|scope
                |import|export|intern|extern
                |debug|assert|check|decl
              )
              \b
            )
            [\p{Pc}\p{L}]\w* # identifier
          )
          \b\s*
          (?=
            (?!
              (?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b
              (?: # keywords
                [io]n|of|[ai]s|by|has|old|new|del
                |unset|ref|deref|and|x?or|not
                |const|let|mut|dyn|va[rl]|use
                |given|expr|eval|init|comp
                |func|pro[pc]|type|class|actor|trait
                |impl|enum|module|model|struct|record
                |union|iter|macro|query|elem|temp|oper
                |object|realm|style|script|quote
                |go|defer|do|with|from|where
                |if|else|then|guard|when
                |for|loop|while|goto|move
                |try|throw|catch|switch
                |match|case|pass|def|defer
                |break|skip|redo|retry
                |return|yield|await|scope
                |import|export|intern|extern
                |debug|assert|check|decl
              )
              \b
            )
            [\p{Pc}\p{L}]\w*
          )
        captures:
          1: {patterns: [{include: '#modifiers'}]}

  modifiers:
    patterns:
      - comment: Visibility modifiers
        match: |
          (?x)\s*\b
          (?:
            pub|priv|prot|final|read|write|over
            |global|local|intern|extern|mut|immut
            |post|[gs]et|put|del|req|opt|shared|stable
            |(?:un)?safe|virt|seal|abst|friend|enemy
          ) \b\s*
        name: storage.modifier.ruko
      - comment: Visibility modifiers
        match: |
          (?x)\s*\b
          (?:
            in|out|inout|inplace|ref|defer|a?sync
            |stat|dyn|lazy|eager|bound|free|unique
            |union|open|closed?
          ) \b\s*
        name: storage.modifier.declaration.ruko
      - comment: Functional modifiers
        match: |
          (?x)\s*\b
          (?:
            rec|oper|curry|opaque|inline|tail|macro
            |partial|variadic|generic|template|lambda
            |coroutine|continuation|hook|event
          )\b\s*
        name: storage.modifier.function.ruko
      - include: '#expression-keywords'
      - comment: Custom modifiers
        match: \s*\b([\p{Pc}\p{L}]\w*)\b\s*
        name: storage.modifier.specifier.ruko

  declaration-keywords:
    patterns:
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(decl)\b\s*
        name: keyword.other.declare.ruko
      - match: |
          (?x)
          \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(
            const|let|mut|dyn|va[rl]|use
            |given|expr|eval|init|comp
          )\b\s*
        name: storage.type.ruko
      - match: |
          (?x)
          \s*
            (?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b
            (
              func|pro[pc]|type|class|actor|trait
              |impl|enum|module|model|struct|record
              |union|iter|macro|query|elem|temp|oper
              |object|realm|style|script|quote
            )
            \b
          \s*
        name: storage.type.$1.ruko

  general-keywords:
    comment: general keywords
    patterns:
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(if|else|guard|when)\b\s*
        name: keyword.control.conditional.ruko
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(for|loop|while)\b\s*
        name: keyword.control.loop.ruko
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(try|throw|catch|then)\b\s*
        name: keyword.control.trycatch.ruko
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(switch|case|def)\b\s*
        name: keyword.control.switch.ruko
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(match)\b\s*
        name: keyword.control.match.ruko
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(break|skip|redo|retry|return|await|scope|yield|goto|move|pass)\b\s*
        name: keyword.control.flow.ruko
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(import|export|intern|extern)\b\s*
        name: keyword.control.module.ruko
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(with|do|from|(?:de)?ref|go|defer)\b\s*
        name: keyword.control.$1.ruko
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(debug|assert|check|decl|where)\b\s*
        name: keyword.other.$1.ruko

  expression-keywords:
    comment: expression keywords
    patterns:
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(as|old|new|by)\b\s*
        name: keyword.operator.expression.$1.ruko
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(not\s+)?([io]n|of)\b\s*
        name: keyword.operator.expression.$2.ruko
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(is\s+not|is|has\s+not|has)\b\s*
        name: keyword.operator.expression.is.ruko
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(del)\b\s*
        name: keyword.operator.expression.delete.ruko
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(unset)\b\s*
        name: keyword.operator.expression.void.ruko
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(and|x?or|not)\b\s*
        name: keyword.operator.expression.logical.ruko

  keywords:
    patterns:
      - include: '#module-expression'
      - include: '#control-expression'
      - include: '#query-expression'
      - include: '#constraint-expression'
      - include: '#intern-extern-expression'
      - include: '#modifier-keywords'
      - include: '#declaration-keywords'
      - include: '#expression-keywords'
      - include: '#general-keywords'

  control-expression:
    applyEndPatternLast: true
    begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(break|skip|redo|retry|scope|goto|move|pass)\b\s*
    end: (?=)|$
    beginCaptures:
      1: {name: keyword.control.flow.ruko}
    patterns:
      - match: *entity-name
        name: constant.other.label.ruko

  intern-extern-expression:
    applyEndPatternLast: true
    begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(intern|extern)\b\s*
    end: (?=)|$
    beginCaptures:
      1: {name: keyword.control.module.ruko}
    patterns:
      - match: *entity-name
        name: constant.other.label.ruko

  module-expression:
    applyEndPatternLast: true
    begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(import|export)\b\s*
    end: (?=)|$
    beginCaptures:
      1: {name: keyword.control.module.ruko}
    patterns:
      - include: '#module-content'
      - include: '#intern-extern-expression'

  module-content:
    patterns:
      - begin: (\{)\s*
        end: \s*(\})
        captures:
          1: {name: punctuation.definition.block.ruko}
        patterns:
          - include: '#module-content'
          - include: '#intern-extern-expression'
          - include: $self
      - include: '#strings'
      - include: '#regexps'
      - include: '#symbols'
      - include: '#comments'
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(as)\b\s*
        name: keyword.control.module.ruko
      - include: '#type-operators'
      - include: '#accessor-operators'
      - match: \s*(?<!:):(?!:)\s*
        name: keyword.operator.alias.ruko
      - include: '#regexp-patterns'
      - include: '#type-keywords'
      - match: \s*(?<!\*)\*(?!\*)\s*
        name: constant.language.import-export-all.js
      - include: '#type-modifiers'
      - include: '#comma'
      - include: '#line-continuation'
      - match: *entity-name
        name: string.unquoted.module.ruko

  constraint-expression:
    comment: most of the keywords come from Dafny
    begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(where)\b\s*
    beginCaptures:
      1: {name: keyword.control.validate.ruko}
    end: (?=[,;)}\]])
    patterns:
      - match: |
          (?x)
          (?<=^|[,;]|\#?[(\[{])\s*
          (
            \b
            # ignore all keywords
            (?!
              (?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b
              (?: # keywords
                [io]n|of|[ai]s|by|has|old|new|del
                |unset|ref|deref|and|x?or|not
                |const|let|mut|dyn|va[rl]|use
                |given|expr|eval|init|comp
                |func|pro[pc]|type|class|actor|trait
                |impl|enum|module|model|struct|record
                |union|iter|macro|query|elem|temp|oper
                |object|realm|style|script|quote
                |go|defer|do|with|from|where
                |if|else|then|guard|when
                |for|loop|while|goto|move
                |try|throw|catch|switch
                |match|case|pass|def|defer
                |break|skip|redo|retry
                |return|yield|await|scope
                |import|export|intern|extern
                |debug|assert|check|decl
              )
              \b
            )
            \b
            [\p{Pc}\p{L}]\w* # identifier
            \b
          )
        name: keyword.control.validate.ruko
      - include: $self

  query-expression:
    applyEndPatternLast: true
    comment: RINQ (Ruko INtegrated Query) expression mini-language
    begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(from)\b\s*
    beginCaptures:
      1: {name: keyword.control.query.ruko}
    end: (?=[,;)}\]])
    patterns:
      - include: '#query-body'
      - include: $self

  query-body:
    patterns:
      - include: '#in-clause'
      - include: '#where-clause'
      - include: '#join-clause'
      - include: '#sort-clause'
      - include: '#select-clause'
      - include: '#group-clause'
      - include: '#take-clause'
      - include: '#reduce-clause'
      - include: '#set-clause'

  in-clause:
    begin: |
      (?x)
      \s*
      (?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b
        (
          [io]n|of
        )
      \b
      \s*
    beginCaptures:
      1: {name: keyword.control.query.ruko}
      2: {patterns: [include: $self]}
      3: {name: keyword.control.query.ruko}
    end: (?=[,;)}\]])
    patterns:
      - include: '#query-body'
      - include: $self

  join-clause:
    begin: |
      (?x)
      \s*
      (?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b
        (
          \b (?:full|part|self|cross)? \b \s*
          \b (?:inner|outer|left|right)? \b \s*
          \b (?:join)
        )
      \b
      \s*
    beginCaptures:
      1: {name: keyword.control.query.ruko}
      2: {patterns: [include: $self]}
      3: {name: keyword.control.query.ruko}
    end: (?=[,;)}\]])
    patterns:
      - begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b([io]nto|[io]n|of|where)\b\s*
        end: (?=[,;)}\]])
        beginCaptures:
          1: {name: keyword.control.query.ruko}
        patterns:
          - include: '#query-body'
          - include: $self
      - include: '#query-body'
      - include: $self

  where-clause:
    begin: |
      (?x)
      \s*
      (?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b
        (
          where|having|filter|reject
        )
      \b
      \s*
    beginCaptures:
      1: {name: keyword.control.query.ruko}
    end: (?=[,;)}\]])
    patterns:
      - include: '#query-body'
      - include: $self

  sort-clause:
    begin: |
      (?x)
      \s*
      (?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b
        (
          \b (?:sort|order|then) \b \s*
          \b (?:asc|desc)? \b \s*
          \b (?:by|with)?
        )
      \b
      \s*
    beginCaptures:
      1: {name: keyword.control.query.ruko}
    end: (?=[,;)}\]])
    patterns:
      - include: '#query-body'
      - include: $self

  select-clause:
    begin: |
      (?x)
      \s*
      (?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b
        (
          \b (?:select|map) \b \s*
          \b (?:unique|any|all|some|every)?
        )
      \b
      \s*
    beginCaptures:
      1: {name: keyword.control.query.ruko}
    end: (?=[,;)}\]])
    patterns:
      - begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(by|with|while)\b\s*
        end: (?=[,;)}\]])
        name: keyword.control.query.ruko
        patterns:
          - include: '#query-body'
          - include: $self
      - include: '#query-body'
      - include: $self

  take-clause:
    begin: |
      (?x)
      \s*
      (?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b
        (
          \b (?:take|drop|limit|offset) \b \s*
          \b (?:first|last|head|tail)?
        )
      \b
      \s*
    beginCaptures:
      1: {name: keyword.control.query.ruko}
    end: (?=[,;)}\]])
    patterns:
      - begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(by|with|while)\b\s*
        end: (?=[,;)}\]])
        name: keyword.control.query.ruko
        patterns:
          - include: '#query-body'
          - include: $self
      - include: '#query-body'
      - include: $self

  reduce-clause:
    begin: |
      (?x)
      \s*
      (?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b
        (
          \b (?:fold|reduce|scan) \b \s*
          \b (?:first|last|left|right)?
        )
      \b
      \s*
    beginCaptures:
      1: {name: keyword.control.query.ruko}
    end: (?=[,;)}\]])
    patterns:
      - begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(by|while|with)\b\s*
        end: (?=[,;)}\]])
        name: keyword.control.query.ruko
        patterns:
          - include: '#query-body'
          - include: $self
      - include: '#query-body'
      - include: $self

  group-clause:
    begin: |
      (?x)
      \s*
      (?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b
        (
          group|lookup
        )
      \b
      \s*
    beginCaptures:
      1: {name: keyword.control.query.ruko}
    end: (?=[,;)}\]])
    patterns:
      - begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(by|[io]nto)\b\s*
        end: (?=[,;)}\]])
        name: keyword.control.query.ruko
        patterns:
          - include: '#query-body'
          - include: $self
      - include: '#query-body'
      - include: $self

  set-clause:
    begin: |
      (?x)
      \s*
      (?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b
        (
          and|x?or|but
        )
      \b
      \s*
    beginCaptures:
      1: {name: keyword.control.query.ruko}
    end: (?=[,;)}\]])
    patterns:
      - include: '#query-body'
      - include: $self

  namespace-separators:
    patterns:
      - include: '#accessor-operators'
      - match: (?<!\\)\\(?!\\)
        name: punctuation.separator.namespace.ruko

  declarations:
    patterns:
      - applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(quote)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.quote.ruko}
        name: meta.quote.ruko
        patterns:
          - begin: \s*(\{)\s*
            end: \s*(\})\s*
            name: meta.quote.ruko
            captures:
              1: {name: punctuation.definition.block.ruko}
            patterns:
              - include: '#embedded-expressions'
              - include: '#embedded-formatting'
              - include: '#embedded-arguments'
              - include: $self
          - include: '#declaration-clause'
          - include: '#namespace-separators'
          - match: *entity-name
            name: entity.name.quote.ruko
      - applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(style)\b\s*
        end: (?=$|['"`\w\s]|\#?[(\[{])
        beginCaptures:
          1: {name: storage.type.style.ruko}
        name: meta.style.ruko
        patterns:
          - include: '#style-rules'
          - include: '#style-pair'
          - include: '#style-block'
          - include: '#declaration-clause'
          - include: '#namespace-separators'
          - match: *entity-name
            name: entity.name.style.ruko
      - begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(oper)\b\s*
        end: (:?=(?:\s+|$)(?!\#?[(\[{]))|(?=\#?{|[;,]|$)
        beginCaptures:
          1: {name: storage.type.operator.ruko}
        endCaptures:
          1: {name: punctuation.terminator.operator.ruko}
        name: meta.operator.ruko
        patterns:
          - include: '#angle-brackets'
          - include: '#operator-declarations'
          - include: '#declaration-clause'
          - match: *entity-name
            name: variable.parameter.ruko
      - applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(script)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.script.ruko}
        name: meta.script.ruko
        patterns:
          - include: '#script-blocks'
          - include: '#declaration-clause'
          - include: '#namespace-separators'
          - match: *entity-name
            name: entity.name.script.ruko
      - applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(elem)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.component.ruko}
        patterns:
          - include: '#declaration-clause'
          - include: '#namespace-separators'
          - match: *entity-name
            name: entity.name.component.ruko
            patterns: *html-tag-names
      - applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(const|let|mut|dyn|va[rl]|use|given|expr|eval|init|comp)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.variable.ruko}
      - applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(decl)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: keyword.other.declare.ruko}
      - applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(func)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.function.ruko}
        patterns:
          - include: '#declaration-clause'
          - include: '#namespace-separators'
          - match: *entity-name
            name: entity.name.function.ruko
      - applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(actor)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.namespace.ruko}
        patterns:
          - include: '#declaration-clause'
          - include: '#namespace-separators'
          - match: *entity-name
            name: entity.name.namespace.ruko
      - applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(prop)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.property.ruko}
        patterns:
          - include: '#declaration-clause'
          - include: '#namespace-separators'
          - match: *entity-name
            name: entity.name.property.ruko
      - applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(proc)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.procedure.ruko}
        patterns:
          - include: '#declaration-clause'
          - include: '#namespace-separators'
          - match: *entity-name
            name: entity.name.procedure.ruko
      - applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(temp)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.template.ruko}
        patterns:
          - include: '#declaration-clause'
          - include: '#namespace-separators'
          - match: *entity-name
            name: entity.name.template.ruko
      - applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(class)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.class.ruko}
        patterns:
          - include: '#declaration-clause'
          - include: '#namespace-separators'
          - match: *entity-name
            name: entity.name.class.ruko
      - applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(impl)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.interface.ruko}
        patterns:
          - include: '#declaration-clause'
          - include: '#namespace-separators'
          - match: *entity-name
            name: entity.name.interface.ruko
      - applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(enum)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.enum.ruko}
        patterns:
          - include: '#declaration-clause'
          - include: '#namespace-separators'
          - match: *entity-name
            name: entity.name.enum.ruko
      - applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(module)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.module.ruko}
        patterns:
          - include: '#declaration-clause'
          - include: '#namespace-separators'
          - match: *entity-name
            name: entity.name.module.ruko
      - applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(iter)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.iterator.ruko}
        patterns:
          - include: '#declaration-clause'
          - include: '#namespace-separators'
          - match: *entity-name
            name: entity.name.iterator.ruko
      - applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(model)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.model.ruko}
        patterns:
          - include: '#declaration-clause'
          - include: '#namespace-separators'
          - match: *entity-name
            name: entity.name.model.ruko
      - applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(macro)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.macro.ruko}
        patterns:
          - include: '#declaration-clause'
          - include: '#namespace-separators'
          - match: *entity-name
            name: entity.name.macro.ruko
      - applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(query)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.query.ruko}
        patterns:
          - include: '#declaration-clause'
          - include: '#namespace-separators'
          - match: *entity-name
            name: entity.name.query.ruko
      - applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(object)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.object.ruko}
        patterns:
          - include: '#declaration-clause'
          - include: '#namespace-separators'
          - match: *entity-name
            name: entity.name.object.ruko
      - applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(trait)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.trait.ruko}
        patterns:
          - include: '#declaration-clause'
          - include: '#namespace-separators'
          - match: *entity-name
            name: entity.name.trait.ruko
      - applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(realm)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.realm.ruko}
        patterns:
          - include: '#declaration-clause'
          - include: '#namespace-separators'
          - match: *entity-name
            name: entity.name.realm.ruko
      - applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(union)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.union.ruko}
        patterns:
          - include: '#declaration-clause'
          - match: *entity-name
            name: entity.name.union.ruko
      - applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(struct)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.struct.ruko}
        patterns:
          - include: '#declaration-clause'
          - include: '#namespace-separators'
          - match: *entity-name
            name: entity.name.struct.ruko
      - applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(record)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.record.ruko}
        patterns:
          - include: '#declaration-clause'
          - include: '#namespace-separators'
          - match: *entity-name
            name: entity.name.record.ruko

  declaration-clause:
    name: meta.declaration.ruko
    patterns:
      - include: '#line-continuation'
      - match: \b([\p{Pc}\p{L}]\w*)\b(?=::|\.|->|\\)
        name: entity.name.namespace.ruko
      - include: '#type-square-brackets'
      - include: '#type-signature'
      - include: '#decorators'
      - include: '#embedded-verbatim'
      - include: '#type-keywords'
      - match: \s*(?<!\*)\*(?!\*)\s*
        name: keyword.generator.asterisk.ruko
      - include: '#type-operators'
      - include: '#comments'
      - include: '#comma'
      - include: '#line-continuation'
      - begin: (\()\s*
        end: \s*(\))
        captures:
          1: {name: punctuation.definition.parameters.ruko}
        patterns:
          - include: '#binding-pattern'
          - include: $self
      - begin: (\#\{)\s*
        end: \s*(\})
        name: meta.brace.curly.ruko
        captures:
          1: {name: punctuation.section.class.ruko}
        patterns:
          - include: $self
      - begin: (\{)\s*
        end: \s*(\})
        name: meta.brace.curly.ruko
        captures:
          1: {name: punctuation.definition.block.ruko}
        patterns:
          - include: '#modifier-clause'
          - include: $self
      - include: '#embedded-expressions'
      - include: '#embedded-formatting'
      - include: '#embedded-arguments'
      - include: '#brackets'
      - include: '#literals'
      - match: ::|\.|->|\\
        name: punctuation.separator.namespace.ruko
      - match: \s+
        name: meta.block.ruko

  modifier-clause:
    comment: Modifiers for declarations in classes, objects, traits, etc.
    patterns:
      - match: |
          (?x)
          ^\s*\b((?:
            # ignore all keywords
            (?!
              (?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b
              (?: # keywords
                [io]n|of|[ai]s|by|has|old|new|del
                |unset|ref|deref|and|x?or|not
                |const|let|mut|dyn|va[rl]|use
                |given|expr|eval|init|comp
                |func|pro[pc]|type|class|actor|trait
                |impl|enum|module|model|struct|record
                |union|iter|macro|query|elem|temp|oper
                |object|realm|style|script|quote
                |go|defer|do|with|from|where
                |if|else|then|guard|when
                |for|loop|while|goto|move
                |try|throw|catch|switch
                |match|case|pass|def|defer
                |break|skip|redo|retry
                |return|yield|await|scope
                |import|export|intern|extern
                |debug|assert|check|decl
              )
              \b
            )
            [\p{Pc}\p{L}]\w* # identifier
            \b\s*
          )+)(:)\s*
        captures:
          1:
            name: storage.modifier.specifier.ruko
            patterns: [{include: '#modifiers'}]
          2:
            name: punctuation.separator.section.ruko

  function-clause:
    patterns:
      - comment: Function def before function keyword; x = def()
        match: |
          (?x)
          \s*
          (?<=[?!:]:|\b\.|[?!]\.) # lookbehind for valid assignment
          \s*
          \b([\p{Pc}\p{L}]\w*)\b\s+ # Label
          (:?=)\s+ # Assignment operator

          (
            # ignore all keywords
            (?!
              (?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b
              (?: # keywords
                [io]n|of|[ai]s|by|has|old|new|del
                |unset|ref|deref|and|x?or|not
                |const|let|mut|dyn|va[rl]|use
                |given|expr|eval|init|comp
                |func|pro[pc]|type|class|actor|trait
                |impl|enum|module|model|struct|record
                |union|iter|macro|query|elem|temp|oper
                |object|realm|style|script|quote
                |go|defer|do|with|from|where
                |if|else|then|guard|when
                |for|loop|while|goto|move
                |try|throw|catch|switch
                |match|case|pass|def|defer
                |break|skip|redo|retry
                |return|yield|await|scope
                |import|export|intern|extern
                |debug|assert|check|decl
              )
              \b
            )
            [\p{Pc}\p{L}]\w* # identifier
            \b
          )?

          \s*
          (?=
            \b
            (?: # Function types
              func|pro[pc]|type|class|actor|trait
              |impl|enum|module|model|struct|record
              |union|iter|macro|query|elem|temp|oper
              |object|realm|style|script|quote
            )
            \b
          )
        name: meta.function.declaration.ruko
        captures:
          1: {name: entity.name.method.ruko}
          2: {name: keyword.operator.assignment.ruko}
          3: {patterns: [{include: '#modifiers'}]}
      - begin: |
          (?x)
          \s*
          (?<=[?!:]:|\b\.|[?!]\.) # lookbehind for valid assignment
          \s*
          \b([\p{Pc}\p{L}]\w*)\b\s+ # Label
          (:?=)\s+ # Assignment operator

          (
            # ignore all keywords
            (?!
              (?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b
              (?: # keywords
                [io]n|of|[ai]s|by|has|old|new|del
                |unset|ref|deref|and|x?or|not
                |const|let|mut|dyn|va[rl]|use
                |given|expr|eval|init|comp
                |func|pro[pc]|type|class|actor|trait
                |impl|enum|module|model|struct|record
                |union|iter|macro|query|elem|temp|oper
                |object|realm|style|script|quote
                |go|defer|do|with|from|where
                |if|else|then|guard|when
                |for|loop|while|goto|move
                |try|throw|catch|switch
                |match|case|pass|def|defer
                |break|skip|redo|retry
                |return|yield|await|scope
                |import|export|intern|extern
                |debug|assert|check|decl
              )
              \b
            )
            [\p{Pc}\p{L}]\w* # identifier
            \b
          )?

          \s*
          \b(fn)\b\s* # function keyword
          (\|)(?!\|)
        end: (?<!\|)(\|)(?!\|)
        name: meta.function.declaration.ruko
        captures:
          1: {name: entity.name.method.ruko}
          2: {name: keyword.operator.assignment.ruko}
          3: {patterns: [{include: '#modifiers'}]}
          4: {name: storage.type.function.ruko}
          5: {name: punctuation.separator.arguments.ruko}
        endCaptures:
          1: {name: punctuation.separator.arguments.ruko}
        patterns:
          - include: '#argument-list-content'
      - comment: 'Function def before function keyword; x = func()'
        match: |
          (?x)
          \s*
          \b([\p{Pc}\p{L}]\w*)\b\s+ # Label
          (:?=)\s+ # Assignment operator

          (
            # ignore all keywords
            (?!
              (?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b
              (?: # keywords
                [io]n|of|[ai]s|by|has|old|new|del
                |unset|ref|deref|and|x?or|not
                |const|let|mut|dyn|va[rl]|use
                |given|expr|eval|init|comp
                |func|pro[pc]|type|class|actor|trait
                |impl|enum|module|model|struct|record
                |union|iter|macro|query|elem|temp|oper
                |object|realm|style|script|quote
                |go|defer|do|with|from|where
                |if|else|then|guard|when
                |for|loop|while|goto|move
                |try|throw|catch|switch
                |match|case|pass|def|defer
                |break|skip|redo|retry
                |return|yield|await|scope
                |import|export|intern|extern
                |debug|assert|check|decl
              )
              \b
            )
            [\p{Pc}\p{L}]\w* # identifier
            \b
          )?

          \s*
          (?=
            \b
            (?: # Function types
              func|pro[pc]|type|class|actor|trait
              |impl|enum|module|model|struct|record
              |union|iter|macro|query|elem|temp|oper
              |object|realm|style|script|quote
            )
            \b
          )
        name: meta.function.declaration.ruko
        captures:
          1: {name: entity.name.ruko}
          2: {name: keyword.operator.assignment.ruko}
          3: {patterns: [{include: '#modifiers'}]}
      - comment: 'Function def with function keyword; x = fn |args| { }'
        begin: |
          (?x)

          \s*
          \b([\p{Pc}\p{L}]\w*)\b\s+ # Label
          (:?=)\s+ # Assignment operator
          \s*

          (
            # ignore all keywords
            (?!
              (?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b
              (?: # keywords
                [io]n|of|[ai]s|by|has|old|new|del
                |unset|ref|deref|and|x?or|not
                |const|let|mut|dyn|va[rl]|use
                |given|expr|eval|init|comp
                |func|pro[pc]|type|class|actor|trait
                |impl|enum|module|model|struct|record
                |union|iter|macro|query|elem|temp|oper
                |object|realm|style|script|quote
                |go|defer|do|with|from|where
                |if|else|then|guard|when
                |for|loop|while|goto|move
                |try|throw|catch|switch
                |match|case|pass|def|defer
                |break|skip|redo|retry
                |return|yield|await|scope
                |import|export|intern|extern
                |debug|assert|check|decl
              )
              \b
            )
            [\p{Pc}\p{L}]\w* # identifier
            \b
          )?

          \s*
          \b(fn)\b\s* # function keyword
          (\|)(?!\|)
        end: (?<!\|)(\|)(?!\|)
        name: meta.function.declaration.ruko
        captures:
          1: {name: entity.name.ruko}
          2: {name: keyword.operator.assignment.ruko}
          3: {patterns: [{include: '#modifiers'}]}
          4: {name: storage.type.function.ruko}
          5: {name: punctuation.separator.arguments.ruko}
        endCaptures:
          1: {name: punctuation.separator.arguments.ruko}
        patterns:
          - include: '#argument-list-content'

  argument-list:
    comment: Function argument list starting and ending with |
    name: meta.function.arguments.ruko
    begin: |
      (?x)
      (?<=
        (?:
            # beginning of line
            ^
          | # separator
            [,;]
          | # opening bracket
            \#? [({\[]
          | # postfix or infix operator
            [\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]+ \s
          | # a keyword
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            [\p{Pc}\p{L}]\w*  # keyword or identifier
        ) \s*
      ) \s*
      (\|) (?=
        (?: \#?[(\[{] )? # opening bracket
        (?: [;,] \s* )* # optional separators
        (?:
          ((?:[*&%@^!~?\\\-+]|\.{3})*) # any sigils
          (\b[\p{Pc}\p{L}]\w*\b) # identifier
          ([!?]*) # optional sigils
          \s*
        )+ (?: \#? [)\]}] )? # closing bracket
      )
    captures:
      1: {name: punctuation.separator.arguments.ruko}
    end: (?<!\|)(\|)(?!\|)
    patterns:
      - include: '#argument-list-content'

  argument-list-content:
    name: meta.function.arguments.content.ruko
    patterns:
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(as)\b\s*
        name: keyword.operator.expression.as.ruko
      - match: (?<=[\w\s][(|])\.
        name: punctuation.definition.metadata.ruko
      - match: ','
        name: punctuation.separator.arguments.ruko
      - include: '#binding-pattern'

  clauses:
    patterns:
      - include: '#do-clause'
      - include: '#for-clause'
      - include: '#if-clause'
      - include: '#match-clause'
      - include: '#switch-clause'
      - include: '#catch-clause'
      - include: '#with-clause'
      - include: '#try-clause'
      - include: '#type-clause'
      - include: '#new-clause'

  new-clause:
    applyEndPatternLast: true
    begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(old|new)\b
    end: (?=)|$
    beginCaptures:
      1: {name: keyword.operator.expression.$1.ruko}
    patterns:
      - match: *entity-name
        name: entity.name.instance.ruko
      - include: '#type-clause'
      - include: '#type-keywords'
      - include: '#type-square-brackets'
      - include: '#parameter-brackets'
      - include: '#namespace-separators'
      - include: '#round-brackets'

  do-clause:
    match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(do)\b\s*
    name: keyword.control.do.ruko

  type-clause:
    patterns:
      - applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(as)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: keyword.operator.expression.as.ruko}
        patterns:
          - include: '#types'
      - applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(is\s+not|is|has\s+not|has|has\s+not|has)\b\s*
        end: (?=)|$
        beginCaptures:
          1: {name: keyword.operator.expression.is.ruko}
        patterns:
          - include: '#types'
      - applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(type)\b\s*
        end: (?=)|$
        captures:
          1: {name: keyword.other.typedef.ruko}
        patterns:
          - include: '#types'
          - match: \s*([:!=</>.^$%?*+|&~]?=)\s*
            captures:
              1: {name: keyword.operator.assignment.ruko}

  try-clause:
    begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(try|then)\b\s*
    end: \s*(:)(?=(?:[,;'"`)}\]\w\s]|\#?[(\[{]|\\.))|(?=[,;)}\]])|$
    name: meta.try.ruko
    beginCaptures:
      1: {name: keyword.control.error.ruko}
    endCaptures:
      1: {name: punctuation.separator.colon.ruko}
    patterns:
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b([io]n|of|as|await)\b\s*
        name: keyword.control.error.ruko
      - include: $self

  catch-clause:
    begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(catch)\b\s*
    end: \s*(?=[,;)}\]])|$
    name: meta.catch.ruko
    beginCaptures:
      1: {name: keyword.control.error.ruko}
    patterns:
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(as)\b\s*
        name: keyword.control.error.ruko
      - begin: \s*(\{)\s*
        end: \s*(\})\s*
        captures:
          1: {name: punctuation.definition.block.ruko}
        patterns:
          - include: '#catch-case-clause'
          - include: $self
      - include: $self

  catch-case-clause:
    patterns:
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(def|else)\b\s*(:)
        captures:
          1: {name: keyword.control.error.ruko}
          2: {name: punctuation.definition.case-statement.ruko}
      - begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(case)\b\s*
        end: \s*(:)(?=(?:[,;'"`)}\]\w\s]|\#?[(\[{]|\\.))|$
        beginCaptures:
          1: {name: keyword.control.error.ruko}
        endCaptures:
          1: {name: punctuation.definition.case-statement.ruko}
        patterns:
          - include: '#argument-list'
          - applyEndPatternLast: true
            begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(is\s+not|is|has\s+not|has)\b\s*
            end: (?=)|$
            beginCaptures:
              1: {name: keyword.control.error.ruko}
            patterns: [{include: '#types'}]
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(if\s+not|if|when\s+not|when|guard|as)\b\s*
            name: keyword.control.error.ruko
          - include: '#type-keywords'
          - include: $self

  for-clause:
    begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(for|while\s+not|while)\b\s*
    end: \s*(:)(?=(?:[,;'"`)}\]\w\s]|\#?[(\[{]|\\.))|(?=[,;)}\]])|$
    name: meta.for.ruko
    beginCaptures:
      1: {name: keyword.control.loop.ruko}
    endCaptures:
      1: {name: punctuation.separator.colon.ruko}
    patterns:
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b([io]n|of|as|await)\b\s*
        name: keyword.control.loop.ruko
      - include: $self

  if-clause:
    begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(if\s+not|if|when\s+not|when|guard)\b\s*
    end: \s*(:)(?=(?:[,;'"`)}\]\w\s]|\#?[(\[{]|\\.))|(?=[,;)}\]])|$
    name: meta.if.ruko
    beginCaptures:
      1: {name: keyword.control.conditional.ruko}
    endCaptures:
      1: {name: punctuation.separator.colon.ruko}
    patterns:
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(await)\b\s*
        name: keyword.control.conditional.ruko
      - include: $self

  match-clause:
    begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(match)\b\s*
    end: \s*(?=[,;)}\]])|$
    name: meta.match.ruko
    beginCaptures:
      1: {name: keyword.control.match.ruko}
    patterns:
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(await)\b\s*
        name: keyword.control.match.ruko
      - begin: \s*(\{)\s*
        end: \s*(\})\s*
        captures:
          1: {name: punctuation.definition.block.ruko}
        patterns:
          - include: '#match-case-clause'
          - include: $self
      - include: $self

  match-case-clause:
    patterns:
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(def|else)\b\s*(:)
        captures:
          1: {name: keyword.control.match.ruko}
          2: {name: punctuation.definition.case-statement.ruko}
      - begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(case)\b\s*
        end: \s*(:)(?=(?:[,;'"`)}\]\w\s]|\#?[(\[{]|\\.))|$
        beginCaptures:
          1: {name: keyword.control.match.ruko}
        endCaptures:
          1: {name: punctuation.definition.case-statement.ruko}
        patterns:
          - include: '#argument-list'
          - applyEndPatternLast: true
            begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(is\s+not|is|has\s+not|has)\b\s*
            end: (?=)|$
            beginCaptures:
              1: {name: keyword.control.match.ruko}
            patterns: [{include: '#types'}]
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(if\s+not|if|when\s+not|when|guard|as)\b\s*
            name: keyword.control.match.ruko
          - include: '#type-keywords'
          - include: $self

  switch-clause:
    begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(switch)\b\s*
    end: \s*(:)(?=(?:[,;'"`)}\]\w\s]|\#?[(\[{]|\\.))|(?=[,;)}\]])|$
    name: meta.switch.ruko
    beginCaptures:
      1: {name: keyword.control.switch.ruko}
    patterns:
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(await)\b\s*
        name: keyword.control.switch.ruko
      - begin: \s*(\{)\s*
        end: \s*(\})\s*
        captures:
          1: {name: punctuation.definition.block.ruko}
        patterns:
          - include: '#switch-case-clause'
          - include: $self
      - include: $self

  switch-case-clause:
    patterns:
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(def|else)\b\s*(:)
        captures:
          1: {name: keyword.control.switch.ruko}
          2: {name: punctuation.definition.case-statement.ruko}
      - begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(case)\b\s*
        end: \s*(:)(?=(?:[,;'"`)}\]\w\s]|\#?[(\[{]|\\.))|$
        beginCaptures:
          1: {name: keyword.control.switch.ruko}
        endCaptures:
          1: {name: punctuation.definition.case-statement.ruko}
        patterns:
          - include: '#argument-list'
          - applyEndPatternLast: true
            begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(is\s+not|is|has\s+not|has)\b\s*
            end: (?=)|$
            beginCaptures:
              1: {name: keyword.control.switch.ruko}
            patterns: [{include: '#types'}]
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(if\s+not|if|when\s+not|when|guard|as)\b\s*
            name: keyword.control.switch.ruko
          - include: '#type-keywords'
          - include: $self

  with-clause:
    begin: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(with)\b\s*
    end: \s*(:)(?=(?:[,;'"`)}\]\w\s]|\#?[(\[{]|\\.))|(?=[,;)}\]])|$
    name: meta.if.ruko
    beginCaptures:
      1: {name: keyword.control.with.ruko}
    endCaptures:
      1: {name: punctuation.separator.colon.ruko}
    patterns:
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(await)\b\s*
        name: keyword.control.with.ruko
      - include: $self

  # Binding patterns

  object-key:
    begin: (?<=^|[,;]|\#?[(\[{])\s*
    end: \s*(?=[,;)\]}]|$)|\s*(:)
    name: meta.object-key.ruko
    endCaptures:
      1: {name: punctuation.separator.key-value.ruko}
    patterns:
      - include: '#literals'
      - include: '#embedded-expressions'
      - include: '#brackets'
      - match: (?<=^|[,;]|\#?[(\[{])\s*\b[\p{Pc}\p{L}]\w*\b\s*(?=[,;)\]}:]|$)
        name: constant.other.object.key.ruko
      - include: '#space'
      - include: '#comments'
      - include: '#line-continuation'
      - include: $self

  object-value:
    patterns:
      - match: (?<=(?:^|[,;(\[{])\s*)\b[\p{Pc}\p{L}]\w*\b(?=\s*(?:[,;)\]}]|=(?:['"`\w\s]|\#?[(\[{])|$))
        name: variable.other.constant.ruko
      - match: (?<=^|[,;]|\#?[(\[{])\s*\b[\p{Pc}\p{L}]\w*\b\s*(?=[,;)\]}]|=(?:['"`\w\s]|\#?[(\[{])|$)
        name: variable.other.constant.ruko

  object-argument:
    patterns:
      - match: (?<=(?:^|[,;(\[{])\s*)\b[\p{Pc}\p{L}]\w*\b(?=\s*(?:[,;)\]}]|=(?:['"`\w\s]|\#?[(\[{])|$))
        name: variable.parameter.ruko
      - match: (?<=^|[,;]|\#?[(\[{])\s*\b[\p{Pc}\p{L}]\w*\b\s*(?=[,;)\]}]|=(?:['"`\w\s]|\#?[(\[{])|$)
        name: variable.parameter.ruko

  as-keyword:
    match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(as)\b\s*
    name: keyword.operator.expression.as.ruko

  given-using-keyword:
    match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(given|using)\b\s*
    name: keyword.operator.expression.$1.ruko

  binding-pattern-object:
    begin: (\#?{)\s*
    end: \s*(\})
    name: meta.brace.curly.ruko
    captures:
      1: {name: punctuation.definition.binding-pattern.object.ruko}
    patterns:
      - include: '#object-argument'
      - include: '#labels'
      - include: '#object-key'
      - match: ;|,
        name: punctuation.separator.mapping.ruko
      - include: '#binding-pattern'
      - include: '#illegal'

  binding-pattern-tuple:
    begin: (\#?\()\s*
    end: \s*(\))
    name: meta.brace.curly.ruko
    captures:
      1: {name: punctuation.definition.binding-pattern.tuple.ruko}
    patterns:
      - include: '#labels'
      - match: ;|,
        name: punctuation.separator.arguments.ruko
      - include: '#binding-pattern'
      - include: '#illegal'

  binding-pattern-array:
    begin: (\#?\[)\s*
    end: \s*(])
    name: meta.brace.curly.ruko
    captures:
      1: {name: punctuation.definition.binding-pattern.array.ruko}
    patterns:
      - include: '#labels'
      - match: ;|,
        name: punctuation.separator.sequence.ruko
      - include: '#binding-pattern'
      - include: '#illegal'

  default-value:
    begin: (?<=^|[\s({\[])(\=)(?=$|[)}\]\s])|(?<=['"`)}\]\w]|\\.)(\=)(?=(?:['"`\w]|\#?[(\[{]))
    captures:
      1: {name: keyword.operator.assignment.ruko}
      2: {name: keyword.operator.assignment.ruko}
    end: (?=\|(?:$|[^|])|[,;)}\]])
    patterns:
      - include: $self

  binding-pattern:
    patterns:
      - include: '#default-value'
      - include: '#as-keyword'
      - include: '#given-using-keyword'
      - include: '#binding-pattern-object'
      - include: '#binding-pattern-tuple'
      - include: '#binding-pattern-array'
      - include: '#parameter-variables'
      - include: '#type-operators'
      - include: '#type-signature'
      - include: '#space'
      - include: '#comments'
      - include: '#function-calls'
      - include: '#literals'
      - include: '#embedded-expressions'
      - include: '#brackets'

  # Object labels

  labels:
    patterns:
      - comment: 'Function def before function keyword: x = def()'
        match: |
          (?x)
          (?<=^|[,;]|\#?[(\[{])\s*

          (\b[\p{Pc}\p{L}][\p{Pd}\w]*\b) # Label
          (:) # Key value separator
          \s*\b

          (
            # ignore all keywords
            (?!
              (?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b
              (?: # keywords
                [io]n|of|[ai]s|by|has|old|new|del
                |unset|ref|deref|and|x?or|not
                |const|let|mut|dyn|va[rl]|use
                |given|expr|eval|init|comp
                |func|pro[pc]|type|class|actor|trait
                |impl|enum|module|model|struct|record
                |union|iter|macro|query|elem|temp|oper
                |object|realm|style|script|quote
                |go|defer|do|with|from|where
                |if|else|then|guard|when
                |for|loop|while|goto|move
                |try|throw|catch|switch
                |match|case|pass|def|defer
                |break|skip|redo|retry
                |return|yield|await|scope
                |import|export|intern|extern
                |debug|assert|check|decl
              )
              \b
            )
            [\p{Pc}\p{L}]\w* # identifier
            \b
          )?

          \s*
          (?=
            \b
            (?: # Function types
              func|pro[pc]|type|class|actor|trait
              |impl|enum|module|model|struct|record
              |union|iter|macro|query|elem|temp|oper
              |object|realm|style|script|quote
            )
            \b
          )
        name: meta.object-literal.key.ruko
        captures:
          1: {name: entity.name.ruko}
          2: {name: punctuation.separator.key-value.ruko}
          3: {patterns: [{include: '#modifiers'}]}
      - begin: |
          (?x)
          (?<=^|[,;]|\#?[(\[{])\s*

          (\b[\p{Pc}\p{L}][\p{Pd}\w]*\b) # Label
          (:) # Key value separator
          \s*\b

          (
            # ignore all keywords
            (?!
              (?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b
              (?: # keywords
                [io]n|of|[ai]s|by|has|old|new|del
                |unset|ref|deref|and|x?or|not
                |const|let|mut|dyn|va[rl]|use
                |given|expr|eval|init|comp
                |func|pro[pc]|type|class|actor|trait
                |impl|enum|module|model|struct|record
                |union|iter|macro|query|elem|temp|oper
                |object|realm|style|script|quote
                |go|defer|do|with|from|where
                |if|else|then|guard|when
                |for|loop|while|goto|move
                |try|throw|catch|switch
                |match|case|pass|def|defer
                |break|skip|redo|retry
                |return|yield|await|scope
                |import|export|intern|extern
                |debug|assert|check|decl
              )
              \b
            )
            [\p{Pc}\p{L}]\w* # identifier
            \b
          )?

          \s*
          \b(fn)\b\s* # function keyword
          (\|)(?!\|)
        end: (?<!\|)(\|)(?!\|)
        name: meta.object-literal.key.ruko
        beginCaptures:
          1: {name: entity.name.ruko}
          2: {name: punctuation.separator.key-value.ruko}
          3: {patterns: [{include: '#modifiers'}]}
          4: {name: storage.type.function.ruko}
          5: {name: punctuation.separator.arguments.ruko}
        endCaptures:
          1: {name: punctuation.separator.arguments.ruko}
        patterns:
          - include: '#argument-list-content'
      - match: |
          (?x)
          (?<=^|[,;]|\#?[(\[{])\s*
          (\b[\p{Pc}\p{L}][\p{Pd}\w]*\b) # label
          (?=:(?:[,;'"`)}\]\w\s]|\#?[(\[{]|\\.)) # lookahead for key-value separator
        name: meta.object-literal.key.ruko
        captures:
          1:
            name: constant.other.object.key.ruko
            patterns:
              - include: '#constants'
              - include: '#numbers'
              - include: '#symbols'
              - include: '#xml-regex-content'

  # Punctuation

  punctuation:
    patterns:
      - include: '#line-continuation'
      - include: '#comma'
      - include: '#double-semicolon'
      - include: '#semicolon'

  line-continuation:
    begin: \s*(\\)\s*(?=/[/*](?![\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]+)|$)
    end: ^\s*(?=\S)
    captures:
      1: {name: punctuation.separator.continuation.line.ruko}
    patterns: [{include: '#comments'}]

  comma:
    match: \s*(,)
    captures:
      1: {name: punctuation.separator.expression.ruko}
  double-semicolon:
    match: \s*(;;)
    captures:
      1: {name: punctuation.terminator.statement.ruko}
  semicolon:
    match: \s*(;)
    captures:
      1: {name: punctuation.terminator.expression.ruko}

  brackets:
    patterns:
      - include: '#angle-brackets'
      - include: '#curly-brackets'
      - include: '#square-brackets'
      - include: '#round-brackets'

  generics: &generics
    patterns:
      - comment: <> exception
        match: (?<=^|['"`)}\]>\w\s]|(?:[?!]\.|[?!:]:|[?!-]>)=?)(<)(>)(?=[!~]?(?:['"`\w<]|\#?[(\[{]))
        captures:
          1: {name: punctuation.type.arguments.ruko}
          2: {name: punctuation.type.arguments.ruko}
      - comment: <...> with content
        name: meta.type-arguments.ruko
        begin: (?<=^|['"`)}\]>\w\s]|(?:[?!]\.|[?!:]:|[?!-]>)=?)(<)(?=[!@#$%^&*\-+|\\/~:.?<]*(?:['"`\w]|\#?[(\[{]))
        end: (?<=^|['"`)}\]>\w])(>)(?:(!)|(~))?
        beginCaptures:
          1:
            name: punctuation.type.arguments.ruko
            patterns: [{include: '#accessor-operators'}]
          2:
            name: punctuation.type.arguments.ruko
        endCaptures:
          1: {name: punctuation.type.arguments.ruko}
          2: {name: keyword.operator.macro.ruko}
          3: {name: keyword.operator.destructor.ruko}
        patterns:
          - include: '#punctuation'
          - include: '#brackets'
          - include: '#types'
          - include: '#type-signature'
          - include: '#embedded-expressions'
          - include: '#embedded-formatting'
          - include: '#embedded-arguments'

  accessor-operators:
    name: punctuation.type.arguments.ruko
    match: |
      (?x)
      (?<=\b|>)
      (?:
        ( \?[.:>]=? ) | # 1: optional access/unwrap
        ( ![.:>]=? ) | # 2: assert/unwrap operator
        ( (?:::|\.|->)=? ) # 3: standard accessor
      )
      (?=\b|<)
    captures:
      1: {name: keyword.operator.optional.ruko}
      2: {name: keyword.operator.assert.ruko}
      3: {name: keyword.operator.accessor.ruko}

  angle-brackets: *generics

  curly-brackets:
    repository:
      punctuation:
        patterns:
          - match: ','
            name: punctuation.separator.mapping.ruko
          - match: (?<=(?:['"`)}\]\w]|\\.)[\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]*):(?=(?:['"`\w\s]|\#?[(\[{])|$)
            name: punctuation.separator.key-value.ruko

    patterns:
      - begin: |
          (?x)
          (?<=
            (?:
                (?:^|[\s\p{P}\p{S}]):\|\s*\| # beside a lambda pipe
              | (?:^|[,;'"`)}\]\w\s]|\\.)\|
              | ^\s*\|
            )
          )
          \s*
          (\#\{)
          \s*
        end: \s*(\})
        name: meta.brace.curly.ruko
        captures:
          1: {name: punctuation.section.class.ruko}
        patterns:
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:
                (?:^|[\s\p{P}\p{S}]):\|\s*\| # beside a lambda pipe
              | (?:^|[,;'"`)}\]\w\s]|\\.)\|
              | ^\s*\|
            )
          )
          \s*
          (\{)
          \s*
        end: \s*(\})
        name: meta.brace.curly.ruko
        captures:
          1: {name: punctuation.definition.block.ruko}
        patterns:
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \b
              (?: # destructuring keywords
                const|let|mut|dyn|va[rl]|use
                |given|expr|eval|init|comp
                |case
              )
            \b
            (?:$|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \s*
          )
          (\#?\{)\s*
        end: \s*(\})
        name: meta.brace.curly.ruko
        captures:
          1:
            name: punctuation.definition.binding-pattern.object.ruko
        patterns:
          - include: '#labels'
          - include: '#punctuation'
          - include: '#object-value'
          - include: '#object-key'
          - include: '#as-keyword'
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \b
              (?: # expression keywords
                [io]n|of|[ai]s|by|has|old|new|del
                |unset|ref|deref|and|x?or|not
              )
            \b
            (?:$|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \s*
          )
          (\#\{)\s*
        end: \s*(\})
        name: meta.brace.curly.ruko
        captures:
          1: {name: punctuation.definition.mapping.ruko}
        patterns:
          - include: '#labels'
          - include: '#punctuation'
          - include: '#object-value'
          - include: '#object-key'
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \b
              (?: # expression keywords
                [io]n|of|[ai]s|by|has|old|new|del
                |unset|ref|deref|and|x?or|not
              )
            \b
            (?:$|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \s*
          )
          (\{)\s*
        end: \s*(\})
        name: meta.brace.curly.ruko
        captures:
          1: {name: punctuation.definition.dictionary.ruko}
        patterns:
          - include: '#labels'
          - include: '#punctuation'
          - include: '#object-value'
          - include: '#object-key'
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:
                [,;({\[]
              | (?:^|[,;({\[)}\]\w'"`]|\\.):\s*
              | [\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]+
            )
            \s*
          )
          (\#\{)\s*
        end: \s*(\})
        name: meta.brace.curly.ruko
        captures:
          1: {name: punctuation.definition.mapping.ruko}
        patterns:
          - include: '#labels'
          - include: '#punctuation'
          - include: '#object-value'
          - include: '#object-key'
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:
                [,;({\[]
              | (?:^|[,;({\[)}\]\w'"`]|\\.):\s*
              | [\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]+
            )
            \s*
          )
          (\{)\s*
        end: \s*(\})
        name: meta.brace.curly.ruko
        captures:
          1: {name: punctuation.definition.dictionary.ruko}
        patterns:
          - include: '#labels'
          - include: '#punctuation'
          - include: '#object-value'
          - include: '#object-key'
          - include: $self
      - begin: (\#\{)\s*
        end: \s*(\})
        name: meta.brace.curly.ruko
        captures:
          1: {name: punctuation.section.class.ruko}
        patterns:
          - include: $self
      - begin: (\{)\s*
        end: \s*(\})
        name: meta.brace.curly.ruko
        captures:
          1: {name: punctuation.definition.block.ruko}
        patterns:
          - include: $self

  round-brackets:
    repository:
      punctuation:
        patterns:
          - match: ','
            name: punctuation.separator.arguments.ruko
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b(as)\b\s*
            name: keyword.operator.expression.as.ruko
          - match: (?<=[\w\s][(|])\.
            name: punctuation.definition.metadata.ruko

    patterns:
      - begin: |
          (?x)
          (?<=
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \b
              (?: # destructuring keywords
                const|let|mut|dyn|va[rl]|use
                |given|expr|eval|init|comp
                |case
              )
            \b
            (?:$|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \s*
          )
          (\#?\()\s*
        end: \s*(\))
        name: meta.brace.round.ruko
        captures:
          1: {name: punctuation.definition.binding-pattern.tuple.ruko}
        patterns:
          - include: '#as-keyword'
          - include: '#punctuation'
          - include: $self
      - begin: |
          (?x)
          (?<= # literal
              (?: [\w'"`)}\]] | \\.) >* !?
            | [^.]\.=?|[?!:]:=?
          )
          (\#?\()\s*
        end: \s*(\))
        name: meta.brace.round.ruko
        captures:
          1: {name: punctuation.definition.parameters.ruko}
        patterns:
          - include: '#parameter-variables'
          - include: $self
      - begin: (\#\()\s*
        end: \s*(\))
        name: meta.brace.round.ruko
        captures:
          1: {name: punctuation.definition.tuple.ruko}
        patterns:
          - include: $self
      - begin: (\()\s*
        end: \s*(\))
        name: meta.brace.round.ruko
        captures:
          1: {name: punctuation.definition.expression.ruko}
        patterns:
          - include: $self

  square-brackets:
    repository:
      punctuation:
        patterns:
          - match: ','
            name: punctuation.separator.sequence.ruko

    patterns:
      - begin: |
          (?x)
          (?<=
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \b
              (?: # destructuring keywords
                const|let|mut|dyn|va[rl]|use
                |given|expr|eval|init|comp
                |case
              )
            \b
            (?:$|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \s*
          )
          (\#?\[)\s*
        end: \s*(\])
        name: meta.brace.square.ruko
        captures:
          1: {name: punctuation.definition.binding-pattern.array.ruko}
        patterns:
          - include: '#punctuation'
          - include: '#as-keyword'
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \b
              (?: # destructuring keywords
                [io]n|of|[ai]s|by|has|old|new|del
                |unset|ref|deref|and|x?or|not
              )
            \b
            (?:$|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \s*
          )
          (\[)\s*
        end: \s*(\])
        name: meta.brace.square.ruko
        captures:
          1: {name: punctuation.definition.sequence.ruko}
        patterns:
          - include: '#message-passing'
          - include: '#punctuation'
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \b
              (?: # destructuring keywords
                [io]n|of|[ai]s|by|has|old|new|del
                |unset|ref|deref|and|x?or|not
              )
            \b
            (?:$|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \s*
          )
          (\[)\s*
        end: \s*(\])
        name: meta.brace.square.ruko
        captures:
          1: {name: punctuation.definition.array.ruko}
        patterns:
          - include: '#message-passing'
          - include: '#punctuation'
          - include: $self
      - begin: |
          (?x)
          (?<= # literal
              (?: [\w'"`)}\]] | \\.)
            | [^.]\.=?|[?!:]:=?
          )
          (\#?\[)\s*
        end: \s*(\])
        name: meta.brace.square.ruko
        captures:
          1: {name: punctuation.definition.attribute-selector.ruko}
        patterns:
          - include: '#slice-syntax'
          - include: '#punctuation'
          - include: $self
      - begin: (\#\[)\s*
        end: \s*(\])
        name: meta.brace.square.ruko
        captures:
          1: {name: punctuation.definition.sequence.ruko}
        patterns:
          - include: '#message-passing'
          - include: '#punctuation'
          - include: $self
      - begin: (\[)\s*
        end: \s*(\])
        name: meta.brace.square.ruko
        captures:
          1: {name: punctuation.definition.array.ruko}
        patterns:
          - include: '#message-passing'
          - include: '#punctuation'
          - include: $self

  # Slicing syntax

  slice-syntax:
    patterns:
      - match: (?<=[:'"`\w\s]|\\.)(:)(?=[:'"`\w\s]|\#?[(\[{]|$)
        name: keyword.operator.slice.ruko
      - include: '#numbers'
      - include: '#space'
      - include: '#comments'
      - include: '#line-continuation'

  # Objective-C-style messages

  message-passing:
    patterns:
      - include: '#literals'
      - include: '#constants'
      - applyEndPatternLast: true
        begin: |
          (?x)
          (?<= # literal
            (?: 
                ^ # start of line
              | [\w'"`)}\]] # literals and closing brackets
              | [?!:]:[\p{Pc}\p{L}]\w* # identifiers
              | [?!][\p{Pc}\p{L}]\w* # identifiers
              | \\. # escape sequences
            ) 
            \s*
          )
          \s*
          ([?!][:>]?=?|[:>])? # message access operator
          ( # Message name
            \b
            # ignore all keywords
            (?!
              (?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b
              (?: # keywords
                [io]n|of|[ai]s|by|has|old|new|del
                |unset|ref|deref|and|x?or|not
                |const|let|mut|dyn|va[rl]|use
                |given|expr|eval|init|comp
                |func|pro[pc]|type|class|actor|trait
                |impl|enum|module|model|struct|record
                |union|iter|macro|query|elem|temp|oper
                |object|realm|style|script|quote
                |go|defer|do|with|from|where
                |if|else|then|guard|when
                |for|loop|while|goto|move
                |try|throw|catch|switch
                |match|case|pass|def|defer
                |break|skip|redo|retry
                |return|yield|await|scope
                |import|export|intern|extern
                |debug|assert|check|decl
              )
              \b
            )
            \b
            [\p{Pc}\p{L}]\w* # identifier
            \b
          )
          (:)
        end: (?=)|$
        name: meta.message.ruko
        beginCaptures:
          1:
            patterns:
              - match: |
                  (?x)
                  (?:
                    ( \?[:>]?=? ) | # 1: optional access/unwrap
                    ( ![:>]?=? ) | # 2: assert/unwrap operator
                    ( [:>]?=? ) # 3: access operator
                  )
                captures:
                  1: {name: keyword.operator.optional.ruko}
                  2: {name: keyword.operator.assert.ruko}
                  3: {name: keyword.operator.accessor.ruko}
          2:
            patterns:
              - match: |
                  (?x)
                  (?: # Regular variables
                    # Leading underscore
                    (\p{Pc}+\w*(?!\p{Pc}+))
                  | # Train case
                    ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)
                  | # Pascal case
                    ((?:[\p{Pc}\p{L}&&\P{Ll}][\w&&\P{Lu}]*)+)
                  | # Camel or kebab case
                    ([\p{Pc}\p{L}]\w*)
                  )
                captures:
                  1:
                    patterns: *builtin-names
                    name: entity.name.tag.ruko
                  2:
                    patterns: *builtin-names
                    name: entity.name.tag.ruko support.class.component.ruko
                  3:
                    patterns: *builtin-names
                    name: entity.name.class.builtin.ruko
                  4:
                    patterns: *builtin-names
                    name: entity.name.function.member.ruko
          3: {name: punctuation.separator.arguments.ruko}
        patterns:
          - include: '#brackets'
      - match: |
          (?x)
          (?<=\#?\[[\p{P}\p{S}&&[^,;'"`({\[)}\]\p{Pc}]]*)
          \s*
          ( # Message name
            \b
            # ignore all keywords
            (?!
              (?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b
              (?: # keywords
                [io]n|of|[ai]s|by|has|old|new|del
                |unset|ref|deref|and|x?or|not
                |const|let|mut|dyn|va[rl]|use
                |given|expr|eval|init|comp
                |func|pro[pc]|type|class|actor|trait
                |impl|enum|module|model|struct|record
                |union|iter|macro|query|elem|temp|oper
                |object|realm|style|script|quote
                |go|defer|do|with|from|where
                |if|else|then|guard|when
                |for|loop|while|goto|move
                |try|throw|catch|switch
                |match|case|pass|def|defer
                |break|skip|redo|retry
                |return|yield|await|scope
                |import|export|intern|extern
                |debug|assert|check|decl
              )
              \b
            )
            \b
            [\p{Pc}\p{L}]\w* # identifier
            \b
          )
          \s*
          (?= 
            (?:[?!][:>]?=?|[:>])? # message access operator
            (?: # function name
              \b
              # ignore all keywords
              (?!
                (?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b
                (?: # keywords
                  [io]n|of|[ai]s|by|has|old|new|del
                  |unset|ref|deref|and|x?or|not
                  |const|let|mut|dyn|va[rl]|use
                  |given|expr|eval|init|comp
                  |func|pro[pc]|type|class|actor|trait
                  |impl|enum|module|model|struct|record
                  |union|iter|macro|query|elem|temp|oper
                  |object|realm|style|script|quote
                  |go|defer|do|with|from|where
                  |if|else|then|guard|when
                  |for|loop|while|goto|move
                  |try|throw|catch|switch
                  |match|case|pass|def|defer
                  |break|skip|redo|retry
                  |return|yield|await|scope
                  |import|export|intern|extern
                  |debug|assert|check|decl
                )
                \b
              )
              \b
              [\p{Pc}\p{L}]\w* # identifier
              \b
            ) 
          )
        name: meta.message.ruko
        captures:
          1:
            patterns:
              - match: |
                  (?x)
                  (?: # Regular variables
                    # Leading underscore
                    (\p{Pc}+\w*(?!\p{Pc}+))
                  | # Train case
                    ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)
                  | # Pascal case
                    ((?:[\p{Pc}\p{L}&&\P{Ll}][\w&&\P{Lu}]*)+)
                  | # Camel or kebab case
                    ([\p{Pc}\p{L}]\w*)
                  )
                captures:
                  1: {name: variable.other.global.ruko}
                  2: {name: variable.other.constant.object.ruko}
                  3: {name: variable.other.class.stat.ruko}
                  4: {name: variable.other.object.ruko}
      - match: |
          (?x)
          (?<= # literal
            (?: 
                [\w'"`)}\]] # literals and closing brackets
              | (?:[?!][:>]?=?|[:>])?[\p{Pc}\p{L}]\w* # identifiers
              | \\. # escape sequences
              | [;,] # punctuation
              | ^ # start of line
            ) 
            \s*
          )
          \s*
          ([?!][:>]?=?|[:>])? # message access operator
          ( # Message name
            \b
            # ignore all keywords
            (?!
              (?<!(?:(?<!\.)\.|[?!:]:|[?!-]>)=?)\b
              (?: # keywords
                [io]n|of|[ai]s|by|has|old|new|del
                |unset|ref|deref|and|x?or|not
                |const|let|mut|dyn|va[rl]|use
                |given|expr|eval|init|comp
                |func|pro[pc]|type|class|actor|trait
                |impl|enum|module|model|struct|record
                |union|iter|macro|query|elem|temp|oper
                |object|realm|style|script|quote
                |go|defer|do|with|from|where
                |if|else|then|guard|when
                |for|loop|while|goto|move
                |try|throw|catch|switch
                |match|case|pass|def|defer
                |break|skip|redo|retry
                |return|yield|await|scope
                |import|export|intern|extern
                |debug|assert|check|decl
              )
              \b
            )
            \b
            [\p{Pc}\p{L}]\w* # identifier
            \b
          )
        name: meta.message.ruko
        captures:
          1:
            patterns:
              - match: |
                  (?x)
                  (?:
                    ( \?[:>]?=? ) | # 1: optional access/unwrap
                    ( ![:>]?=? ) | # 2: assert/unwrap operator
                    ( [:>]?=? ) # 3: access operator
                  )
                captures:
                  1: {name: keyword.operator.optional.ruko}
                  2: {name: keyword.operator.assert.ruko}
                  3: {name: keyword.operator.accessor.ruko}
          2:
            patterns:
              - match: |
                  (?x)
                  (?: # Regular variables
                    # Leading underscore
                    (\p{Pc}+\w*(?!\p{Pc}+))
                  | # Train case
                    ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)
                  | # Pascal case
                    ((?:[\p{Pc}\p{L}&&\P{Ll}][\w&&\P{Lu}]*)+)
                  | # Camel or kebab case
                    ([\p{Pc}\p{L}]\w*)
                  )
                captures:
                  1: {name: variable.other.property.dynamic.ruko}
                  2: {name: variable.other.constant.property.ruko}
                  3: {name: variable.other.property.stat.ruko}
                  4: {name: variable.other.property.ruko}
      - include: '#function-calls'
      - include: '#type-signature'

  # Support

  css-property-names:
    patterns:
      - match: |
          (?x)\b(
            accent-color|additive-symbols|align-content|align-items|align-self|all|animation|animation-delay|animation-direction|animation-duration
            |animation-fill-mode|animation-iteration-count|animation-name|animation-play-state|animation-timing-function|aspect-ratio|backdrop-filter
            |backface-visibility|background|background-attachment|background-blend-mode|background-clip|background-color|background-image
            |background-origin|background-position|background-position-[xy]|background-repeat|background-size|bleed|block-size|border
            |border-block-end|border-block-end-color|border-block-end-style|border-block-end-width|border-block-start|border-block-start-color
            |border-block-start-style|border-block-start-width|border-bottom|border-bottom-color|border-bottom-left-radius|border-bottom-right-radius
            |border-bottom-style|border-bottom-width|border-collapse|border-color|border-end-end-radius|border-end-start-radius|border-image
            |border-image-outset|border-image-repeat|border-image-slice|border-image-source|border-image-width|border-inline-end
            |border-inline-end-color|border-inline-end-style|border-inline-end-width|border-inline-start|border-inline-start-color
            |border-inline-start-style|border-inline-start-width|border-left|border-left-color|border-left-style|border-left-width
            |border-radius|border-right|border-right-color|border-right-style|border-right-width|border-spacing|border-start-end-radius
            |border-start-start-radius|border-style|border-top|border-top-color|border-top-left-radius|border-top-right-radius|border-top-style
            |border-top-width|border-width|bottom|box-decoration-break|box-shadow|box-sizing|break-after|break-before|break-inside|caption-side
            |caret-color|clear|clip|clip-path|clip-rule|color|color-adjust|color-interpolation-filters|color-scheme|column-count|column-fill|column-gap
            |column-rule|column-rule-color|column-rule-style|column-rule-width|column-span|column-width|columns|contain|container|container-name|container-type|content|counter-increment
            |counter-reset|cursor|direction|display|empty-cells|enable-background|fallback|fill|fill-opacity|fill-rule|filter|flex|flex-basis
            |flex-direction|flex-flow|flex-grow|flex-shrink|flex-wrap|float|flood-color|flood-opacity|font|font-display|font-family
            |font-feature-settings|font-kerning|font-language-override|font-optical-sizing|font-size|font-size-adjust|font-stretch
            |font-style|font-synthesis|font-variant|font-variant-alternates|font-variant-caps|font-variant-east-asian|font-variant-ligatures
            |font-variant-numeric|font-variant-position|font-variation-settings|font-weight|gap|glyph-orientation-horizontal|glyph-orientation-vertical
            |grid|grid-area|grid-auto-columns|grid-auto-flow|grid-auto-rows|grid-column|grid-column-end|grid-column-gap|grid-column-start
            |grid-gap|grid-row|grid-row-end|grid-row-gap|grid-row-start|grid-template|grid-template-areas|grid-template-columns|grid-template-rows
            |hanging-punctuation|height|hyphens|image-orientation|image-rendering|image-resolution|ime-mode|initial-letter|initial-letter-align
            |inline-size|inset|inset-block|inset-block-end|inset-block-start|inset-inline|inset-inline-end|inset-inline-start|isolation
            |justify-content|justify-items|justify-self|kerning|left|letter-spacing|lighting-color|line-break|line-clamp|line-height|list-style
            |list-style-image|list-style-position|list-style-type|margin|margin-block|margin-block-end|margin-block-start|margin-bottom|margin-inline|margin-inline-end|margin-inline-start
            |margin-left|margin-right|margin-top|marker-end|marker-mid|marker-start|marks|mask|mask-border|mask-border-mode|mask-border-outset
            |mask-border-repeat|mask-border-slice|mask-border-source|mask-border-width|mask-clip|mask-composite|mask-image|mask-mode
            |mask-origin|mask-position|mask-repeat|mask-size|mask-type|max-block-size|max-height|max-inline-size|max-lines|max-width
            |max-zoom|min-block-size|min-height|min-inline-size|min-width|min-zoom|mix-blend-mode|negative|object-fit|object-position
            |offset|offset-anchor|offset-distance|offset-path|offset-position|offset-rotation|opacity|order|orientation|orphans
            |outline|outline-color|outline-offset|outline-style|outline-width|overflow|overflow-anchor|overflow-block|overflow-inline
            |overflow-wrap|overflow-[xy]|overscroll-behavior|overscroll-behavior-block|overscroll-behavior-inline|overscroll-behavior-[xy]
            |pad|padding|padding-block|padding-block-end|padding-block-start|padding-bottom|padding-inline|padding-inline-end|padding-inline-start|padding-left
            |padding-right|padding-top|page-break-after|page-break-before|page-break-inside|paint-order|perspective|perspective-origin
            |place-content|place-items|place-self|pointer-events|position|prefix|quotes|range|resize|right|rotate|row-gap|ruby-align
            |ruby-merge|ruby-position|scale|scroll-behavior|scroll-margin|scroll-margin-block|scroll-margin-block-end|scroll-margin-block-start
            |scroll-margin-bottom|scroll-margin-inline|scroll-margin-inline-end|scroll-margin-inline-start|scroll-margin-left|scroll-margin-right
            |scroll-margin-top|scroll-padding|scroll-padding-block|scroll-padding-block-end|scroll-padding-block-start|scroll-padding-bottom
            |scroll-padding-inline|scroll-padding-inline-end|scroll-padding-inline-start|scroll-padding-left|scroll-padding-right
            |scroll-padding-top|scroll-snap-align|scroll-snap-coordinate|scroll-snap-destination|scroll-snap-stop|scroll-snap-type
            |scrollbar-color|scrollbar-gutter|scrollbar-width|shape-image-threshold|shape-margin|shape-outside|shape-rendering|size
            |speak-as|src|stop-color|stop-opacity|stroke|stroke-dasharray|stroke-dashoffset|stroke-linecap|stroke-linejoin|stroke-miterlimit
            |stroke-opacity|stroke-width|suffix|symbols|system|tab-size|table-layout|text-align|text-align-last|text-anchor|text-combine-upright
            |text-decoration|text-decoration-color|text-decoration-line|text-decoration-skip|text-decoration-skip-ink|text-decoration-style|text-decoration-thickness
            |text-emphasis|text-emphasis-color|text-emphasis-position|text-emphasis-style|text-indent|text-justify|text-orientation
            |text-overflow|text-rendering|text-shadow|text-size-adjust|text-transform|text-underline-offset|text-underline-position|top|touch-action|transform
            |transform-box|transform-origin|transform-style|transition|transition-delay|transition-duration|transition-property|transition-timing-function
            |translate|unicode-bidi|unicode-range|user-select|user-zoom|vertical-align|visibility|white-space|widows|width|will-change
            |word-break|word-spacing|word-wrap|writing-mode|z-index|zoom

            # SVG attributes
            |alignment-baseline|baseline-shift|clip-rule|color-interpolation|color-interpolation-filters|color-profile
            |color-rendering|cx|cy|dominant-baseline|enable-background|fill|fill-opacity|fill-rule|flood-color|flood-opacity
            |glyph-orientation-horizontal|glyph-orientation-vertical|height|kerning|lighting-color|marker-end|marker-mid
            |marker-start|r|rx|ry|shape-rendering|stop-color|stop-opacity|stroke|stroke-dasharray|stroke-dashoffset|stroke-linecap
            |stroke-linejoin|stroke-miterlimit|stroke-opacity|stroke-width|text-anchor|width|x|y

            # Not listed on MDN; presumably deprecated
            |adjust|after|align|align-last|alignment|alignment-adjust|appearance|attachment|azimuth|background-break
            |balance|baseline|before|bidi|binding|bookmark|bookmark-label|bookmark-level|bookmark-target|border-length
            |bottom-color|bottom-left-radius|bottom-right-radius|bottom-style|bottom-width|box|box-align|box-direction
            |box-flex|box-flex-group|box-lines|box-ordinal-group|box-orient|box-pack|break|character|collapse|column
            |column-break-after|column-break-before|count|counter|crop|cue|cue-after|cue-before|decoration|decoration-break
            |delay|display-model|display-role|down|drop|drop-initial-after-adjust|drop-initial-after-align|drop-initial-before-adjust
            |drop-initial-before-align|drop-initial-size|drop-initial-value|duration|elevation|emphasis|family|fit|fit-position
            |flex-group|float-offset|gap|grid-columns|grid-rows|hanging-punctuation|header|hyphenate|hyphenate-after|hyphenate-before
            |hyphenate-character|hyphenate-lines|hyphenate-resource|icon|image|increment|indent|index|initial-after-adjust
            |initial-after-align|initial-before-adjust|initial-before-align|initial-size|initial-value|inline-box-align|iteration-count
            |justify|label|left-color|left-style|left-width|length|level|line|line-stacking|line-stacking-ruby|line-stacking-shift
            |line-stacking-strategy|lines|list|mark|mark-after|mark-before|marks|marquee|marquee-direction|marquee-play-count|marquee-speed
            |marquee-style|max|min|model|move-to|name|nav|nav-down|nav-index|nav-left|nav-right|nav-up|new|numeral|offset|ordinal-group
            |orient|origin|overflow-style|overhang|pack|page|page-policy|pause|pause-after|pause-before|phonemes|pitch|pitch-range
            |play-count|play-during|play-state|point|presentation|presentation-level|profile|property|punctuation|punctuation-trim
            |radius|rate|rendering-intent|repeat|replace|reset|resolution|resource|respond-to|rest|rest-after|rest-before|richness
            |right-color|right-style|right-width|role|rotation|rotation-point|rows|ruby|ruby-overhang|ruby-span|rule|rule-color
            |rule-style|rule-width|shadow|size|size-adjust|sizing|space|space-collapse|spacing|span|speak|speak-header|speak-numeral
            |speak-punctuation|speech|speech-rate|speed|stacking|stacking-ruby|stacking-shift|stacking-strategy|stress|stretch
            |string-set|style|style-image|style-position|style-type|target|target-name|target-new|target-position|text|text-height
            |text-justify|text-outline|text-replace|text-wrap|timing-function|top-color|top-left-radius|top-right-radius|top-style
            |top-width|trim|unicode|up|user-select|variant|voice|voice-balance|voice-duration|voice-family|voice-pitch|voice-pitch-range
            |voice-rate|voice-stress|voice-volume|volume|weight|white|white-space-collapse|word|wrap

            # in PascalCase
            |accentColor|additiveSymbols|alignContent|alignItems|alignSelf|all|animation|animationDelay|animationDirection|animationDuration
            |animationFillMode|animationIterationCount|animationName|animationPlayState|animationTimingFunction|aspectRatio|backdropFilter
            |backfaceVisibility|background|backgroundAttachment|backgroundBlendMode|backgroundClip|backgroundColor|backgroundImage
            |backgroundOrigin|backgroundPosition|backgroundPosition[xy]|backgroundRepeat|backgroundSize|bleed|blockSize|border
            |borderBlockEnd|borderBlockEndColor|borderBlockEndStyle|borderBlockEndWidth|borderBlockStart|borderBlockStartColor
            |borderBlockStartStyle|borderBlockStartWidth|borderBottom|borderBottomColor|borderBottomLeftRadius|borderBottomRightRadius
            |borderBottomStyle|borderBottomWidth|borderCollapse|borderColor|borderEndEndRadius|borderEndStartRadius|borderImage
            |borderImageOutset|borderImageRepeat|borderImageSlice|borderImageSource|borderImageWidth|borderInlineEnd
            |borderInlineEndColor|borderInlineEndStyle|borderInlineEndWidth|borderInlineStart|borderInlineStartColor
            |borderInlineStartStyle|borderInlineStartWidth|borderLeft|borderLeftColor|borderLeftStyle|borderLeftWidth
            |borderRadius|borderRight|borderRightColor|borderRightStyle|borderRightWidth|borderSpacing|borderStartEndRadius
            |borderStartStartRadius|borderStyle|borderTop|borderTopColor|borderTopLeftRadius|borderTopRightRadius|borderTopStyle
            |borderTopWidth|borderWidth|bottom|boxDecorationBreak|boxShadow|boxSizing|breakAfter|breakBefore|breakInside|captionSide
            |caretColor|clear|clip|clipPath|clipRule|color|colorAdjust|colorInterpolationFilters|colorScheme|columnCount|columnFill|columnGap
            |columnRule|columnRuleColor|columnRuleStyle|columnRuleWidth|columnSpan|columnWidth|columns|contain|container|containerName|containerType|content|counterIncrement
            |counterReset|cursor|direction|display|emptyCells|enableBackground|fallback|fill|fillOpacity|fillRule|filter|flex|flexBasis
            |flexDirection|flexFlow|flexGrow|flexShrink|flexWrap|float|floodColor|floodOpacity|font|fontDisplay|fontFamily
            |fontFeatureSettings|fontKerning|fontLanguageOverride|fontOpticalSizing|fontSize|fontSizeAdjust|fontStretch
            |fontStyle|fontSynthesis|fontVariant|fontVariantAlternates|fontVariantCaps|fontVariantEastAsian|fontVariantLigatures
            |fontVariantNumeric|fontVariantPosition|fontVariationSettings|fontWeight|gap|glyphOrientationHorizontal|glyphOrientationVertical
            |grid|gridArea|gridAutoColumns|gridAutoFlow|gridAutoRows|gridColumn|gridColumnEnd|gridColumnGap|gridColumnStart
            |gridGap|gridRow|gridRowEnd|gridRowGap|gridRowStart|gridTemplate|gridTemplateAreas|gridTemplateColumns|gridTemplateRows
            |hangingPunctuation|height|hyphens|imageOrientation|imageRendering|imageResolution|imeMode|initialLetter|initialLetterAlign
            |inlineSize|inset|insetBlock|insetBlockEnd|insetBlockStart|insetInline|insetInlineEnd|insetInlineStart|isolation
            |justifyContent|justifyItems|justifySelf|kerning|left|letterSpacing|lightingColor|lineBreak|lineClamp|lineHeight|listStyle
            |listStyleImage|listStylePosition|listStyleType|margin|marginBlock|marginBlockEnd|marginBlockStart|marginBottom|marginInline|marginInlineEnd|marginInlineStart
            |marginLeft|marginRight|marginTop|markerEnd|markerMid|markerStart|marks|mask|maskBorder|maskBorderMode|maskBorderOutset
            |maskBorderRepeat|maskBorderSlice|maskBorderSource|maskBorderWidth|maskClip|maskComposite|maskImage|maskMode
            |maskOrigin|maskPosition|maskRepeat|maskSize|maskType|maxBlockSize|maxHeight|maxInlineSize|maxLines|maxWidth
            |maxZoom|minBlockSize|minHeight|minInlineSize|minWidth|minZoom|mixBlendMode|negative|objectFit|objectPosition
            |offset|offsetAnchor|offsetDistance|offsetPath|offsetPosition|offsetRotation|opacity|order|orientation|orphans
            |outline|outlineColor|outlineOffset|outlineStyle|outlineWidth|overflow|overflowAnchor|overflowBlock|overflowInline
            |overflowWrap|overflow[xy]|overscrollBehavior|overscrollBehaviorBlock|overscrollBehaviorInline|overscrollBehavior[xy]
            |pad|padding|paddingBlock|paddingBlockEnd|paddingBlockStart|paddingBottom|paddingInline|paddingInlineEnd|paddingInlineStart|paddingLeft
            |paddingRight|paddingTop|pageBreakAfter|pageBreakBefore|pageBreakInside|paintOrder|perspective|perspectiveOrigin
            |placeContent|placeItems|placeSelf|pointerEvents|position|prefix|quotes|range|resize|right|rotate|rowGap|rubyAlign
            |rubyMerge|rubyPosition|scale|scrollBehavior|scrollMargin|scrollMarginBlock|scrollMarginBlockEnd|scrollMarginBlockStart
            |scrollMarginBottom|scrollMarginInline|scrollMarginInlineEnd|scrollMarginInlineStart|scrollMarginLeft|scrollMarginRight
            |scrollMarginTop|scrollPadding|scrollPaddingBlock|scrollPaddingBlockEnd|scrollPaddingBlockStart|scrollPaddingBottom
            |scrollPaddingInline|scrollPaddingInlineEnd|scrollPaddingInlineStart|scrollPaddingLeft|scrollPaddingRight
            |scrollPaddingTop|scrollSnapAlign|scrollSnapCoordinate|scrollSnapDestination|scrollSnapStop|scrollSnapType
            |scrollbarColor|scrollbarGutter|scrollbarWidth|shapeImageThreshold|shapeMargin|shapeOutside|shapeRendering|size
            |speakAs|src|stopColor|stopOpacity|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit
            |strokeOpacity|strokeWidth|suffix|symbols|system|tabSize|tableLayout|textAlign|textAlignLast|textAnchor|textCombineUpright
            |textDecoration|textDecorationColor|textDecorationLine|textDecorationSkip|textDecorationSkipInk|textDecorationStyle|textDecorationThickness
            |textEmphasis|textEmphasisColor|textEmphasisPosition|textEmphasisStyle|textIndent|textJustify|textOrientation
            |textOverflow|textRendering|textShadow|textSizeAdjust|textTransform|textUnderlineOffset|textUnderlinePosition|top|touchAction|transform
            |transformBox|transformOrigin|transformStyle|transition|transitionDelay|transitionDuration|transitionProperty|transitionTimingFunction
            |translate|unicodeBidi|unicodeRange|userSelect|userZoom|verticalAlign|visibility|whiteSpace|widows|width|willChange
            |wordBreak|wordSpacing|wordWrap|writingMode|zIndex|zoom
            |alignmentBaseline|baselineShift|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile
            |colorRendering|cx|cy|dominantBaseline|enableBackground|fill|fillOpacity|fillRule|floodColor|floodOpacity
            |glyphOrientationHorizontal|glyphOrientationVertical|height|kerning|lightingColor|markerEnd|markerMid
            |markerStart|r|rx|ry|shapeRendering|stopColor|stopOpacity|stroke|strokeDasharray|strokeDashoffset|strokeLinecap
            |strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|textAnchor|width|x|y
            |adjust|after|align|alignLast|alignment|alignmentAdjust|appearance|attachment|azimuth|backgroundBreak
            |balance|baseline|before|bidi|binding|bookmark|bookmarkLabel|bookmarkLevel|bookmarkTarget|borderLength
            |bottomColor|bottomLeftRadius|bottomRightRadius|bottomStyle|bottomWidth|box|boxAlign|boxDirection
            |boxFlex|boxFlexGroup|boxLines|boxOrdinalGroup|boxOrient|boxPack|break|character|collapse|column
            |columnBreakAfter|columnBreakBefore|count|counter|crop|cue|cueAfter|cueBefore|decoration|decorationBreak
            |delay|displayModel|displayRole|down|drop|dropInitialAfterAdjust|dropInitialAfterAlign|dropInitialBeforeAdjust
            |dropInitialBeforeAlign|dropInitialSize|dropInitialValue|duration|elevation|emphasis|family|fit|fitPosition
            |flexGroup|floatOffset|gap|gridColumns|gridRows|hangingPunctuation|header|hyphenate|hyphenateAfter|hyphenateBefore
            |hyphenateCharacter|hyphenateLines|hyphenateResource|icon|image|increment|indent|index|initialAfterAdjust
            |initialAfterAlign|initialBeforeAdjust|initialBeforeAlign|initialSize|initialValue|inlineBoxAlign|iterationCount
            |justify|label|leftColor|leftStyle|leftWidth|length|level|line|lineStacking|lineStackingRuby|lineStackingShift
            |lineStackingStrategy|lines|list|mark|markAfter|markBefore|marks|marquee|marqueeDirection|marqueePlayCount|marqueeSpeed
            |marqueeStyle|max|min|model|moveTo|name|nav|navDown|navIndex|navLeft|navRight|navUp|new|numeral|offset|ordinalGroup
            |orient|origin|overflowStyle|overhang|pack|page|pagePolicy|pause|pauseAfter|pauseBefore|phonemes|pitch|pitchRange
            |playCount|playDuring|playState|point|presentation|presentationLevel|profile|property|punctuation|punctuationTrim
            |radius|rate|renderingIntent|repeat|replace|reset|resolution|resource|respondTo|rest|restAfter|restBefore|richness
            |rightColor|rightStyle|rightWidth|role|rotation|rotationPoint|rows|ruby|rubyOverhang|rubySpan|rule|ruleColor
            |ruleStyle|ruleWidth|shadow|size|sizeAdjust|sizing|space|spaceCollapse|spacing|span|speak|speakHeader|speakNumeral
            |speakPunctuation|speech|speechRate|speed|stacking|stackingRuby|stackingShift|stackingStrategy|stress|stretch
            |stringSet|style|styleImage|stylePosition|styleType|target|targetName|targetNew|targetPosition|text|textHeight
            |textJustify|textOutline|textReplace|textWrap|timingFunction|topColor|topLeftRadius|topRightRadius|topStyle
            |topWidth|trim|unicode|up|userSelect|variant|voice|voiceBalance|voiceDuration|voiceFamily|voicePitch|voicePitchRange
            |voiceRate|voiceStress|voiceVolume|volume|weight|white|whiteSpaceCollapse|word|wrap
          )\b
        name: support.type.property-name.css.ruko
      - match: (?x)\b(?:ah|apple|atsc|epub|hp|khtml|moz|ms|o|rim|ro|tc|wap|webkit|xv|mso|prince)(?:[\p{Pc}\p{L}&&\P{Ll}][\w&&\P{Lu}]*)+\b
        name: support.type.vendored.property-name.css.ruko

  css-value-names:
    comment: TODO
    patterns:
      - match: |
          (?x)\b(
            aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow
          )\b
        name: support.constant.color.w3c-standard-color-name.css.ruko
      - match: |
          (?x)\b(aliceblue|antiquewhite|aquamarine|azure|beige|bisque|blanchedalmond|blueviolet|brown|burlywood|cadetblue|chartreuse|chocolate|coral|cornflowerblue|cornsilk|crimson|cyan|darkblue|darkcyan|darkgoldenrod|darkgray|darkgreen|darkgrey|darkkhaki|darkmagenta|darkolivegreen|darkorange|darkorchid|darkred|darksalmon|darkseagreen|darkslateblue|darkslategray|darkslategrey|darkturquoise|darkviolet|deeppink|deepskyblue|dimgray|dimgrey|dodgerblue|firebrick|floralwhite|forestgreen|gainsboro|ghostwhite|gold|goldenrod|greenyellow|grey|honeydew|hotpink|indianred|indigo|ivory|khaki|lavender|lavenderblush|lawngreen|lemonchiffon|lightblue|lightcoral|lightcyan|lightgoldenrodyellow|lightgray|lightgreen|lightgrey|lightpink|lightsalmon|lightseagreen|lightskyblue|lightslategray|lightslategrey|lightsteelblue|lightyellow|limegreen|linen|magenta|mediumaquamarine|mediumblue|mediumorchid|mediumpurple|mediumseagreen|mediumslateblue|mediumspringgreen|mediumturquoise|mediumvioletred|midnightblue|mintcream|mistyrose|moccasin|navajowhite|oldlace|olivedrab|orangered|orchid|palegoldenrod|palegreen|paleturquoise|palevioletred|papayawhip|peachpuff|peru|pink|plum|powderblue|rebeccapurple|rosybrown|royalblue|saddlebrown|salmon|sandybrown|seagreen|seashell|sienna|skyblue|slateblue|slategray|slategrey|snow|springgreen|steelblue|tan|thistle|tomato|transparent|turquoise|violet|wheat|whitesmoke|yellowgreen)\b
        name: support.constant.color.w3c-extended-color-name.css.ruko
      - match: (?x)\b(currentColor)\b
        name: support.constant.color.current.css.ruko
      - match: |
          (?x)\b(
            ActiveBorder|ActiveCaption|AppWorkspace|Background|ButtonFace|ButtonHighlight|ButtonShadow|ButtonText|CaptionText|GrayText|Highlight|HighlightText|InactiveBorder|InactiveCaption|InactiveCaptionText|InfoBackground|InfoText|Menu|MenuText|Scrollbar|ThreeDDarkShadow|ThreeDFace|ThreeDHighlight|ThreeDLightShadow|ThreeDShadow|Window|WindowFrame|WindowText
          )\b
        name: support.constant.color.system.css.ruko
      - match: |
          (?x)\b(
            above|absolute|active|add|additive|after-edge|alias|all|all-petite-caps|all-scroll|all-small-caps|alpha|alphabetic|alternate|alternate-reverse
            |always|antialiased|auto|auto-fill|auto-fit|auto-pos|available|avoid|avoid-column|avoid-page|avoid-region|backwards|balance|baseline|before-edge|below|bevel
            |bidi-override|blink|block|block-axis|block-start|block-end|bold|bolder|border|border-box|both|bottom|bottom-outside|break-all|break-word|bullets
            |butt|capitalize|caption|cell|center|central|char|circle|clip|clone|close-quote|closest-corner|closest-side|col-resize|collapse|color|color-burn
            |color-dodge|column|column-reverse|common-ligatures|compact|condensed|contain|content|content-box|contents|context-menu|contextual|copy|cover
            |crisp-edges|crispEdges|crosshair|cyclic|dark|darken|dashed|decimal|default|dense|diagonal-fractions|difference|digits|disabled|disc|discretionary-ligatures
            |distribute|distribute-all-lines|distribute-letter|distribute-space|dot|dotted|double|double-circle|downleft|downright|e-resize|each-line|ease|ease-in
            |ease-in-out|ease-out|economy|ellipse|ellipsis|embed|end|evenodd|ew-resize|exact|exclude|exclusion|expanded|extends|extra-condensed|extra-expanded
            |fallback|farthest-corner|farthest-side|fill|fill-available|fill-box|filled|fit-content|fixed|flat|flex|flex-end|flex-start|flip|flow-root|forwards|freeze
            |from-image|full-width|geometricPrecision|georgian|grab|grabbing|grayscale|grid|groove|hand|hanging|hard-light|help|hidden|hide
            |historical-forms|historical-ligatures|horizontal|horizontal-tb|hue|icon|ideograph-alpha|ideograph-numeric|ideograph-parenthesis|ideograph-space
            |ideographic|inactive|infinite|inherit|initial|inline|inline-axis|inline-block|inline-end|inline-flex|inline-grid|inline-list-item|inline-start
            |inline-table|inset|inside|inter-character|inter-ideograph|inter-word|intersect|invert|isolate|isolate-override|italic|jis04|jis78|jis83
            |jis90|justify|justify-all|kannada|keep-all|landscape|large|larger|left|light|lighten|lighter|line|line-edge|line-through|linear|linearRGB
            |lining-nums|list-item|local|loose|lowercase|lr|lr-tb|ltr|luminance|luminosity|main-size|mandatory|manipulation|manual|margin-box|match-parent
            |match-source|mathematical|max-content|medium|menu|message-box|middle|min-content|miter|mixed|move|multiply|n-resize|narrower|ne-resize
            |nearest-neighbor|nesw-resize|newspaper|no-change|no-clip|no-close-quote|no-common-ligatures|no-contextual|no-discretionary-ligatures
            |no-drop|no-historical-ligatures|no-open-quote|no-repeat|none|nonzero|normal|not-allowed|nowrap|ns-resize|numbers|numeric|nw-resize|nwse-resize
            |oblique|oldstyle-nums|open|open-quote|optimizeLegibility|optimizeQuality|optimizeSpeed|optional|ordinal|outset|outside|over|overlay|overline|padding
            |padding-box|page|painted|pan-down|pan-left|pan-right|pan-up|pan-x|pan-y|paused|petite-caps|pixelated|plaintext|pointer|portrait|pre|pre-line
            |pre-wrap|preserve-3d|progress|progressive|proportional-nums|proportional-width|proximity|radial|recto|region|relative|remove|repeat|repeat-[xy]
            |reset-size|reverse|revert|ridge|right|rl|rl-tb|round|row|row-resize|row-reverse|row-severse|rtl|ruby|ruby-base|ruby-base-container|ruby-text
            |ruby-text-container|run-in|running|s-resize|saturation|scale-down|screen|scroll|scroll-position|se-resize|semi-condensed|semi-expanded|separate
            |sesame|show|sideways|sideways-left|sideways-lr|sideways-right|sideways-rl|simplified|slashed-zero|slice|small|small-caps|small-caption|smaller
            |smooth|soft-light|solid|space|space-around|space-between|space-evenly|spell-out|square|sRGB|stacked-fractions|start|static|status-bar|swap
            |step-end|step-start|sticky|stretch|strict|stroke|stroke-box|style|sub|subgrid|subpixel-antialiased|subtract|super|sw-resize|symbolic|table
            |table-caption|table-cell|table-column|table-column-group|table-footer-group|table-header-group|table-row|table-row-group|tabular-nums|tb|tb-rl
            |text|text-after-edge|text-before-edge|text-bottom|text-top|thick|thin|titling-caps|top|top-outside|touch|traditional|transparent|triangle
            |ultra-condensed|ultra-expanded|under|underline|unicase|unset|upleft|uppercase|upright|use-glyph-orientation|use-script|verso|vertical
            |vertical-ideographic|vertical-lr|vertical-rl|vertical-text|view-box|visible|visibleFill|visiblePainted|visibleStroke|w-resize|wait|wavy
            |weight|whitespace|wider|words|wrap|wrap-reverse|x|x-large|x-small|xx-large|xx-small|y|zero|zoom-in|zoom-out
            |above|absolute|active|add|additive|afterEdge|alias|all|allPetiteCaps|allScroll|allSmallCaps|alpha|alphabetic|alternate|alternateReverse
            |always|antialiased|auto|autoFill|autoFit|autoPos|available|avoid|avoidColumn|avoidPage|avoidRegion|backwards|balance|baseline|beforeEdge|below|bevel
            |bidiOverride|blink|block|blockAxis|blockStart|blockEnd|bold|bolder|border|borderBox|both|bottom|bottomOutside|breakAll|breakWord|bullets
            |butt|capitalize|caption|cell|center|central|char|circle|clip|clone|closeQuote|closestCorner|closestSide|colResize|collapse|color|colorBurn
            |colorDodge|column|columnReverse|commonLigatures|compact|condensed|contain|content|contentBox|contents|contextMenu|contextual|copy|cover
            |crispEdges|crispEdges|crosshair|cyclic|dark|darken|dashed|decimal|default|dense|diagonalFractions|difference|digits|disabled|disc|discretionaryLigatures
            |distribute|distributeAllLines|distributeLetter|distributeSpace|dot|dotted|double|doubleCircle|downleft|downright|eResize|eachLine|ease|easeIn
            |easeInOut|easeOut|economy|ellipse|ellipsis|embed|end|evenodd|ewResize|exact|exclude|exclusion|expanded|extends|extraCondensed|extraExpanded
            |fallback|farthestCorner|farthestSide|fill|fillAvailable|fillBox|filled|fitContent|fixed|flat|flex|flexEnd|flexStart|flip|flowRoot|forwards|freeze
            |fromImage|fullWidth|geometricPrecision|georgian|grab|grabbing|grayscale|grid|groove|hand|hanging|hardLight|help|hidden|hide
            |historicalForms|historicalLigatures|horizontal|horizontalTb|hue|icon|ideographAlpha|ideographNumeric|ideographParenthesis|ideographSpace
            |ideographic|inactive|infinite|inherit|initial|inline|inlineAxis|inlineBlock|inlineEnd|inlineFlex|inlineGrid|inlineListItem|inlineStart
            |inlineTable|inset|inside|interCharacter|interIdeograph|interWord|intersect|invert|isolate|isolateOverride|italic|jis04|jis78|jis83
            |jis90|justify|justifyAll|kannada|keepAll|landscape|large|larger|left|light|lighten|lighter|line|lineEdge|lineThrough|linear|linearRGB
            |liningNums|listItem|local|loose|lowercase|lr|lrTb|ltr|luminance|luminosity|mainSize|mandatory|manipulation|manual|marginBox|matchParent
            |matchSource|mathematical|maxContent|medium|menu|messageBox|middle|minContent|miter|mixed|move|multiply|nResize|narrower|neResize
            |nearestNeighbor|neswResize|newspaper|noChange|noClip|noCloseQuote|noCommonLigatures|noContextual|noDiscretionaryLigatures
            |noDrop|noHistoricalLigatures|noOpenQuote|noRepeat|none|nonzero|normal|notAllowed|nowrap|nsResize|numbers|numeric|nwResize|nwseResize
            |oblique|oldstyleNums|open|openQuote|optimizeLegibility|optimizeQuality|optimizeSpeed|optional|ordinal|outset|outside|over|overlay|overline|padding
            |paddingBox|page|painted|panDown|panLeft|panRight|panUp|panX|panY|paused|petiteCaps|pixelated|plaintext|pointer|portrait|pre|preLine
            |preWrap|preserve3d|progress|progressive|proportionalNums|proportionalWidth|proximity|radial|recto|region|relative|remove|repeat|repeat[xy]
            |resetSize|reverse|revert|ridge|right|rl|rlTb|round|row|rowResize|rowReverse|rowSeverse|rtl|ruby|rubyBase|rubyBaseContainer|rubyText
            |rubyTextContainer|runIn|running|sResize|saturation|scaleDown|screen|scroll|scrollPosition|seResize|semiCondensed|semiExpanded|separate
            |sesame|show|sideways|sidewaysLeft|sidewaysLr|sidewaysRight|sidewaysRl|simplified|slashedZero|slice|small|smallCaps|smallCaption|smaller
            |smooth|softLight|solid|space|spaceAround|spaceBetween|spaceEvenly|spellOut|square|sRGB|stackedFractions|start|static|statusBar|swap
            |stepEnd|stepStart|sticky|stretch|strict|stroke|strokeBox|style|sub|subgrid|subpixelAntialiased|subtract|super|swResize|symbolic|table
            |tableCaption|tableCell|tableColumn|tableColumnGroup|tableFooterGroup|tableHeaderGroup|tableRow|tableRowGroup|tabularNums|tb|tbRl
            |text|textAfterEdge|textBeforeEdge|textBottom|textTop|thick|thin|titlingCaps|top|topOutside|touch|traditional|transparent|triangle
            |ultraCondensed|ultraExpanded|under|underline|unicase|unset|upleft|uppercase|upright|useGlyphOrientation|useScript|verso|vertical
            |verticalIdeographic|verticalLr|verticalRl|verticalText|viewBox|visible|visibleFill|visiblePainted|visibleStroke|wResize|wait|wavy
            |weight|whitespace|wider|words|wrap|wrapReverse|x|xLarge|xSmall|xxLarge|xxSmall|y|zero|zoomIn|zoomOut
          )\b
        name: support.constant.property-value.css.ruko
      - match: |
          (?x)\b(
             arabicIndic|armenian|bengali|cambodian|circle|cjkDecimal|cjkEarthlyBranch|cjkHeavenlyStem|cjkIdeographic
            |decimal|decimalLeadingZero|devanagari|disc|disclosureClosed|disclosureOpen|ethiopicHalehameAm
            |ethiopicHalehameTiE[rt]|ethiopicNumeric|georgian|gujarati|gurmukhi|hangul|hangulConsonant|hebrew
            |hiragana|hiraganaIroha|japaneseFormal|japaneseInformal|kannada|katakana|katakanaIroha|khmer
            |koreanHangulFormal|koreanHanjaFormal|koreanHanjaInformal|lao|lowerAlpha|lowerArmenian|lowerGreek
            |lowerLatin|lowerRoman|malayalam|mongolian|myanmar|oriya|persian|simpChineseFormal|simpChineseInformal
            |square|tamil|telugu|thai|tibetan|tradChineseFormal|tradChineseInformal|upperAlpha|upperArmenian
            |upperLatin|upperRoman|urdu
            arabic-indic|armenian|bengali|cambodian|circle|cjk-decimal|cjk-earthly-branch|cjk-heavenly-stem|cjk-ideographic
            |decimal|decimal-leading-zero|devanagari|disc|disclosure-closed|disclosure-open|ethiopic-halehame-am
            |ethiopic-halehame-ti-e[rt]|ethiopic-numeric|georgian|gujarati|gurmukhi|hangul|hangul-consonant|hebrew
            |hiragana|hiragana-iroha|japanese-formal|japanese-informal|kannada|katakana|katakana-iroha|khmer
            |korean-hangul-formal|korean-hanja-formal|korean-hanja-informal|lao|lower-alpha|lower-armenian|lower-greek
            |lower-latin|lower-roman|malayalam|mongolian|myanmar|oriya|persian|simp-chinese-formal|simp-chinese-informal
            |square|tamil|telugu|thai|tibetan|trad-chinese-formal|trad-chinese-informal|upper-alpha|upper-armenian
            |upper-latin|upper-roman|urdu
          )\b
        name: support.constant.property-value.list-style-type.css.ruko
      - match: |
          (?x)\b(arial|century|comic|courier|garamond|georgia|helvetica|impact|lucida|symbol|system-ui|system|tahoma|times|trebuchet|ui-monospace|ui-rounded|ui-sans-serif|ui-serif|utopia|verdana|webdings|sans-serif|serif|monospace|arial|century|comic|courier|garamond|georgia|helvetica|impact|lucida|symbol|systemUi|system|tahoma|times|trebuchet|uiMonospace|uiRounded|uiSansSerif|uiSerif|utopia|verdana|webdings|sansSerif|serif|monospace)\b
        name: support.constant.font-name.css.ruko

  html-tag-names:
    patterns:
      - match: (?x)\b(all|print|screen|speech|aural|braille|embossed|handheld|projection|tty|tv)\b
        name: support.constant.media.css.ruko
      - match: |
          (?x)\b(
            a|abbr|acronym|address|altGlyph|altGlyphDef|altGlyphItem|animate|animateColor|animateMotion|animateTransform|annotation|annotationXml|applet|area|article|aside|audio|b|base|basefont|bdi|bdo|bgsound|big|blink|blockquote|body|br|button|canvas|caption|center|circle|cite|clipPath|code|col|colgroup|colorProfile|command|content|cursor|data|datalist|dd|defs|del|desc|details|dfn|dialog|dir|discard|div|dl|dt|elem|ellipse|em|embed|feBlend|feColorMatrix|feComponentTransfer|feComposite|feConvolveMatrix|feDiffuseLighting|feDisplacementMap|feDistantLight|feDropShadow|feFlood|feFuncA|feFuncB|feFuncG|feFuncR|feGaussianBlur|feImage|feMerge|feMergeNode|feMorphology|feOffset|fePointLight|feSpecularLighting|feSpotLight|feTile|feTurbulence|fieldset|figcaption|figure|filter|font|fontFace|fontFaceFormat|fontFaceName|fontFaceSrc|fontFaceUri|footer|foreignObject|form|frame|frameset|g|glyph|glyphRef|hatch|hatchpath|hd|head|header|hgroup|hkern|hr|html|h[1-6]|i|iframe|image|img|input|ins|isindex|kbd|keygen|label|legend|li|line|linearGradient|link|listing|maction|main|maligngroup|malignmark|map|mark|marker|marquee|mask|math|menclose|menu|menuitem|merror|mesh|meshgradient|meshpatch|meshrow|meta|metadata|meter|mfenced|mfrac|mglyph|mi|missingGlyph|mlabeledtr|mlongdiv|mmultiscripts|mn|mo|mover|mpadded|mpath|mphantom|mroot|mrow|ms|mscarries|mscarry|msgroup|msline|mspace|msqrt|msrow|mstack|mstyle|msub|msubsup|msup|mtable|mtd|mtext|mtr|multicol|munder|munderover|nav|nextid|nobr|noembed|noframes|noscript|object|ol|optgroup|option|output|p|param|path|pattern|picture|plaintext|polygon|polyline|pre|progress|q|radialGradient|rb|rect|rp|rt|rtc|ruby|s|samp|script|section|select|semantics|set|shadow|slot|small|solidcolor|source|spacer|span|stop|strike|strong|style|sub|summary|sup|svg|switch|symbol|table|tbody|td|template|text|textarea|textPath|tfoot|th|thead|time|title|tr|track|tref|tspan|tt|u|ul|use|var|video|view|vkern|wbr|xmp
          )\b
        name: entity.name.tag.css.ruko

  entities:
    patterns:
      - include: '#constants'
      - include: '#function-names'
      - include: '#type-names'
      - include: '#variables'

  type-names:
    comment: Names for built-in types
    patterns:
      - comment: Primitive classes
        match: |
          (?x)\s*(?<![?!]?\.|[?!:]:)\b(
            # upper flat case
            Bool|Char|Rune|Str|Sym|Text|Buf
            |(Big)?(Num|Nat|U?Int|Float|Frac|Real|Imag|Complex)
            # lower flat case
            |bool|char|rune|str|sym|text|buf
            |(big)?(num|nat|u?int|float|frac|real|imag|complex)
            # suffixed numeric types
            # i: signed integer
            # u: unsigned integer
            # f: floating point
            # j: imaginary float
            # c: complex float (real+imaginary)
            |(?i:[iufjc]\d+)
          )\b
        name: support.type.builtin.primitive.ruko
      - comment: Data query classes
        match: |
          (?x)\s*(?<![?!]?\.|[?!:]:)\b(
            Array|Tuple|Set|Map|Object|Seq|Record|Dict
            |Proc|Range|Stack|Heap|Queue|Tree|Trie|Graph
            |Future|Stream|RegExp|Func|Buffer|FSe[tq]
            # lower flat case
            |array|tuple|set|map|object|seq|record|dict
            |proc|range|stack|heap|queue|tree|trie|graph
            |future|stream|regexp|func|buffer|fse[tq]
          )\b
        name: support.type.builtin.ruko
      - comment: Constant/algebraic classes
        match: |
          (?x)\s*(?<![?!]?\.|[?!:]:)\b(
            True|False|Null|Void|NaN|Inf|Empty|Unit|Object
            |Any|Mixed|Just|Some|None|Never|(Im)?pure|Const|Undef
            # lower flat case
            |true|false|null|void|nan|inf|empty|unit|obj
            |any|mixed|just|some|none|never|(im)?pure|const|undef
          )\b
        name: support.type.primitive.ruko
      - comment: Error classes | BaseError, etc
        match: \s*\b((\p{Lu}[\w&&\P{Lu}]*)+)?(Error|Exception)\b
        name: support.class.error.ruko
      - comment: Interface classes | IEnumerable, etc
        match: \s*\bI((\p{Lu}[\w&&\P{Lu}]*)+)\b
        name: entity.name.interface.ruko
      - comment: Namespace classes | NSString, etc
        match: \s*\bNS((\p{Lu}[\w&&\P{Lu}]*)+)\b
        name: entity.name.namespace.ruko
      - comment: Trait classes | Serializable, Loggable etc
        match: \s*\b((\p{Lu}[\w&&\P{Lu}]*)+)able\b
        name: support.class.trait.ruko
      - comment: Algebraic data types
        match: \s*\b(Some|None|Just|Ok|Err|Left|Right)\b\s*
        name: support.class.algebraic.ruko
      - include: '#support-classes'

  support-classes:
    comment: Ruko probably won't have a large set of built-in classes,
      so we include common built-in types from major languages
      to improve recognition of cross-language codebases
    patterns:
      - include: source.python#builtin-exceptions
      - include: source.php#class-builtin
      - include: source.swift#builtin-types-builtin-protocol-type
      - include: source.swift#builtin-types-builtin-struct-type
      - include: source.swift#builtin-types-builtin-enum-type
      - include: source.swift#builtin-types-builtin-class-type
      - include: source.swift#builtin-types

      # ShaderLab
      - name: support.type.basic.shaderlab
        match: \b(Range|Float|Int|Color|Vector|2D|3D|Cube|Any)\b
      - include: '#numbers'
      - name: storage.type.structure.shaderlab
        match: \b(Shader|Properties|SubShader|Pass|Category)\b
      - name: support.type.propertyname.shaderlab
        match: \b(Name|Tags|Fallback|CustomEditor|Cull|ZWrite|ZTest|Offset|Blend|BlendOp|ColorMask|AlphaToMask|LOD|Lighting|Stencil|Ref|ReadMask|WriteMask|Comp|CompBack|CompFront|Fail|ZFail|UsePass|GrabPass|Dependency|Material|Diffuse|Ambient|Shininess|Specular|Emission|Fog|Mode|Density|SeparateSpecular|SetTexture|Combine|ConstantColor|Matrix|AlphaTest|ColorMaterial|BindChannels|Bind)\b
      - name: support.type.property-value.shaderlab
        match: \b(Back|Front|On|Off|[RGBA]{1,3}|AmbientAndDiffuse|Emission)\b
      - name: support.type.property-value.comparisonfunction.shaderlab
        match: \b(Less|Greater|LEqual|GEqual|Equal|NotEqual|Always|Never)\b
      - name: support.type.property-value.stenciloperation.shaderlab
        match: \b(Keep|Zero|Replace|IncrSat|DecrSat|Invert|IncrWrap|DecrWrap)\b
      - name: support.type.property-value.texturecombiners.shaderlab
        match: \b(Previous|Primary|Texture|Constant|Lerp|Double|Quad|Alpha)\b
      - name: support.type.property-value.fog.shaderlab
        match: \b(Global|Linear|Exp2|Exp)\b
      - name: support.type.property-value.bindchannels.shaderlab
        match: \b(Vertex|Normal|Tangent|TexCoord0|TexCoord1)\b
      - name: support.type.property-value.blendoperations.shaderlab
        match: \b(Add|Sub|RevSub|Min|Max|LogicalClear|LogicalSet|LogicalCopyInverted|LogicalCopy|LogicalNoop|LogicalInvert|LogicalAnd|LogicalNand|LogicalOr|LogicalNor|LogicalXor|LogicalEquiv|LogicalAndReverse|LogicalAndInverted|LogicalOrReverse|LogicalOrInverted)\b
      - name: support.type.property-value.blendfactors.shaderlab
        match: \b(One|Zero|SrcColor|SrcAlpha|DstColor|DstAlpha|OneMinusSrcColor|OneMinusSrcAlpha|OneMinusDstColor|OneMinusDstAlpha)\b

      # HLSL
      - name: support.type.basic.hlsl
        match: \b(bool([1-4](x[1-4])?)?|double([1-4](x[1-4])?)?|dword|float([1-4](x[1-4])?)?|half([1-4](x[1-4])?)?|int([1-4](x[1-4])?)?|matrix|min10float([1-4](x[1-4])?)?|min12int([1-4](x[1-4])?)?|min16float([1-4](x[1-4])?)?|min16int([1-4](x[1-4])?)?|min16uint([1-4](x[1-4])?)?|unsigned|uint([1-4](x[1-4])?)?|vector|void)\b
      - name: support.modifier.hlsl
        match: \b(column_major|const|export|extern|globallycoherent|groupshared|inline|inout|in|out|precise|row_major|shared|static|uniform|volatile)\b
      - name: support.modifier.float.hlsl
        match: \b(snorm|unorm)\b
      - name: support.modifier.postfix.hlsl
        match: \b(packoffset|register)\b
      - name: support.modifier.interpolation.hlsl
        match: \b(centroid|linear|nointerpolation|noperspective|sample)\b
      - name: support.modifier.geometryshader.hlsl
        match: \b(lineadj|line|point|triangle|triangleadj)\b
      - name: support.type.other.hlsl
        match: \b(string)\b
      - name: support.type.object.hlsl
        match: \b(AppendStructuredBuffer|Buffer|ByteAddressBuffer|ConstantBuffer|ConsumeStructuredBuffer|InputPatch|OutputPatch)\b
      - name: support.type.object.rasterizerordered.hlsl
        match: \b(RasterizerOrderedBuffer|RasterizerOrderedByteAddressBuffer|RasterizerOrderedStructuredBuffer|RasterizerOrderedTexture1D|RasterizerOrderedTexture1DArray|RasterizerOrderedTexture2D|RasterizerOrderedTexture2DArray|RasterizerOrderedTexture3D)\b
      - name: support.type.object.rw.hlsl
        match: \b(RWBuffer|RWByteAddressBuffer|RWStructuredBuffer|RWTexture1D|RWTexture1DArray|RWTexture2D|RWTexture2DArray|RWTexture3D)\b
      - name: support.type.object.geometryshader.hlsl
        match: \b(LineStream|PointStream|TriangleStream)\b
      - name: support.type.sampler.legacy.hlsl
        match: \b(sampler|sampler1D|sampler2D|sampler3D|samplerCUBE|sampler_state)\b
      - name: support.type.sampler.hlsl
        match: \b(SamplerState|SamplerComparisonState)\b
      - name: support.type.texture.legacy.hlsl
        match: \b(texture2D|textureCUBE)\b
      - name: support.type.texture.hlsl
        match: \b(Texture1D|Texture1DArray|Texture2D|Texture2DArray|Texture2DMS|Texture2DMSArray|Texture3D|TextureCube|TextureCubeArray)\b
      - name: support.type.structured.hlsl
        match: \b(cbuffer|class|interface|namespace|struct|tbuffer)\b
      - name: support.type.fx.hlsl
        match: \b(BlendState|DepthStencilState|RasterizerState)\b
      - name: support.type.fx.technique.hlsl
        match: \b(pass|technique|technique10|technique11)\b
      - name: support.type.semantic.sm4.hlsl
        match: \b(?i:SV_ClipDistance[0-9]*|SV_CullDistance[0-9]*|SV_Coverage|SV_Depth|SV_DepthGreaterEqual[0-9]*|SV_DepthLessEqual[0-9]*|SV_InstanceID|SV_IsFrontFace|SV_Position|SV_RenderTargetArrayIndex|SV_SampleIndex|SV_StencilRef|SV_Target[0-7]?|SV_VertexID|SV_ViewportArrayIndex)\b
      - name: support.type.semantic.sm5.hlsl
        match: \b(?i:SV_DispatchThreadID|SV_DomainLocation|SV_GroupID|SV_GroupIndex|SV_GroupThreadID|SV_GSInstanceID|SV_InsideTessFactor|SV_OutputControlPointID|SV_TessFactor)\b

      # Objective-C++
      - include: source.objcpp#anonymous_pattern_17
      - include: source.objcpp#anonymous_pattern_18
      - include: source.objcpp#anonymous_pattern_19
      - include: source.objcpp#anonymous_pattern_20
      - include: source.objcpp#anonymous_pattern_21
      - include: source.objcpp#anonymous_pattern_22
      - include: source.objcpp#anonymous_pattern_23
      - include: source.objcpp#anonymous_pattern_24
      - include: source.objcpp#anonymous_pattern_25

  support-functions:
    comment: |
      Names for general support functions in Ruko standard library
      organized by naming conventions for maintainability
    patterns:
      - comment: predicate functions
        match: \s*\b(i|ha)s(\p{Lu}[\w&&\P{Lu}]*)+\b\s*
        name: support.function.predicate.ruko
      - comment: conversion functions
        match: \s*\b(to|from)(\p{Lu}[\w&&\P{Lu}]*)+\b\s*
        name: support.function.type.ruko
      - comment: magic functions like __init__, __str__, etc
        match: \s*\b\p{Pc}+([\p{Pc}\p{L}]\w*)+\p{Pc}+\b\s*
        name: support.function.magic.ruko
      - match: \s*\b[gs]et(\p{Lu}[\w&&\P{Lu}]*)+\b\s*
        name: support.function.accessor.ruko
      - include: '#support-functions-core'

  support-functions-core:
    comment: Core built-in functions from major languages,
      to improve recognition of cross-language codebases
    patterns:
      - include: source.coffeescript#method_names
      - include: source.coffeescript#function_names
      - include: source.swift#builtin-functions
      - include: source.swift#builtin-global-functions
      - include: source.php#support
      - include: source.r#builtin-functions
      - include: source.objcpp#c_functions

      # Lua
      - match: (?<![^.]\.|:)\b(assert|collectgarbage|dofile|error|getfenv|getmetatable|ipairs|load|loadfile|loadstring|module|next|pairs|pcall|print|rawequal|rawget|rawlen|rawset|require|select|setfenv|setmetatable|tonumber|tostring|type|unpack|xpcall)\b(?!\s*=(?!=))
        name: support.function.lua
      - match: (?<![^.]\.|:)\b(coroutine\.(create|isyieldable|close|resume|running|status|wrap|yield)|string\.(byte|char|dump|find|format|gmatch|gsub|len|lower|match|pack|packsize|rep|reverse|sub|unpack|upper)|table\.(concat|insert|maxn|move|pack|remove|sort|unpack)|math\.(abs|acos|asin|atan2?|ceil|cosh?|deg|exp|floor|fmod|frexp|ldexp|log|log10|max|min|modf|pow|rad|random|randomseed|sinh?|sqrt|tanh?|tointeger|type)|io\.(close|flush|input|lines|open|output|popen|read|tmpfile|type|write)|os\.(clock|date|difftime|execute|exit|getenv|remove|rename|setlocale|time|tmpname)|package\.(loadlib|seeall|searchpath)|debug\.(debug|[gs]etfenv|[gs]ethook|getinfo|[gs]etlocal|[gs]etmetatable|getregistry|[gs]etupvalue|[gs]etuservalue|set[Cc]stacklimit|traceback|upvalueid|upvaluejoin)|bit32\.(arshift|band|bnot|bor|btest|bxor|extract|replace|lrotate|lshift|rrotate|rshift)|utf8\.(char|codes|codepoint|len|offset))\b(?!\s*=(?!=))
        name: support.function.library.lua

      # Ruby
      - match: \b(abort|at_exit|autoload[?]?|binding|callcc|caller|caller_locations|chomp|chop|eval|exec|exit|exit!|fork|format|gets|global_variables|gsub|lambda|load|local_variables|open|p|print|printf|proc|putc|puts|rand|readline|readlines|select|set_trace_func|sleep|spawn|sprintf|srand|sub|syscall|system|test|trace_var|trap|untrace_var|warn)(\b|(?<=[?!]))(?![?!])
        name: support.function.kernel.ruby

      # SQL
      - match: \b(avg|checksum_agg|count|count_big|grouping|grouping_id|max|min|sum|stdev|stdevp|var|varp)\b
        name: support.function.aggregate.sql
      - match: \b(cume_dist|first_value|lag|last_value|lead|percent_rank|percentile_cont|percentile_disc)\b
        name: support.function.analytic.sql
      - match: \b(cast|convert|parse|try_cast|try_convert|try_parse)\b
        name: support.function.conversion.sql
      - match: \b(cursor_status)\b
        name: support.function.cursor.sql
      - match: \b(sysdatetime|sysdatetimeoffset|sysutcdatetime|current_time(stamp)?|getdate|getutcdate|datename|datepart|day|month|year|datefromparts|datetime2fromparts|datetimefromparts|datetimeoffsetfromparts|smalldatetimefromparts|timefromparts|datediff|dateadd|eomonth|switchoffset|todatetimeoffset|isdate)\b
        name: support.function.datetime.sql
      - match: \b(coalesce|nullif)\b
        name: support.function.expression.sql
      - match: (?<!@)@@(?i)\b(cursor_rows|connections|cpu_busy|datefirst|dbts|error|fetch_status|identity|idle|io_busy|langid|language|lock_timeout|max_connections|max_precision|nestlevel|options|packet_errors|pack_received|pack_sent|procid|remserver|rowcount|servername|servicename|spid|textsize|timeticks|total_errors|total_read|total_write|trancount|version)\b
        name: support.function.globalvar.sql
      - match: \b(choose|iif)\b
        name: support.function.logical.sql
      - match: \b(abs|acos|asin|atan|atn2|ceiling|cos|cot|degrees|exp|floor|log|log10|pi|power|radians|rand|round|sign|sin|sqrt|square|tan)\b
        name: support.function.mathematical.sql
      - match: \b(app_name|applock_mode|applock_test|assemblyproperty|col_length|col_name|columnproperty|database_principal_id|databasepropertyex|db_id|db_name|file_id|file_idex|file_name|filegroup_id|filegroup_name|filegroupproperty|fileproperty|fulltextcatalogproperty|fulltextserviceproperty|index_col|indexkey_property|indexproperty|object_definition|object_id|object_name|object_schema_name|objectproperty|objectpropertyex|original_db_name|parsename|schema_id|schema_name|scope_identity|serverproperty|stats_date|type_id|type_name|typeproperty)\b
        name: support.function.metadata.sql
      - match: \b(rank|dense_rank|ntile|row_number)\b
        name: support.function.ranking.sql
      - match: \b(opendatasource|openrowset|openquery|openxml)\b
        name: support.function.rowset.sql
      - match: \b(certencoded|certprivatekey|current_user|database_principal_id|has_perms_by_name|is_member|is_rolemember|is_srvrolemember|original_login|permissions|pwdcompare|pwdencrypt|schema_id|schema_name|session_user|suser_id|suser_sid|suser_sname|system_user|suser_name|user_id|user_name)\b
        name: support.function.security.sql
      - match: \b(ascii|char|charindex|concat|difference|format|left|len|lower|ltrim|nchar|nodes|patindex|quotename|replace|replicate|reverse|right|rtrim|soundex|space|str|string_agg|string_escape|string_split|stuff|substring|translate|trim|unicode|upper)\b
        name: support.function.string.sql
      - match: \b(binary_checksum|checksum|compress|connectionproperty|context_info|current_request_id|current_transaction_id|decompress|error_line|error_message|error_number|error_procedure|error_severity|error_state|formatmessage|get_filestream_transaction_context|getansinull|host_id|host_name|isnull|isnumeric|min_active_rowversion|newid|newsequentialid|rowcount_big|session_context|session_id|xact_state)\b
        name: support.function.system.sql
      - match: \b(patindex|textptr|textvalid)\b
        name: support.function.textimage.sql

      # Python
      - name: support.function.legacy.builtin.python
        match: (?x)(?<!\.)\b(file|reduce|intern|raw_input|unicode|cmp|basestring|execfile|long|xrange)\b
      - include: source.python#builtin-functions
      - include: source.python#builtin-types
      - include: source.python#magic-function-names
