// Ruko is a markup, scripting, styling and shader
// language I'm making that compiles to HTML/CSS/JS,
// WebAssembly, and WebGPU shaders (GLSL, WGSL, etc.).

// This is an implementation of the Mersenne Twister
// pseudorandom number generator (MT19937) , loosely
// translated from the original C code by Makoto Matsumoto
// and Takuji Nishimura.

// Translated from https://gist.github.com/yuikns/10017640

use Sys::{Crypto, Time, Io, Fs}, Math;

show class MTRand : Io.Serializer {
  pub:
    const prop i32 N = 624,
    const prop i32 SAVE = N + 1;

  prot:
    const prop i32 M = 397;

    prop [N]u32 state,
      &u32 p_next,
      i32 left,
      bool has_gauss = false,
      f64 next_gauss = 0.0;

    static prop u32 differ = 0;

    // constructor overloads
    // # = "self"
    proc MTRand(u32 one_seed) = #seed(one_seed);
    proc MTRand(&u32 big_seed, u32 seed_length = N) =
      #seed(big_seed, seed_length);
    proc MTRand() = #seed();
    proc MTRand(&MTRand o) {
      for let i32 i in 0 ..< N:
        #state->[i] := o->state->[i];
      #left := o->left;
      #p_next := if #left == 0: &#state->0 else &#state->[N - #left];
    }

    proc ~MTRand(); // no dynamic memory to free

    // generate N words at one time
    proc u32 rand_int() {
      if #left == 0: #reload();
      #left -= 1;

      mut u32 s1 = *#p_next;
      #p_next += 1;

      s1 ^= (s1 >> 11);
      s1 ^= (s1 << 7) & 0x9d2c5680;
      s1 ^= (s1 << 15) & 0xefc60000;

      return s1 ^ (s1 >> 18);
    }

    // find the biggest used bit
    proc u32 rand_int(u32 n) {
      mut used = n;
      for let i32 i in 0 ... 5:
        used |= used >> (1 << i);

      mut u32 i;
      loop i := #rand_int() & used while i >= n;

      return i;
    }

    // seed overloads
    proc seed(u32 one_seed) {
      #initialize(one_seed);
      #reload();
    }

    // seed with an array
    proc seed(&u32 big_seed, u32 seed_length = N) {
      #initialize(19650218);

      mut i32 i = 1;
      mut u32 j = 0;
      mut i32 k = if N > seed_length: N else seed_length;

      for in 0 ..< k {
        #state->[i] := #state->[i] ^
          ((#state->[i - 1] ^ (#state->[i - 1] >> 30)) * 0x19660d);
        #state->[i] += (big_seed[j] & 0xffffffff) + j;
        #state->[i] &= 0xffffffff;

        i += 1; j += 1;
        if i >= N {#state->0 := #state->[N - 1]; i := 1};
        if j >= seed_length: j := 0;
      }

      for in 0 ..< N - 1 {
        #state->[i] := #state->[i] ^ ((#state->[i - 1] ^ (#state->[i - 1] >> 30)) * 0x5d588b65);
        #state->[i] -= i;
        #state->[i] &= 0xffffffff;

        i += 1;
        if i >= N {#state->0 := #state->[N - 1]; i := 1;}
      }

      #state->0 := 0x80000000;
      #reload();
    }

    // seed with system entropy or time-based seed
    proc seed() {
      let ur = Crypto::open_urandom();

      if ?ur {
        mut [N]u32 big;
        mut bool ok = true;
         for let i32 i in 0 ..< N {
          let bytes = ur->read_bytes(4);
          if bytes::len != 4 {ok := false; break;}
          big[i] := bytes.to_u32(0);
        }

        ur->close();
        if ok {#seed(&big.0, N); return;}
      }

      let Time.time t = Time::now().to_unix();
      let Time.clock c = Time::clock::to_nanoseconds();
      #seed(#hash(t, c));
    }

    proc initialize(u32 one_seed) {
      #state->0 := one_seed & 0xffffffff;

      for let i32 i in 1 ..< N {
        let u32 x = #state->[i - 1] ^ (#state->[i - 1] >> 30);
        #state->[i] := (0x6c078965 * x + i) & 0xffffffff;
      }
    }

    proc reload() {
      mut p = &#state->0;

      for in 0 ..< (N - M) {
        p->0 := #twist(p[M], p->0, p->1);
        p += 1;
      }

      for in 0 ..< (M - 1) {
        p->0 := #twist(p[M - N], p->0, p->1);
        p += 1;
      }

      p->0 := #twist(p[M - N], p->0, #state->0);
      #left := N;
      #p_next := &#state->0;
    }

    proc save(&u32 save_array) {
      mut sa = save_array;
      for let i32 i in 0 ..< N: sa[i] := #state->[i];
      sa[N] := #left;
    }

    proc load(&u32 load_array) {
      mut la = load_array;
      for let i32 i in 0 ..< N: #state->[i] := la[i];
      #left := la[N];
      #p_next := if #left == 0: &#state->0 else &#state->[N - #left];
    }

    // hash function for time-based seed
    proc u32 hash(Time.time t, Time.clock c) {
      mut u32 h1 = 0;
      let &u8 tb = (&u8) t;
      for let i32 i in 0 ..< sizeof(Time.time) {
        h1 *= u8::max_value + 2;
        h1 += (u32) tb[i];
      }

      mut u32 h2 = 0;
      let &u8 cb = (&u8) c;
      for let i32 i in 0 ..< sizeof(Time.clock) {
        h2 *= u8::max_value + 2;
        h2 += (u32) cb[i];
      }

      let u32 output = (h1 + #differ) ^ h2;
      #differ += 1;
      return output;
    }

    proc u32 twist(u32 m, u32 s0, u32 s1) =  m ^ (#mix_bits(s0, s1) >> 1) ^ #magic(s1);
    proc u32 mix_bits(u32 u, u32 v) = #hi_bit(u) | #lo_bits(v);
    proc u32 magic(u32 u) = if #lo_bit(u) != 0: 0x9908b0df else 0x0;

    proc u32 hi_bit(u32 u) = u & 0x80000000;
    proc u32 lo_bit(u32 u) = u & 0x00000001;
    proc u32 lo_bits(u32 u) = u & 0x7fffffff;

    // additional generation functions
    proc f64 rand() = ((f64) #rand_int()) * (1.0 / 0xffffffff.0);
    proc f64 rand(f64 n) = #rand() * n;
    proc f64 rand_exc() = ((f64) #rand_int()) * (1.0 / 0x100000000.0);
    proc f64 rand_exc(f64 n) = #rand_exc() * n;
    proc f64 rand_dbl_exc() = (((f64) #rand_int()) + 0x0.8) * (1.0 / 0x100000000.0);
    proc f64 rand_dbl_exc(f64 n) = #rand_dbl_exc() * n;

    proc f64 rand_53() {
      let u32 a = #rand_int() >> 5; // 27 bits
      let u32 b = #rand_int() >> 6; // 26 bits
      return ((f64) a * 0x4000000.0 + (f64) b) * (1.0 / 0x20000000000000.0);
    }

    proc u32 genrand_int_31() = #rand_int() >> 1;
    proc f64 genrand_real_1() = #rand_dbl_exc();
    proc f64 genrand_real_2() = #rand();
    proc f64 genrand_real_3() = #rand_exc();
    proc f64 genrand_res_53() = #rand_53();

    // normally distributed number
    proc f64 rand_norm(f64 mean = 0.0, f64 std_dev = 1.0) {
      if #has_gauss {
        #has_gauss := false;
        return #next_gauss * std_dev + mean;
      }

      mut f64 x, f64 y, f64 r, f64 z, f64 a;
      loop {
        x := 2.0 * #rand() - 1.0;
        y := 2.0 * #rand() - 1.0;
        r := x ** 2 + y ** 2;
      } while r >= 1.0 || r == 0.0;

      let f64 s = Math::sqrt(-2.0 * Math::log(r) / r);
      #next_gauss := y * s + mean;
      #has_gauss := true;
      return x * s * std_dev + mean;
    }

    override proc str serialize() {
      mut str s = '';
      for let i32 i in 0 ..< N: s += (str) #state->[i] + '\t';
      s += (str) #left;
      return s;
    }

    override static proc deserialize(str s) {
      let []str parts = s / '\t'; // split by tab
      for let i32 i in 0 ..< N: #state->[i] := (u32) parts[i];
      #left := (i32) parts[N];
      #p_next := if #left == 0: &#state->0 else &#state->[N - #left];
    }

    static proc u32 hash(str s) {
      mut u32 h = 0;
      let []u8 bytes = s.to_bytes();
      for let i32 i in 0 ..< bytes::len {
        h *= u8::max_value + 2;
        h += (u32) bytes[i];
      }
      mut u32 h2 = 0;
      for let i32 i in 0 ..< bytes::len {
        h2 *= u8::max_value + 2;
        h2 += (u32) bytes[bytes::len - i - 1];
      }
      return h ^ h2;
    }

    // operator definitions
    suffix oper f64 self() = #rand();

    right oper 4 &Io.OutputStream o_stream <- &MTRand mt_rand: &Io.OutputStream {
      for let i32 i in 0 ..< N:
        o_stream->write_str((str) mt_rand->state->[i] + '\t');
      o_stream->write_str((str) mt_rand->left);
      return o_stream;
    }

    left oper 4 &Io.InputStream i_stream -> &MTRand mt_rand: &Io.InputStream {
      for let i32 i in 0 ..< N {
        let str line = i_stream->read_line();
        mt_rand->state->[i] := (u32) line;
      }

      let str line = i_stream->read_line();
      mt_rand->left := (i32) line;
      mt_rand->p_next := &mt_rand->state->[N - mt_rand->left];
      return i_stream;
    }

    right oper 4 = (&MTRand o): &MTRand {
      if *self == o: return *self;
      for let i32 i in 0 ..< N: #state->[i] := o->state->[i];
      #left := o->left;
      #p_next := &#state->[N - #left];
      return *self;
    }
}

mut MTRand rand = new MTRand;
rand.seed();

rand -> Fs::open('mtstate.txt', fm_write).get.close();
rand <- Fs::open('mtstate.txt', fm_read).get.close();

for let i32 i in 0 ..< 10:
  Io::stdout->write_str('Random number ' +
    (str) (i + 1) + ': ' +
    (str) rand.rand_int() + '\n');

Io::stdout->write_str('Random float: ' + (str) rand.rand() + '\n');
Io::stdout->write_str('Random normal: ' + (str) rand.rand_norm() + '\n');