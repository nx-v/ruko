// test file for the Ruko Language
proc main {
  use Figlet.*,
    Dom.{Canvas, Audio, FS, Log},
    Artists.`Nexo Volta`,
    Galaxies.MilkyWay:Galaxy,
    Components.Post;

  let stars = Galaxy.getVisibleStars();
  if const prophecy = 3 ** (3 * 2) &&
  stars has "Alained" &&
  "Nexo" in stars \map\ _-1.name {
    [Dom.Canvas clear:
                setBackground: 'black'
                draw: prophecy.toSVG()];
    [Audio.Track play: './VirtualRiot-Reconnect.mp3'
                 volume: 0.8
                 `loop`: true];
    Post.emit(
      dev: <`Nexo Volta` handle=@nexoVolta/>
    );
  }

  [FS writeFile: :utf-8, new? Log{
    path: 'C://users/NexoV/memories/2025',
    message: 'before there was code, there was\n' *
      Figlet.toAscii(str prophecy),
    title: 'nu-Eden: Sundered Skies',
  }];
}

// variable declaration with and without type annotation
let mut a: i32 = 10;
let mut i32 x = 15;
pub let i32 a = 20;
let int[][][][] y = [[[[1, 2], [3]], [[4, 5]]], [[[6]]]];
let &mut int z = &mut a;
&Type a = 10;
(int | 'hello world') b = "hello world";
let int[] result = [];
pub func int x(mut const int x) =
  arr.reduce 0 (int|int sum, int value| sum + value);
let x = 10;
let mut str name = "Ruko";
let f32 pi = 3.14159;
let f64 x = 2.718281828459045;
let f128 z = 1.618033988749895;
let bool isActive = true;
let char initial = 'R';
let [int | str] c = 42;
mut<X :> T> func<T> identity = |x: x|: X = x;
mut<X :> T> func<T> X identity = X|x x| = x;
X<(|x| func<X>)> identity = |x: x|: X = x;
((((((((((((((((((((int | str))))))))))))))))))))[] c = [1, "two", 3, "four"];

// style DSL example
style `style` {
  width: 200px;
  draw: %draw(M 100 100 L 300 100 L 200 300 Z);
  background color: %322;
  text color: %rgb(255, 255, 255);
  fill: %url"https://example.com/resource.txt";
  content: %quote(\(({Hello, World!})\));
  font family: ['Courier New', :monospace];
  margin: 20px;
  padding: 10px;
  border: 2px :solid %#ff5733;
  font size: 14px;
  animation: blink(1s, :infinite, :easeInOut, :alternate);
  timestamp: %time'2024-06-01T12:00:00Z';
}

// imperative style
func int[][] sortedPowerSet(int[] arr) {
  mut int[][] result = [];

  for let int i in 0 ..< 1 << arr::len {
    mut int[] subset = [];
    for let int j in 0 ..< arr::len:
      if (i >> j) & 1:
        subset.=push arr[j];
    result.=push subset;
  }

  return result.=sort |int a, int b| {
    let int countA = a.reduce 0 (int|int c,, int i| c + 1);
    let int countB = b.reduce 0 (|int d,, int i| d + 1);
    if countA != countB:
      countA - countB;
    for let int i in 0 ..< min a::len b::len:
      if a[i] != b[i]:
        a[i] - b[i];
    a::len - b::len;
  }
}

// infix functional style
func int[][] sortedPowerSet = int[][]|int[] arr| 0 ..< 1 << arr::len
  \sort\ int[]|int a, int b| (-) ([a, b]
  \map\ int[]|int k| (arr \reduce\ 0, (int|int c,, int i| c + ((k >> i) & 1)))
    ) || arr \reduce\ 0, (int|int d,, int i| d || ((b >> i) & 1) - ((a >> i) & 1))
  \map\ int[]|int e| (arr \filter\ int|, int i| (e >> i) & 1);

// LINQ style
func int[][] sortedPowerSet(int[] arr) =
  from let int i in 0 ..< (1 << arr::len)
  select (
    from let int j in 0 ..< arr::len
    where (i >> j) & 1
    select arr[j] ) as let int[] subset
  sort by subset::len
  then by (
    from let int a, int b
    where a::len != b::len
    select a::len - b::len )
  then by (
    from let int i in 0 ..< min a::len b::len
    where a[i] != b[i]
    select a[i] - b[i] )
  then by a::len - b::len;

// Haskell/ML/Python style
func int[][] sortedPowerSet(int[] arr) =
  mut int[][] result = [];

  for let int i in 0 ..< 1 << arr::len:
    mut int[] subset = []
    for let int j in 0 ..< arr::len:
      if (i >> j) & 1:
        subset = push subset arr[j];
    result = push result subset;

  return sort result (int[][]|int a, int b| =
    let int countA = reduce a 0 (int|int c,, int i| c + 1);
    let int countB = reduce b 0 (int|int d,, int i| d + 1);
    if countA != countB:
      countA - countB;
    for let int i in 0 ..< min a::len b::len:
      if a[i] != b[i]:
        a[i] - b[i];
    a::len - b::len);

// Objective-C & Ruby style
func int[][] sortedPowerSet(int[] arr) {
  mut int[][] result = [];

  [0 ..< 1 << arr::len each: |int i| {
    mut int[] subset = [];
    [0 ..< arr::len each: |int j|
      if (i >> j) & 1: [subset =push: arr[j]]]
    [result =push: subset];
  }]

  return [result =sort: int[][]|int a, int b| {
    let int countA = [a reduce: 0, int|int c,, int i| c + 1];
    let int countB = [b reduce: 0, int|int d,, int i| d + 1];
    if countA != countB: return countA - countB;
    for let int i in 0 ..< min(a::len, b::len):
      if a[i] != b[i]:
        return a[i] - b[i];
    a::len - b::len;
  }];
}

// Lisp/Clojure/Scheme style (operators and calls only)
func int[][] sortedPowerSet(int[] arr) {
  mut int[][] result = [];

  for let int i in (..< 0 (<< 1 arr::len)) {
    mut int[] subset = [];
    for let int j in (..< 0 arr::len):
      if (& (>> i j) 1):
        subset = (push subset arr[j]);
    result = (push result subset);
  }

  return (sort result (int[][]|int a, int b| {
    let int countA = (reduce a 0 (int|int c,, int i| (+ c 1)));
    let int countB = (reduce b 0 (int|int d,, int i| (+ d 1)));
    if (!= countA countB):
      (- countA countB);
    for let int i in (..< 0 (min a::len b::len)):
      if (!= a[i] b[i]):
        (- a[i] b[i]);
    (- a::len b::len);
  }));
}

// JSX style
<decl (func int[][] sortedPowerSet(int[] arr))=(
  <mut(type int[][]) (result)=[]/>
  <for let(type int)=i in=(0 ..< 1 << arr::len)>
    <mut(type int[]) (subset)=[]/>
    <for let(type int)=j in=(0 ..< arr::len)>
      <if ((i >> j) & 1)>
        subset.=push arr[j];
      </if>
    </for>
    result.=push subset;
  </for>
  <return (result.=sort(int[][]|int a, int b| <>
    <let(type int) (countA)=(a.reduce 0 (int|int c,, int i| c + 1))/>
    <let(type int) (countB)=(b.reduce 0 (int|int d,, int i| d + 1))/>
    <if (countA != countB)>
      <return (countA - countB)/>
    </if>
    <for let(type int)=i in=(0 ..< min a::len b::len)>
      <if (a[i] != b[i])>
        <return (a[i] - b[i])/>
      </if>
    </for>
    <return (a::len - b::len)/>
  </>))/>
)/>;

// using the various sortedPowerSet implementations
for let i in sortedPowerSet [1 ... 16]:
  echo i;

// LINQ-style queries
func str formatPowerSet = |int[][] a| =
  a.iter(`iter`: from let int[] subset in a
    where subset::len > 0
    select '[' ++ [subset map: str x `join`: ','] ++ ']'
  ).join(', ');

print $ formatPowerSet sortedPowerSet [1 ..< 10];

// shader language subset example (WGSL-like)
shader MazeGenerator {
  struct Uniforms {prop u32 mazeSize, u32 numWalls};
  struct WallsArray {prop u32[] values};
  pub mut[group 0, id 0] Uniforms uniforms;
  out mut[group 0, id 1] u32[] walls;
  out mut[group 0, id 2] WallsArray wallsArray;

  func i32 getCellIndex(Vec2<i32> cellCoords) {
    let i32 size = i32 uniforms.mazeSize;
    cellCoords->y * size + cellCoords->x;
  }

  func f32 coinFlip(Vec2<f32> p) {
    mut Vec3<f32> p3 = fract $ Vec3 p->xyx * 0.1031;
    p3 += dot p3 (p3->yzx + 33.33);
    step 0.5 (fract (p3->x + p3->y) * p3->z);
  }

  // Carve walls for a given cell at random
  proc randomCarveCellWalls(Vec2<i32> cellCoords) {
    let i32 cellIndex = getCellIndex cellCoords;

    let i32 size = i32 uniforms.mazeSize;
    let i32 numWalls = i32 uniforms.numWalls;

    const i32 tWallType = 0; // top
    const i32 rWallType = 1; // right
    const i32 bWallType = 0; // bottom
    const i32 lWallType = 1; // left

    // isOnEdge -> Vec2 isMostLeftEdge isMostBottomEdge
    mut Vec2<bool> isOnEdge = cellCoords == Vec2 0;

    // main body: bottom and left edges
    let f32 bottomNotLeft = coinFlip $ Vec2<f32> cellCoords;
    let i32 bWallIndex = cellIndex * 2 + bWallType;
    let i32 lWallIndex = cellIndex * 2 + lWallType;
    let f32 carveBottom = mix bottomNotLeft 1.0 (f32 isOnEdge->x);
    let f32 carveLeft = mix (1.0 - bottomNotLeft) 1.0 (f32 isOnEdge->y);
    wallsArray.values[bWallIndex] = u32 bottomNotLeft;
    wallsArray.values[lWallIndex] = u32 $ 1.0 - bottomNotLeft;
  }

  compute proc<thread 8 8> main(Vec3<u32> @id) {
    randomCarveCellWalls $ Vec2<i32> @id->xy;
  }
}

// regex examples
/[\d\D]/;
/\p{L}+/;
/\p{Script=Latin}+/;
/\p{sc=Han}+/;
/\p{blk=UCAS_Ext_A}+/;
/\p{name~=/(SMILING|GRINNING) FACE/}/g;
/\p{InGreek}+/i;
/\p{Script=Hiragana}+/m;
/\p{Emoji_Presentation}+/gi;
/(?[\p{Thai}|\p{Lao}])/;
/(?[\p{Digit}&(\p{Thai}|\p{Lao})])/;
/(?[^\P{L}\p{M}])+/;

// generating a random string
func randomString = str |repeat, seed = 3**32| =
  [/[\da-z]/i random: seed, repeat toIter: `join`: ''];
print randomString;

// function call with different argument types
funcName(arg1: 10, &a arg2: 2, stat MyType{k: v} arg3: "hello");
let v = #{a: pub int|*a| a + 1};
oper int k + int x = x * 2;
x = pub int|*a| a + 1;

// chaining with custom operators
// Haskell-style
`iter` 4 $ every 3 (||+ n "10 20") $ (n "0 1 3") # s "triangle" # crush 4
// JavaScript-style
`iter`(4, every(3, add.squeeze("10 20"), n("0 1 3").s("triangle").crush(4)));
n("0 1 3").every(3, add.squeeze("10 20")).iter(4).s("triangle").crush(4)

// arbitrary base digits
let int `custom base` = 16b012345678۹۸۲۷۴٤۶;

// cursed C++ pointer manipulation example
proc x(
  struct {let u32 size = 32} a,
  *mut u8 addr,
  *const f64 b?,
  pub *i32 c?,
)(
  stat (K where K ~ (α + β + γ)) u,
  *pub ((|T, U| <(T as [*U]?)>(U ^ T)) | str) v,
  *&mut (α | β)? y?,
  &mut (***γ??? where !(α & β)?) z!,
): <α, β, γ>(
  ***[(α & β) | γ]? as [[*((|α| β) ^ γ)]?; 20]
) = unsafe {
  mut *α? p = null;
  mut **β? q = null;
  mut **γ? r = null;

  for let int i = 0, i < a::size + 17, i += 1 {
    if y? && !p?:
      p := &y as *α;
    if p? && !q? {
      q := &*(p as **β);
      q[i % 20] := (i * i << (i & 3)) ^ 0xfeedface;
    }
  }

  if z? && z != false:
    for let int j = 0, j < 20, j += 1:
      **z[j] := ((**z[j] ?? 0) + j) as γ;

  func str l = (compo)|*(*i32[]) θ| {
    θ[0][0] := θ[0][0] ^ 1337;
    <div style={color: :green}>\* Pointer value: #{*θ[0][0]} *\</>;
  }

  λ(&q as *(*i32[]));
}

x(
  struct {let u32 size = 32} {},
  unsafe {malloc u8},
  null,
  null,
)(
  stat u32,
  unsafe {malloc str},
  null,
  null,
);

// simple linked list node
struct Node {
  let i32 value;
  let *Node next;

  func *Node Node(i32 value) {
    let node = unsafe {malloc Node};
    node.value = value;
    node.next = null;
    return node;
  }
}

mut *Node head = Node 1;
head.next = Node 2;
head.next.next = Node 3;
head.next.next.next = null;
mut *Node current = head;
while current != null {
  print current.value;
  current = current.next;
}

// stropping keywords with invisible characters
`const` `let` mut `mut`: `in` i32 = 10;
scope `for` for let `in` in [`mut` alloc: init: release:]:
  print `in`;

// JSX with inline styles and dynamic class names
<div>
  for item in items:
    <`span` .item-[item.id]=item.id> item.name </`span`>;
</div>;

// JSX control structures
<for let=i in=(0 ... 10)>
  <if (x % 2 == 0)>
    <span>#"Even: #i"</span>
  <elif (x % 3 == 0)/>
    <span>#"Divisible by 3: #i"</span>
  <else/>
    <span>#"Other: #i"</span>
  </if>
</for>;

// The user hasn't been constructed yet, so we need
// to use 'as' here
let userToBeBuilt = {} as User;

|x| struct User {
  let str id;
  let str name;
  let i32 age?;
  let str email?;
}

let defaultUser = {
  id: "123",
  name: "Matt",
} by User;

// Assigning to a dynamic key
(const["name", "id"]).forEach(proc(str key) {
  userToBeBuilt[key] = "default"
});

// Style DSL example
style `style` {
  x: 100px;
  y: 100px;
  background color: :blue;
  color: %#ff5733;
  file path: %draw(M 50 50 L 150 50 L 100 150 Z);
  custom key: addedValue;
  dynamic[key] sub[key]: dynamicValue;

  @media (max width: 600px) {background color: :red;}

  @keyframes slidein {
    `from`(transform: translateX 0%);
    `to`(transform: translateX 100%);
  }

  @fontFace {
    font family: 'MyFont';
    src: %file"../fonts/myfont.woff2".format(:woff2);
    font weight: :normal;
    font style: :normal;
  }

  ^hover {color: :green;}
  &active {color: :yellow;}
  &visited {color: :purple;}
  ::before {content: 'Hello';}
  ::after {content: 'World';}

  // Nested selectors
  .container {
    display: :flex;
    flex direction: :column;

    .item {
      margin: 10px;
      padding: 5px;
    }
  }

  animation: slideIn 3s :easeInOut :infinite :alternate;
}

// Markdown literals (with embedded code)
<div>
  \\ # Generic Heading 1
  \\ ## Generic Heading 2
  \\ ### Generic Heading 3
  \\ #### Generic Heading 4
  \\ ##### Generic Heading 5
  \\ ###### Generic Heading 6

  <decl (func markdownExample(): void =
    <div .markdown-container>
    \*
      Term : definition term
           : definition description
      + x
        + _x
        + a_ n // comment after raw string
      - : x z
      > this starts a blockquote [example link](https://example.com)
      > > this is a nested blockquote
      > > _nested italic text
      > > continuing the nested blockquote_
      > - and **bold
      > - text** too
      > last line of the outer blockquote
      this starts a paragraph **with bold text** and _italic text
      with a raw string:_ `C:\Users\Name\Documents\file.txt`
      + ++underline++ ~~strikethrough~~ ==highlight== ||spoiler||
      - this is a list item ~subscript~ and ^superscript^
      + numbered list item (automatic) &#x1F600; &zcaron;
      [shortcut] [link text](https://example.com)
      ![image alt text](https://example.com/image.png)
      `pre-rendered` #obj.methodCall(arg1, arg2)
      {style X {x: 10px}}!(p inline styled paragraph)
      {inline code} !{color: :red}**bold red text**
      $\a + y = z ^ 2 - \sqrt{y + x + a}$ // inline math
      !(tag.class span tag with custom attributes !(x nested?!))
    *\

      for let i in 0 ... 3:
        \\ Loop iteration number: #a
    </div>
  )/>
</div>;

// LaTeX example
%latex
\documentclass{article}
\usepackage{amsmath}
\begin{document}
Here is an inline equation: \(E = mc^2\).
And here is a displayed equation:
\[
  \int_{a}^{b} f(x) \, dx = F(b) - F(a)
\]
\end{document}
latex%

// SQL query example
from users
left join posts on users.id = posts.user_id
where users.active = 1
group by users.id, users.name
having post_count > 10
order desc by post_count
limit 50
select users.id, users.name, count posts.id as post_count;

%sql
select users.id, users.name, count(posts.id) as post_count
from users
left join posts on users.id = posts.user_id
where users.active = 1
group by users.id, users.name
having post_count > 10
order by post_count desc
limit 50;
sql%

// Rust codegen example
%rs
fn main() {
  use std::collections::HashMap;
  use serde::{Serialize, Deserialize};
  use tokio::sync::broadcast;
  use warp::Filter;

  #[derive(Serialize, Deserialize, Clone)]
  struct Post {
    id: u32,
    title: String,
    content: String,
  }

  #[tokio::main]
  async fn main() {
    let (tx, _rx) = broadcast::channel(100);
    let tx_filter = warp::any().map(move || tx.clone());

    let post_route = warp::post()
      .and(warp::path("posts"))
      .and(warp::body::json())
      .and(tx_filter.clone())
      .and_then(handle_create_post);

    warp::serve(post_route).run(([127, 0, 0, 1], 6001)).await;
  }

  async fn handle_create_post(new_post: Post, tx: broadcast::Sender<Post>) -> Result<impl warp::Reply, warp::Rejection> {
    tx.send(new_post.clone()).unwrap();
    Ok(warp::reply::json(&new_post))
  }
}
rs%

// PHP & Laravel broadcasting example
%php
use x\y;

class PostCreated implements ShouldBroadcast {
  use Dispatchable, SerializesModels;
  public $post;
  public function __construct(Post $post) {
    $this->post = $post;
  }
}

class PostController extends Controller {
  public function store(Request $request) {
    $post = Post::create($request->all());
    broadcast(new PostCreated($post))->toOthers();
    return response()->json($post, 201);
  }
}

class Post extends Model {
  protected $fillable = ['title', 'content'];
}

class BroadcastServiceProvider extends ServiceProvider {
  public function boot() {
    Broadcast::routes();
    require base_path('routes/channels.php');
  }
}

class UserChannel {
  public function join(User $user) {
    return Auth::check();
  }
}

class PostChannel {
  public function join(User $user) {
    return Auth::check();
  }
}

channel('user.{id}', UserChannel::class);
channel('post.{id}', PostChannel::class);
php%

// JavaScript codegen example
%js
import React, { useEffect, useState } from 'react';
import { io } from "socket.io-client";

interface Post {
  id: number;
  title: string;
  content: string;
}

const socket = io("http://localhost:6001");

const App: React.FC = () => {
  const [posts, setPosts] = useState<Post[]>([]);

  useEffect(() => {
    socket.on("PostCreated", (data: Post) => {
      setPosts((prevPosts) => [...prevPosts, data]);
    });

    return () => {
      socket.off("PostCreated");
    };
  }, []);

  return (
    <div>
      <h1>Posts</h1>
      <ul>
        {posts.map((post) => (
          <li key={post.id}>
            <h2>{post.title}</h2>
            <p>{post.content}</p>
          </li>
        ))}
      </ul>
    </div>
  );
};

export default App;
js%

// string literals with interpolation and raw strings.
// unlike in other languages, function and method calls can be used inside interpolations.
let x = 42;

let multilineString = #"""
  This is a multiline string.
  It can span multiple lines.
  The value of x is: #x.toStr().concat('!').format(toHex: true)
""";

let rawString = $"""
  This is a raw string.
  It does not process escape sequences like \n or \t.
  You can include quotes " and backslashes \ without escaping.
""";

let combinedStr = #$"""
  Here is a raw string combined with interpolation. \t
  The value of x is: #x
""";

let templateString = @"""
  This is a template string, that is, a function returning a string.
  Arguments are provided for let interpolation, with the syntax @varName
  or @{mut varName = expression}.
  The value of x doubled is: @{x = x * 2}
""";

// regex with inline comments and whitespace
/
  (?xi)
  (&)(?:
      (\# 0*(?:\d|[1-9]\d{1,5}|10\d{5}|110\d{4}|111[0-3]\d{3}|11140\d{2}|111410\d|111411[01])) // decimal
    | (\#b0*(?:[01]|1[01]{1,19}|10000[01]{16})) // binary
    | (\#t0*(?:[012]|[12][012]{1,11}|1[012]{12}|200[01][012]{9}|20020[012]{8}|20021[01][012]{7}|2002120[012]{6}|20021210[01][012]{4}|2002121020[012]{3}|20021210210[012]{2}|200212102110[01])) // ternary
    | (\#q0*(?:[0-3]|[123][0-3]{1,9}|100[0-3]{8})) // quaternary
    | (\#s0*(?:[0-5]|[1-5][0-5]{1,6}|[12][0-5]{7}|3[0-4][0-5]{6}|35[0-4][0-5]{5}|3550[0-5]{4}|3551[012][0-5]{3}|35513[0-4][0-5]{2}|355135[012][0-5]|3551353[01])) // senary
    | (\#o0*(?:[0-7]|[1-7][0-7]{1,5}|[123][0-7]{6}|4[01][0-7]{5})) // octal
    | (\#z0*(?:[ab\d]|[1-b][ab\d]{1,4}|[123][ab\d]{5}|4[0-4][ab\d]{4}|45[0-7][ab\d]{3}|458[0-7][ab\d]{2}|4588\d[ab\d]|4588a[0-7])) // duodecimal
    | (\#x0*(?:\h|[1-f]\h{1,4}|10\h{4})) // hexadecimal
    | (\b[\p{Pd}\w]+\b) // named
    | ([^;\s]++) // invalid
  )(;)
/xi.test('&#x1F600;
  &#128512;
  &#b110000001010100000000000000000;
  &#t1002202000000;
  &#q10023020000;
  &#s1003200;
  &#o1405000;
  &#z468a0;
  &#x1F600;
  &#invalid;');

print "Regex matched valid numeral entities!";

// "coastline" @by eddyflux
// @version 1.0
// from the Strudel Synth Bank
// Snippet from Strudel Language Examples

// Haskell + Objective-C style
samples 'github:eddyflux/crate';
setcps 0.75;
let chords = [chord '<Bbm9 Fm9>/4' dict: 'ireal'];
[stack (
  [stack (
      // DRUMS
      [s 'bd' `struct`: '<[x*<1 2> [~@3 x]] x>'],
      [s '~ [rim, sd:<2 3>]' room: '<0 0.2>'],
      [n '[0 <1 3>]*<2!3 4>' s: 'hh'],
      [s 'rd:<1!3 2>*2' mask: '<0 0 1 1>/16' gain: 0.5],
    ) bank: 'crate' mask: '<[0 1] 1 1 1>/16' early: 0.5],
  // CHORDS
  [chords offset: -1 voicing:s: 'gm_epiano1:1' phaser: 4 room: 0.5],
  // MELODY
  [n '<0!3 1*2>' `mut`: chords mode: 'root:g2' voicing:s: 'gm_acoustic_bass'],
  [chords n: '[0 <4 3 <2 5>>*2](<3 5>,8)' anchor: 'D5' voicing:segment: 4
    clip: rand.range 0.4 0.8 room: 0.75 shape: 0.3 delay: 0.25
    fm: [sine.range 3 8 slow: 8] lpf: [sine.range 500 1000 slow: 8]
    lpq: 5 rarely: ply '2' chunk: 4 fast: 2 gain: [perlin.range 0.6 0.9]
    mask: '<0 1 1 0>/16'
  ]),
  late: '[0 0.01]*4' late: '[0 0.01]*2' size: 4 delay: 0.125 size: 2 mix: 0.3
  run: 64
];

// JavaScript-style
samples('github:eddyflux/crate');
setcps(0.75);
let chords = chord('<Bbm9 Fm9>/4').dict('ireal');
stack(
  stack(
    // DRUMS
    s('bd').struct('<[x*<1 2> [~@3 x]] x>'),
    s('~ [rim, sd:<2 3>]').room('<0 0.2>'),
    n('[0 <1 3>]*<2!3 4>').s('hh'),
    s('rd:<1!3 2>*2').mask('<0 0 1 1>/16').gain(0.5)
  ).bank('crate').mask('<[0 1] 1 1 1>/16').early(0.5),
  // CHORDS
  chords.offset(-1).voicing().s('gm_epiano1:1').phaser(4).room(0.5),
  // MELODY
  n('<0!3 1*2>').mut(chords).mode('root:g2').voicing().s('gm_acoustic_bass'),
  chords.n('[0 <4 3 <2 5>>*2](<3 5>,8)').anchor('D5').voicing().segment(4)
    .clip(rand.range(0.4, 0.8)).room(0.75).shape(0.3).delay(0.25)
    .fm(sine.range(3, 8).slow(8)).lpf(sine.range(500, 1000).slow(8)).lpq(5)
    .rarely().ply('2').chunk(4).fast(2).gain(perlin.range(0.6, 0.9))
    .mask('<0 1 1 0>/16')
);