// test file for the Ruko Language
proc main {
  use Figlet.*,
    Dom.{Canvas, Audio, FS, Log}, 
    Artists.NexoVolta,
    Galaxies.MilkyWay:Galaxy,
    Components.Post

  let stars = Galaxy.getVisibleStars()

  if const prophecy = 3 ** (3 * 2) &&
  stars has "Alained" &&
  "Nexo" in stars \map\ .name {
    [Dom.Canvas clear:
                setBackground: 'black'
                draw: prophecy.toSVG()]
    [Audio.Track play: './VirtualRiot-Reconnect.mp3'
                 volume: 0.8
                 loop͏: true]
    Post.emit(
      dev: <NexoVolta handle=@nexovolta/>
    )
  }

  [FS writeFile: :utf-8, new Log{
    path: 'C://users/NexoV/memories/2025'
    message: 'before there was code, there was\n' *
      Figlet.toAscii (str prophecy)
    title: 'nu-Eden: Sundered Skies'
  }]
}

// style DSL example
style {
  width: 200px
  draw: %path(M 100 100 L 300 100 L 200 300 Z)
  background: %322
  color: %rgb(255, 255, 255)
  fill: %url(https://example.com/resource.txt)
  content: %quote(\((({Hello, World!})\)))
  fontFamily: ['Courier New', :monospace]
  margin: 20px
  padding: 10px
  border: 2px :solid %#ff5733
  fontSize: 14px
  animation: blink(1s, :infinite, :easeInOut, :alternate)
  timestamp: %time(2024-06-01T12:00:00Z)
}

// imperative style
func sortedPowerSet(arr: [i32]): [[i32]] {
  mut result: [[i32]] = []

  for let i in 0 ..< 1 << arr.len {
    mut subset: [i32] = []
    for let j in 0 ..< arr.len if (i >> j) & 1:
      subset.=push arr[j]
    result.=push subset
  }

  return result.=sort |a, b| {
    let countA = a.reduce 0, |c,, i| c + 1
    let countB = b.reduce 0, |d,, i| d + 1
    if countA != countB:
      countA - countB
    for let i in 0 ..< min a.len b.len if a[i] != b[i]:
      a[i] - b[i]
    a.len - b.len
  }
}

// infix functional style
let sortedPowerSet = |arr| 0 ..< 1 << arr.len
  \sort\ |a, b| (-) ([a, b] \map\
      |k| (arr \reduce\ 0, |c,, i| c + ((k >> i) & 1))
    ) || arr \reduce\ 0, |d,, i| d || ((b >> i) & 1) - ((a >> i) & 1)
  \map\ |e| (arr \filter\ |, i| (e >> i) & 1)

// LINQ style 
func sortedPowerSet(arr: [i32]): [[i32]] = (
  from let i in 0 ..< (1 << arr.len)
  select (
    from let j in 0 ..< arr.len
    where (i >> j) & 1
    select arr[j]
  ) as let subset
  sort by subset.len
  then by (
    from let a, b
    where a.len != b.len
    select a.len - b.len
  ) then by (
    from let i in 0 ..< min(a.len, b.len)
    where a[i] != b[i]
    select a[i] - b[i]
  ) then by a.len - b.len
)

// Haskell/ML/Python style
func sortedPowerSet(arr: [i32]): [[i32]] =
  let result = []: [[i32]]

  for let i in 0 ..< 1 << arr.len
    let subset = []: [i32]
    for let j in 0 ..< arr.len
      if (i >> j) & 1
        subset = push subset arr[j]
    result = push result subset

  sort result |a, b|
    let countA = reduce a 0, |c,, i| c + 1
    let countB = reduce b 0, |d,, i| d + 1
    if countA != countB
      countA - countB
    for let i in 0 ..< min a.len b.len
      if a[i] != b[i]
        a[i] - b[i]
    a.len - b.len

// Objective-C & Ruby style
func sortedPowerSet(arr: [i32]): [[i32]] {
  let result: [[i32]] = []

  [0 ..< 1 << arr.len each: |i| {
    let subset: [i32] = []
    [0 ..< arr.len each: |j|
      if (i >> j) & 1: [subset =push: arr[j]]]
    [result =push: subset]
  }]

  return [result =sort: |a, b| {
    let countA = [a reduce: 0, |c,, i| c + 1]
    let countB = [b reduce: 0, |d,, i| d + 1]
    if countA != countB: return countA - countB
    for let i in 0 ..< min(a.len, b.len) if a[i] != b[i]:
      return a[i] - b[i]
    a.len - b.len
  }]
}

// Clojure style
func sortedPowerSet(arr: [i32]): [[i32]] = (
  (mut (type [[i32]]) result [])

  (for (let i) in (..< 0 (<< 1 arr.len))) (
    (mut (type [i32]) subset [])
    (for (let j) in (..< 0 arr.len)) (
      (if (& 1 (>> i j)) 
        (push subset arr[j])
      )
    )
    (push result subset)
  )

  (return (sort result (|a, b| (
    (let (type i32) countA (reduce a 0 (|c,, i| (+ c 1))))
    (let (type i32) countB (reduce b 0 (|d,, i| (+ d 1))))
    (if (!= countA countB)
      (- countA countB)
    )
    (for (let i) in (..< 0 (min a.len b.len))) (
      (if (!= a[i] b[i])
        (- a[i] b[i])
      )
    )
    (- a.len b.len)
  ))))
)

// JSX style
<let (func sortedPowerSet(arr: i32): [[i32]])=(
  <mut(type [[i32]]) (result)=[]/>
  <for let=i in=(0 ..< 1 << arr.len)>
    <mut(type [i32]) (subset)=[]/>
    <for let=j in=(0 ..< arr.len)> 
      <if ((i >> j) & 1)>
        subset.=push arr[j]
      </if>
    </for>
    result.=push subset
  </for>
  result.=sort |a, b| <>
    <let(type i32) (countA)=(a.reduce 0, |c,, i| c + 1)/>
    <let(type i32) (countB)=(b.reduce 0, |d,, i| d + 1)/>
    <if (countA != countB)>
      <return (countA - countB)/>
    </if>
    <for let=i in=(0 ..< min a.len b.len)>
      <if (a[i] != b[i])>
        <return (a[i] - b[i])/>
      </if>
    </for>
    <return (a.len - b.len)/>
  </>
  <return (result)/>)
/>

// using the various sortedPowerSet implementations
for let i in sortedPowerSet [1...16]:
  echo i

// LINQ-style queries
let formatPowerSet = |a: [[i32]]|: str =
  a.iter(iter: from let (subset: [i32]) in a where subset.len > 0
    select '[' ++ [subset map: str x join: ','] ++ ']'
  ).join(', ')

print $ formatPowerSet sortedPowerSet [1..<10]

// shader language subset example (WGSL-like)
shader MazeGenerator {
  struct Uniforms { prop mazeSize: n32, numWalls: n32 }
  struct WallsArray { prop values: n32[] }
  uniform mut<grp 0, id 0> uniforms: Uniforms
  storage mut<grp 0, id 1> walls: n32[]
  storage mut<grp 0, id 2> wallsArray: WallsArray

  func getCellIndex(cellCoords: Vec2<i32>): i32 {
    let size = i32 uniforms.mazeSize
    cellCoords->y * size + cellCoords->x
  }

  func coinFlip(p: Vec2<f32>): f32 {
    mut p3: Vec3<f32> = fract $ Vec3 p->xyx * 0.1031
    p3 += dot p3 (p3->yzx + 33.33)
    step 0.5 (fract (p3->x + p3->y) * p3->z)
  }

  // Carve walls for a given cell at random
  proc randomCarveCellWalls(cellCoords: Vec2<i32>) {
    let cellIndex: i32 = getCellIndex cellCoords

    let size = i32 uniforms.mazeSize
    let numWalls = i32 uniforms.numWalls

    const tWallType: i32 = 0 // top
    const rWallType: i32 = 1 // right
    const bWallType: i32 = 0 // bottom
    const lWallType: i32 = 1 // left

    // isOnEdge -> Vec2(isMostLeftEdge, isMostBottomEdge)
    mut isOnEdge: Vec2<bool> = cellCoords == Vec2 0

    // main body: bottom and left edges
    let bottomNotLeft: f32 = coinFlip $ Vec2<f32> cellCoords
    let bWallIndex: i32 = cellIndex * 2 + bWallType
    let lWallIndex: i32 = cellIndex * 2 + lWallType
    let carveBottom: f32 = mix bottomNotLeft 1.0 (f32 isOnEdge->x)
    let carveLeft: f32 = mix (1.0 - bottomNotLeft) 1.0 (f32 isOnEdge->y)
    wallsArray.values[bWallIndex] = n32 bottomNotLeft
    wallsArray.values[lWallIndex] = n32 $ 1.0 - bottomNotLeft
  }

  compute proc<threadGrp 8 8> main(@id: Vec3<n32>) {
    randomCarveCellWalls $ Vec2<i32> @id->xy
  }
}

// "coastline" @by eddyflux
// @version 1.0
// from the Strudel Synth Bank
// Snippet from Strudel Language Examples

// Haskell + Objective-C style
samples 'github:eddyflux/crate'
setcps 0.75
let chords = [chord '<Bbm9 Fm9>/4' dict: 'ireal']
[stack (
  [stack (
      // DRUMS
      [s 'bd' struct͏: '<[x*<1 2> [~@3 x]] x>']
      [s '~ [rim, sd:<2 3>]' room: '<0 0.2>']
      [n '[0 <1 3>]*<2!3 4>' s: 'hh']
      [s 'rd:<1!3 2>*2' mask: '<0 0 1 1>/16' gain: 0.5]
    ) bank: 'crate' mask: '<[0 1] 1 1 1>/16' early: 0.5]
  // CHORDS
  [chords offset: -1 voicing: s: 'gm_epiano1:1' phaser: 4 room: 0.5]
  // MELODY
  [n '<0!3 1*2>' set͏: chords mode: 'root:g2' voicing: s: 'gm_acoustic_bass']
  [chords n: '[0 <4 3 <2 5>>*2](<3 5>,8)' anchor: 'D5' voicing: segment: 4
    clip: rand.range 0.4 0.8 room: 0.75 shape: 0.3 delay: 0.25
    fm: [sine.range 3 8 slow: 8] lpf: [sine.range 500 1000 slow: 8]
    lpq: 5 rarely: ply '2' chunk: 4 fast: 2 gain: [perlin.range 0.6 0.9]
    mask: '<0 1 1 0>/16' 
  ]) 
  late: '[0 0.01]*4' late: '[0 0.01]*2' size: 4 delay: 0.125 size: 2 mix: 0.3
  run: 64
]

// JavaScript-style
samples('github:eddyflux/crate')
setcps(0.75)
let chords = chord('<Bbm9 Fm9>/4').dict('ireal')
stack(
  stack(
    // DRUMS
    s('bd').struct('<[x*<1 2> [~@3 x]] x>'),
    s('~ [rim, sd:<2 3>]').room('<0 0.2>'),
    n('[0 <1 3>]*<2!3 4>').s('hh'),
    s('rd:<1!3 2>*2').mask('<0 0 1 1>/16').gain(0.5)
  ).bank('crate').mask('<[0 1] 1 1 1>/16').early(0.5),
  // CHORDS
  chords.offset(-1).voicing().s('gm_epiano1:1').phaser(4).room(0.5),
  // MELODY
  n('<0!3 1*2>').set(chords).mode('root:g2').voicing().s('gm_acoustic_bass'),
  chords.n('[0 <4 3 <2 5>>*2](<3 5>,8)').anchor('D5').voicing().segment(4) 
  .clip(rand.range(0.4, 0.8)).room(0.75).shape(0.3).delay(0.25)
   .fm(sine.range(3, 8).slow(8)).lpf(sine.range(500, 1000).slow(8)).lpq(5) 
   .rarely().ply('2').chunk(4).fast(2).gain(perlin.range(0.6, 0.9)) 
   .mask('<0 1 1 0>/16')
)

// Style DSL example
style style͏ {
  x: 100px
  y: 100px
  background: :blue
  color: %#ff5733
  path: %path(M 50 50 L 150 50 L 100 150 Z)
  customKey: addedValue
  dynamic[key]-sub[key]: dynamicValue

  @media(max-width: 600px)
    background: :red

  @keyframes slidein
    from͏(transform: translateX 0%)
    to͏(transform: translateX 100%)

  @fontFace
    fontFamily: 'MyFont'
    src: [url '../fonts/myfont.woff2' format: :woff2]

  ^hover
    color: :green

  &active
    color: :yellow

  /* Nested selectors */
  .container {
    display: :flex
    flexDirection: :column

    .item {
      margin: 10px
      padding: 5px
    }
  }

  animation: slideIn 3s :easeInOut :infinite :alternate
}

// SQL query example
from users
left join posts on users.id = posts.user_id
where users.active = 1
group by users.id, users.name
having post_count > 10
order by post_count, desc
limit 50
select users.id, users.name, count(posts.id) as post_count;

script sql {
  select users.id, users.name, count(posts.id) as post_count
  from users
  left join posts on users.id = posts.user_id
  where users.active = 1
  group by users.id, users.name
  having post_count > 10
  order by post_count desc
  limit 50;
}

// PHP & Laravel broadcasting example
script php {
  class PostCreated implements ShouldBroadcast {
    use Dispatchable, SerializesModels;
    public $post;
    public function __construct(Post $post) {
      $this->post = $post;
    }
  }

  class PostController extends Controller {
    public function store(Request $request) {
      $post = Post::create($request->all());
      broadcast(new PostCreated($post))->toOthers();
      return response()->json($post, 201);
    }
  }

  class Post extends Model {
    protected $fillable = ['title', 'content'];
  }

  class BroadcastServiceProvider extends ServiceProvider {
    public function boot() {
      Broadcast::routes();
      require base_path('routes/channels.php');
    }
  }

  class UserChannel {
    public function join(User $user) {
      return Auth::check();
    }
  }

  class PostChannel {
    public function join(User $user) {
      return Auth::check();
    }
  }

  channel('user.{id}', UserChannel::class);
  channel('post.{id}', PostChannel::class);
}

// JavaScript codegen example
script js {
  import React, { useEffect, useState } from 'react';
  import { io } from "socket.io-client";

  interface Post {
    id: number;
    title: string;
    content: string;
  }

  const socket = io("http://localhost:6001");

  const App: React.FC = () => {
    const [posts, setPosts] = useState<Post[]>([]);

    useEffect(() => {
      socket.on("PostCreated", (data: Post) => {
        setPosts((prevPosts) => [...prevPosts, data]);
      });

      return () => {
        socket.off("PostCreated");
      };
    }, []);

    return (
      <div>
        <h1>Posts</h1>
        <ul>
          {posts.map((post) => (
            <li key={post.id}>
              <h2>{post.title}</h2>
              <p>{post.content}</p>
            </li>
          ))}
        </ul>
      </div>
    );
  };

  export default App;
}

// regex examples
/[\d\D]/
/\p{L}+/
/\p{Script=Latin}+/
/\p{sc=Han}+/
/\p{blk=UCAS_Ext_A}+/
/\p{name~=/(SMILING|GRINNING) FACE/}/g
/\p{InGreek}+/i
/\p{Script=Hiragana}+/m
/\p{Emoji_Presentation}+/gi

// generating a random string
let randomString |repeat, seed = 3**32|: str =
  [/[\da-z]/i random: seed, repeat toIter: join: '']
print randomString

// function call with different argument types
funcName(arg1: 10, &mut arg2: 2, stat arg3: {k: v} as MyType)
v = #{a: pub|*a| a + 1}

// chaining with custom operators
// Haskell-style
iter 4 $ every 3 (||+ n "10 20") $ (n "0 1 3") # s "triangle" # crush 4 
// JavaScript-style
iter(4, every(3, add.squeeze("10 20"), n("0 1 3").s("triangle").crush(4)))
n("0 1 3").every(3, add.squeeze("10 20")).iter(4).s("triangle").crush(4)

// iterating with index
for let item, index in items:
  print $"Item #index: #item.name"

// cursed C++ pointers
let val: i32* (*(*(**[]) (i8, i32* i32*)) []) (i8**, i32** ()) = null

// simple linked list node
struct Node {
  let value: i32
  let next: *Node

  func Node(value: i32): *Node {
    let node = unsafe {malloc Node}
    node.value = value
    node.next = null
    return node
  }
}

mut head: *Node = Node 1
head.next = Node 2
head.next.next = Node 3
head.next.next.next = null
auto current: *Node = head
while current != null {
  print current.value
  current = current.next
}

// stropping keywords with invisible characters
const͏ let͏ var var͏: in͏ i32 = 10
scope for͏ for let in͏ in [var͏ alloc: init: release:]:
  print in͏

// jsx with inline styles and dynamic class names
<div>
  for item in items:
    <span .item-[item.id]=item.id> item.name </span>
</div>

// JSX control structures
<for let=i in=(0...10)>
  <if (x % 2 == 0)>
    <span> #"Even: #i" </span>
  <elif (x % 3 == 0)/>
    <span> #"Divisible by 3: #i" </span>
  <else/>
    <span> #"Other: #i" </span>
  </if>
</for>

// string literals with interpolation and raw strings.
// unlike in other languages, function and method calls can be used inside interpolations.
let x: i32 = 42

let multilineString: str = #"""
  This is a multiline string.
  It can span multiple lines.
  The value of x is: #x.toStr().concat('!').format(toHex: true)
"""

let rawString: str = `"""
  This is a raw string.
  It does not process escape sequences like \n or \t.
  You can include quotes " and backslashes \ without escaping.
"""

let combinedStr = #`"""
  Here is a raw string combined with interpolation.
  The value of x is: #x
"""

let templateString: str = @"""
  This is a template string, that is, a function returning a string.
  Arguments are provided for interpolation, with the syntax @varName
  or @{mut varName = expression}.
  The value of x doubled is: @{x = x * 2}
"""

// regex with inline comments and whitespace
/
  (&)(?:
      (\# 0*\d{1,7}) // decimal
    | (\#b0*[01]{1,16}) // binary
    | (\#t0*[0123]{1,20}) // ternary
    | (\#q0*[0-3]{1,18}) // quaternary
    | (\#s0*[0-5]{1,14}) // senary
    | (\#o0*[0-7]{1,11}) // octal
    | (\#z0*[\d↊↋ab]{1,10}) // duodecimal
    | (\#x0*(?:10\h{6}|\h{1,5})) // hexadecimal
    | (\b[\p{Pd}\w]+\b) // named
    | ([^;\s]++) // invalid
  )(;)
/xi.test('&#x1F600; 
  &#128512;
  &#b110000001010100000000000000000;
  &#t1002202000000;
  &#q10023020000;
  &#s1003200;
  &#o1405000;
  &#z468a0;
  &#x1F600;
  &#invalid;')

print "Regex matched valid numeral entities!"

<div>
  \\ # Generic Heading 1
  \\ ## Generic Heading 2
  \\ ### Generic Heading 3
  \\ #### Generic Heading 4
  \\ ##### Generic Heading 5
  \\ ###### Generic Heading 6

  <func (func markdownExample(): void)>
    <div .markdown-container>
    \*
      : definition term
      : definition description
      + x
      + _x
      + a_ n
      - : x z
      > this starts a blockquote [example link](https://example.com)
      > > this is a nested blockquote
      > > _nested italic text
      > > continuing the nested blockquote_
      > - and **bold 
      > - text** too
      > last line of the outer blockquote
      this starts a paragraph **with bold text** and _italic text 
      with a raw string:_ `C:\Users\Name\Documents\file.txt`
      + ++underline++ ~~strikethrough~~ ==highlight== ||spoiler|| 
      - this is a list item
      - another list item
      + numbered list item (automatic)
      [link text](https://example.com) 
      and an image: ![alt text](https://example.com/image.png)
      `inline code`
      $\a + y = z ^ 2 - \sqrt{y + x}$
      !!!tag.class span tag with custom attributes 
       !!x nested?! !! 
      !!!
    *\

      for let i in (0...3):
        \\ Loop iteration number: #a
    </div>
  </func>
</div>