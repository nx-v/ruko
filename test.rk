// function call with different argument types
funcName(arg1: 10, &mut arg2: 2, stat arg3: {k: v} as MyType)
v = #{a: pub|*a| a + 1}

// regex examples
/\p{sc=Han}+/
/\p{blk=UCAS_Ext_A}+/ 
/\p{name~=/(SMILING|GRINNING) FACE/}/g



let randomString = |repeat, seed = 3**32|: str
  // objective c method call style
  [/[\da-z]/i random: seed, repeat toIter:() join: ""] 
print randomString

// css codegen example
style {
  for i in arr: .item-<i> {
    color: if i % 2 == 0: red else blue
    width: (100 + i * 10)px
    opacity: i / len arr
  }
  additional_style: true
}

for (items) as let (item, index):
  print $"Item $index: $item.name"

// jsx with inline code
<div>
; for item in items:
  <span .item-<item.id|>fn>-x=$item.id> $item.name </>
</>

// cursed c++ pointers
struct Node {
  let value: i32
  let _next: *Node

  proc new(value: i32): *Node {
    let node = malloc Node
    node.value = value
    node._next = null
    return node
  }
}

a $"x = $var1 and y = \e${var2 + 10}{""

// Ruko PRNG implementation
class RukoPRNG : PRNG {
  const N = 624
  const M = 397

  mut state: [u32; N]
  mut left: i32 = 0
  mut p_next: &u32 = &state[0]

  proc seed_from_urandom(): void {
    let ur = open("/dev/urandom", :read)
    if ur is Error {
      let t = time.now().to_unix()
      let c = time.clock.to_nanosecs()
      $seed <| $hash t c
      return
    }

    mut big: [u32; N]
    scope {
      let file = ur
      for i in 0..<N {
        mut buf: [u8; 4]
        let read_bytes = file.read <| &mut buf
        if read_bytes != 4 {
          let t = time.now().to_unix()
          let c = time.clock.to_nanosecs()
          $seed <| $hash t c
          return
        }
        big[i] = *cast<*const u32> &buf[0]
      }
    }

    $seed &big.0 N
  }

  proc twist(u: u32, v: u32, w: u32): u32 {
    let x = (u & 0x80000000) | (v & 0x7fffffff)
    let xA = x >> 1
    if x % 2 != 0: xA ^= 0x9908b0df
    return xA ^ w
  }

  proc ~RukoPRNG(): void {
    // destructor
  }
}

struct SpiderMan {
  prop finger: *SpiderMan
}
proc main(): void {
  mut A: *SpiderMan = new SpiderMan
  mut B: *SpiderMan = new SpiderMan
  A->finger = B
  B->finger = A
  return
}

// infix function syntax
let sortedPowerSet = |arr| 0 ..< 1 << len arr
  \sort\ (|a, b| (-) ([a, b] \map\
      |k| (arr \reduce\ 0, |c,, i| c + ((k >> i) & 1))
    ) || arr \reduce\ 0, |d,, i| d || ((b >> i) & 1) - ((a >> i) & 1))
  \map\ (|e| arr \filter\ |, i| (e >> i) & 1)

func sortedPowerSet(arr: i32[]): i32[][] {
  mut result: i32[][] = new i32[][]
  let n: i32 = arr.len

  for let i in 0 ..< 1 << n {
    mut subset: i32[] = new i32[]
    for let j in 0..<n if (i >> j) & 1:
      subset.push arr[j]
    result.push subset
  }

  [result sort: |a: i32[], b: i32[]|: i32 {
    for let x, y in a.iter() \zip\ b.iter() if x != y:
      return x \cmp\ y
    a.len \cmp\ b.len
  }]

  result
}

sortedPowerSet 1..<20 |> print

for let i in sortedPowerSet [1...16]:
  echo i

let formatPowerSet = |a: i32[][]|: str =
  a.iter(_iter: from let (subset: i32[]) in a
    select '[' ++ [subset map: str x join: ','] ++ ']'
  ).join ', '
