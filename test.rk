// regex examples
/\p{sc=Han}+/
/\p{blk=UCAS_Ext_A}+/ 
/\p{name~=/(SMILING|GRINNING) FACE/}/g
/\p{InGreek}+/i
/\p{Script=Hiragana}+/m
/\p{Emoji_Presentation}+/gi

// generating a random string
let randomString |repeat, seed = 3**32|: str =
  [/[\da-z]/i random: seed, repeat toIter: join: ''] 
print randomString

// infix function syntax
let sortedPowerSet = |arr| 0 ..< 1 << len arr
  \sort\ |a, b| (-) ([a, b] \map\
      |k| (arr \reduce\ 0, |c,, i| c + ((k >> i) & 1))
    ) || arr \reduce\ 0, |d,, i| d || ((b >> i) & 1) - ((a >> i) & 1)
  \map\ |e| (arr \filter\ |, i| (e >> i) & 1)

// infix and smalltalk function calls
func sortedPowerSet(arr: i32[]): i32[][] {
  mut result: i32[][] = []
  let n: i32 = arr.len

  for let i in 0 ..< 1 << n {
    mut subset: i32[] = []
    for let j in 0..<n if (i >> j) & 1:
      subset.push arr[j]
    result.push subset
  }

  [result sort: |a: i32[], b: i32[]|: i32 {
    for let x, y in a.iter() \zip\ b.iter() if x != y:
      return x <=> y
    a.len <=> b.len
  }]

  result
}

// Shader Language example
shader MazeGenerator {
  shader<group 0, binding 0> mut<uniform> uniforms: Uniforms
  shader<group 0, binding 1> mut<storage> walls
  struct Uniforms {
    prop maze_size: u32
    prop num_walls: u32
  }
  struct WallsArray {
    prop values: u32[]
  }
  shader<group 0, binding 2> mut<storage> walls_array: WallsArray

  func get_cell_index(cell_coords: Vec2<i32>): i32 {
    let size: i32 = i32 uniforms.maze_size
    return cell_coords.y * size + cell_coords.x
  }

  func coin_flip(p: Vec2<f32>): f32 {
    mut p3: Vec3<f32> = fract (Vec3 p.xyx * 0.1031)
    p3 = p3 + dot p3 (p3.yzx + 33.33)
    return step 0.5 (fract (p3.x + p3.y) * p3.z)
  }

  // Carve walls for a given cell at random
  proc random_carve_cell_walls(cell_coords: Vec2<i32>) {
    let cell_index: i32 = get_cell_index(cell_coords)

    let size: i32 = i32 uniforms.maze_size
    let num_walls: i32 = i32 uniforms.num_walls

    const t_wall_type: i32 = 0 // top
    const r_wall_type: i32 = 1 // right
    const b_wall_type: i32 = 0 // bottom
    const l_wall_type: i32 = 1 // left

    // is_on_edge -> Vec2(is_most_left_edge, is_most_bottom_edge)
    mut is_on_edge: Vec2<bool> = cell_coords == Vec2 0

    // main body: bottom and left edges
    let bottom_not_left: f32 = coin_flip (Vec2<f32> cell_coords)
    let b_wall_index: i32 = cell_index * 2 + b_wall_type
    let l_wall_index: i32 = cell_index * 2 + l_wall_type
    let carve_bottom: f32 = mix bottom_not_left 1.0 (f32 is_on_edge.x)
    let carve_left: f32 = mix (1.0 - bottom_not_left) 1.0 (f32 is_on_edge.y)
    walls_array.values[b_wall_index] = u32 bottom_not_left
    walls_array.values[l_wall_index] = u32 (1.0 - bottom_not_left)
  }

  comp proc<threadGroup 8 8> main(id: Vec3<u32>) {
    random_carve_cell_walls (Vec2<i32> id.xy)
  }
}

// Using the function
sortedPowerSet 1..<20 |> echo
for let i in sortedPowerSet [1...16]:
  echo i

// LINQ-style queries
let formatPowerSet = |a: i32[][]|: str =
  a.iter(iter: from let (subset: i32[]) in a where subset.len > 0
    select '[' ++ [subset map: str x join: ','] ++ ']'
  ).join ', '

print <| formatPowerSet sortedPowerSet [1..<10]

// function call with different argument types
funcName(arg1: 10, &mut arg2: 2, stat arg3: {k: v} as MyType)
v = #{a: pub|*a| a + 1}

// Style DSL example
style `style {
  x: 0x64px
  y: 0x64px
  background: blue
  color: #ff5733
  path: 'M 10 10
    H 90
    V 90
    H 10
    Z' // SVG path data
  customKey: addedValue
  dynamic[key]-sub[key]: dynamicValue

  @media(max-width: 600px)
    background: red

  @keyframes slidein
    `from(transform: translateX 0%)
    `to(transform: translateX 100%)

  @fontFace
    fontFamily: `MyFont
    src: url 'myfont.woff2', format :woff2

  ^hover
    color: green

  &active
    color: yellow

  /* Nested selectors */
  .container {
    display: flex
    flexDirection: column

    .item {
      margin: 10px
      padding: 5px
    }
  }

  animation: slideIn 3s easeInOut infinite alternate
}

// css codegen example
style {
  for let i in arr: .item-[i] {
    color: if i % 2 == 0: red else blue
    width: (100 + i * 10)px
    opacity: i / len arr
  }
  additional_style: true
}

for items as let item, index:
  print $"Item $index: $item.name"

// jsx with inline code
<div>
; for item in items:
  <span .item-[item.id]=$item.id>$item.name</>
</>

// cursed c++ pointers
struct Node {
  let value: i32
  let next: *Node

  proc new(value: i32): *Node {
    let node = malloc Node
    node.value = value
    node.next = null
    return node
  }
}

// stropping
`const `let var x: `in i32 = 10
scope `for for let x in [x alloc: init: release:]:
  print x

// JSX control structures
<for let=$i in=(0...10)>
  <if (x % 2 == 0)>
    ; print i
  </>
</>