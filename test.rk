// test file for the Ruko Language
proc main {
  import Figlet.*,
    Dom.{Canvas, Audio, FS, Log}, // multiple imports
    Artists.NexoVolta, // nested imports
    Galaxies.MilkyWay:Galaxy, // custom import aliasing
    Components.Post

  let stars = Galaxy.getVisibleStars()

  if const prophecy = 3 ** (3 * 2) &&
  stars has "Alained" &&
  "Nexo" in stars \map\ .name {
    [Dom.Canvas clear:
                setBackground: 'black'
                draw: prophecy.toSVG()]
    [Audio.Track play: './VirtualRiot-Reconnect.mp3'
                 volume: 0.8 
                 loop͏: true]
    Post.emit(
      dev: <NexoVolta handle=@nexovolta/>
    )
  }

  [FS write: new Log{
    path: 'C://users/NexoV/memories/2025'
    message: 'before there was code, there was\n' *
      Figlet.toAscii (str prophecy)
    title: 'nu-Eden: Sundered Skies'
  }]
}

// regex examples
/[\d\D]/
/\p{L}+/
/\p{Script=Latin}+/
/\p{sc=Han}+/
/\p{blk=UCAS_Ext_A}+/
/\p{name~=/(SMILING|GRINNING) FACE/}/g
/\p{InGreek}+/i
/\p{Script=Hiragana}+/m
/\p{Emoji_Presentation}+/gi

// generating a random string
let randomString |repeat, seed = 3**32|: str =
  [/[\da-z]/i random: seed, repeat toIter: join: '']
print randomString

// imperative style
func sortedPowerSet(arr: i32[]): i32[][] {
  mut result: i32[][] = []

  for let i in 0 ..< 1 << arr.len {
    mut subset: i32[] = []
    for let j in 0 ..< arr.len if (i >> j) & 1:
      subset.push arr[j]
    result.push subset
  }

  return result.sortBy |a, b| {
    let countA = a.reduce 0, |c,, i| c + 1
    let countB = b.reduce 0, |d,, i| d + 1
    if countA != countB:
      countA - countB
    for let i in 0 ..< min a.len b.len if a[i] != b[i]:
      a[i] - b[i]
    a.len - b.len
  }
}

// infix function chaining style
let sortedPowerSet = |arr| 0 ..< 1 << arr.len
  \sort\ |a, b| (-) ([a, b] \map\
      |k| (arr \reduce\ 0, |c,, i| c + ((k >> i) & 1))
    ) || arr \reduce\ 0, |d,, i| d || ((b >> i) & 1) - ((a >> i) & 1)
  \map\ |e| (arr \filter\ |, i| (e >> i) & 1)

// LINQ style 
func sortedPowerSet(arr: i32[]): i32[][] = (
  from let i in 0 ..< (1 << arr.len)
  select (
    from let j in 0 ..< arr.len
    where (i >> j) & 1
    select arr[j]
  ) as let subset
  sort by subset.len
  then by (
    from let a, b
    where a.len != b.len
    select a.len - b.len
  ) then by (
    from let i in 0 ..< min(a.len, b.len)
    where a[i] != b[i]
    select a[i] - b[i]
  ) then by a.len - b.len
)

// Objective-C style
func sortedPowerSet(arr: i32[]): i32[][] {
  let result: i32[][] = []

  [0 ..< 1 << arr.len each: |i| {
    let subset: i32[] = []
    [0 ..< arr.len each: |j| 
      if (i >> j) & 1: subset.push arr[j]]
    [result push: subset]
  }]

  return [result sortBy: |a, b| {
    let countA = [a reduce: 0, |c,, i| c + 1]
    let countB = [b reduce: 0, |d,, i| d + 1]
    if countA != countB: return countA - countB
    for let i in 0 ..< min(a.len, b.len) if a[i] != b[i]:
      return a[i] - b[i]
    a.len - b.len
  }]
}

// Clojure style
func sortedPowerSet(arr: i32[]): i32[][] = (
  (mut (type i32[][]) result [])

  (for (let i) in (..< 0 (<< 1 arr.len))) (
    (mut (type i32[]) subset [])
    (for (let j) in (..< 0 arr.len)) (
      (if (& 1 (>> i j)) 
        (push subset arr[j])
      )
    )
    (push result subset)
  )

  (return (sortBy result (|a, b| (
    (let (type i32) countA (reduce a 0 (|c,, i| (+ c 1))))
    (let (type i32) countB (reduce b 0 (|d,, i| (+ d 1))))
    (if (!= countA countB)
      (- countA countB)
    )
    (for (let i) in (..< 0 (min a.len b.len))) (
      (if (!= a[i] b[i])
        (- a[i] b[i])
      )
    )
    (- a.len b.len)
  ))))
)

// JSX style
<func (type i32[]) $sortedPowerSet(arr: type i32)>
  <mut (type i32[][]) $result=[]/>
  <for let=i in=(0 ..< 1 << arr.len)>
    <mut (type i32[]) $subset=[]/>
    <for let=j in=(0 ..< arr.len)> 
      <if ((i >> j) & 1)>
        subset.push arr[j]
      </if>
    </for>
    result.push subset
  </for>
  result.sortBy |a, b| <>
    <let (type i32) $countA=(a.reduce 0, |c,, i| c + 1)/>
    <let (type i32) $countB=(b.reduce 0, |d,, i| d + 1)/>
    <if (countA != countB)>
      <return (countA - countB)/>
    </if>
    <for let=i in=(0 ..< min a.len b.len)>
      <if (a[i] != b[i])>
        <return (a[i] - b[i])/>
      </if>
    </for>
    <return (a.len - b.len)/>
  </>
  <return $result/>
</>

for let i in sortedPowerSet [1...16]:
  echo i

// shader language subset example (WGSL-like)
shader MazeGenerator {
  struct Uniforms { prop mazeSize: n32, numWalls: n32 }
  struct WallsArray { prop values: n32[] }
  uniform mut<group 0, binding 0> uniforms: Uniforms
  storage mut<group 0, binding 1> walls: n32[]
  storage mut<group 0, binding 2> wallsArray: WallsArray

  func getCellIndex(cellCoords: Vec2<i32>): i32 {
    let size = i32 uniforms.mazeSize
    cellCoords.y * size + cellCoords.x
  }

  func coinFlip(p: Vec2<f32>): f32 {
    mut p3: Vec3<f32> = fract <| Vec3 p.xyx * 0.1031
    p3 += dot p3 (p3.yzx + 33.33)
    step 0.5 (fract (p3.x + p3.y) * p3.z)
  }

  // Carve walls for a given cell at random
  proc randomCarveCellWalls(cellCoords: Vec2<i32>) {
    let cellIndex: i32 = getCellIndex cellCoords

    let size = i32 uniforms.mazeSize
    let numWalls = i32 uniforms.numWalls

    const tWallType: i32 = 0 // top
    const rWallType: i32 = 1 // right
    const bWallType: i32 = 0 // bottom
    const lWallType: i32 = 1 // left

    // isOnEdge -> Vec2(isMostLeftEdge, isMostBottomEdge)
    mut isOnEdge: Vec2<bool> = cellCoords == Vec2 0

    // main body: bottom and left edges
    let bottomNotLeft: f32 = coinFlip <| Vec2<f32> cellCoords
    let bWallIndex: i32 = cellIndex * 2 + bWallType
    let lWallIndex: i32 = cellIndex * 2 + lWallType
    let carveBottom: f32 = mix bottomNotLeft 1.0 (f32 isOnEdge.x)
    let carveLeft: f32 = mix (1.0 - bottomNotLeft) 1.0 (f32 isOnEdge.y)
    wallsArray.values[bWallIndex] = n32 bottomNotLeft
    wallsArray.values[lWallIndex] = n32 <| 1.0 - bottomNotLeft
  }

  compute proc<threadGroup 8 8> main(%id: Vec3<n32>) {
    randomCarveCellWalls <| Vec2<i32> %id.xy
  }
}

// using the various sortedPowerSet implementations
for let i in sortedPowerSet [1...16]:
  echo i

// LINQ-style queries
let formatPowerSet = |a: i32[][]|: str =
  a.iter(iter: from let (subset: i32[]) in a where subset.len > 0
    select '[' ++ [subset map: str x join: ','] ++ ']'
  ).join ', '

print <| formatPowerSet sortedPowerSet [1..<10]

// function call with different argument types
funcName(arg1: 10, &mut arg2: 2, stat arg3: {k: v} as MyType)
v = #{a: pub|*a| a + 1}

// Style DSL example
style style͏ {
  x: 100px
  y: 100px
  background: :blue
  color: #ff5733
  path: 'M 10 10
    H 90
    V 90
    H 10
    Z' // SVG path data
  customKey: addedValue
  dynamic[key]-sub[key]: dynamicValue

  @media(max-width: 600px)
    background: :red

  @keyframes slidein
    from͏(transform: translateX 0%)
    to͏(transform: translateX 100%)

  @fontFace
    fontFamily: 'MyFont'
    src: url '../fonts/myfont.woff2', format :woff2

  ^hover
    color: :green

  &active
    color: :yellow

  /* Nested selectors */
  .container {
    display: :flex
    flexDirection: :column

    .item {
      margin: 10px
      padding: 5px
    }
  }

  animation: slideIn 3s :easeInOut :infinite :alternate
}

// CSS codegen example
style {
  for let i in arr: .item-[i] {
    color: if i % 2 == 0: :red else :blue
    width: (100 + i * 10)px
    opacity: i / len arr
  }
  additional_style: true
}

for let item, index in items:
  print $"Item $index: $item.name"

// cursed C++ pointers
var val: i32* (*(*(**[]) (i8, i32* i32*)) []) (i8**, i32** ()) =

// simple linked list node
struct Node {
  let value: i32
  let next: *Node

  func Node(value: i32): *Node {
    let node = unsafe { malloc Node }
    node.value = value
    node.next = null
    return node
  }
}

let head: *Node = Node 1
head.next = Node 2
head.next.next = Node 3
head.next.next.next = null
auto current: *Node = head
while current != null {
  print current.value
  current = current.next
}

// stropping keywords with invisible characters
const͏ let͏ var var͏: in͏ i32 = 10
scope for͏ for let in͏ in [var͏ alloc: init: release:]:
  print in͏

// jsx with inline code
<div>
  for item in items:
    <span .item-[item.id]=item.id> item.name </span>
</div>

// JSX control structures
<for let=i in=(0...10)>
  <if (x % 2 == 0)>
    <span>$"Even: $i"</span>
  <elif (x % 3 == 0)/>
    <span>$"Divisible by 3: $i"</span>
  <else/>
    <span>$"Other: $i"</span>
  </if>
</for>